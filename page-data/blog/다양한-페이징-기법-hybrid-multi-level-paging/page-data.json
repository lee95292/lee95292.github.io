{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/다양한-페이징-기법-hybrid-multi-level-paging/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"페이징-기법의-문제점\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"페이징 기법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법의 문제점</h3>\n<p>앞선 글에서 소개한 페이징 기법에서는 페이지의 크기를 4KB로 가정했습니다. 그러나 현대에는 메모리의 크기가 4GB를 넘어 64GB까지도 사용됩니다.</p>\n<p>이런 컴퓨터에서 4KB의 페이지를 사용한다면 페이지 개수가 10^6 ~ 10^7까지도 커지게 됩니다.</p>\n<p>페이지 테이블은 각 프로세스마다 가지는 자료구조이고, <strong>“커널메모리”에 저장</strong>되는 자료이다 보니, <strong>페이지 테이블이 커지면 커질수록</strong> <strong>메모리 가용역역이 작아집니다.</strong></p>\n<p>또한, Segmentation에서는 해결된 메모리의 보호와 공유가 어렵다는 문제가 남아있습니다.</p>\n<h3 id=\"페이지-테이블-크기-문제-해결방법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95\" aria-label=\"페이지 테이블 크기 문제 해결방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 크기 문제 해결방법</h3>\n<p><strong>(1) 더 큰 페이지 크기</strong></p>\n<p>단순하게 생각하면 페이지 크기를 더 키우면 페이지 테이블 사이즈는 작아집니다.</p>\n<p>이를 통해 <strong>(1)디스크 접근횟수를 줄이고 (2)페이지 테이블크기를 줄이는</strong> 효과를 얻을 수 있습니다.</p>\n<p>메모리 크기가 커짐에 따라 페이지 사이즈를 키울수록 이 방법은 몇 가지 <strong>단점</strong>이 있습니다</p>\n<ol>\n<li>내부 단편화가 더 크게 발생합니다.</li>\n<li>큰 페이지를 로드했지만, 사용되는 비율이 적어 <strong>메모리 사용률이 줄어듭니다</strong>.</li>\n</ol>\n<p><strong>(2) Multi Level Paging 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093248-29394fe1-480b-41af-8c30-ed6745922558.png\" alt=\"1\"></p>\n<p>Multi Level Paging기법에서는 페이지 디렉터리를 통해 하나의 레벨을 추가합니다.</p>\n<p>또한 페이지 디렉터리 테이블(PDT)에는 valid bit가 존재합니다. 앞선 페이징 방법에서는 Heap공간에서 사용중인 페이지를 valid bit로 판별했던 반면, <strong>PDT에서의 valid bit는 PDE가 가르키는 페이지 테이블의 엔트리들 중 하나라도 유효한지에 대한 여부입니다(중요) → Heap 또는 Stack의 빈공간으로 인해 사용되는 메모리 낭비를 없애줌.</strong></p>\n<p><strong>장단점</strong></p>\n<p>페이징에서는 페이지 번호를 통해 페이지 테이블에 접근했으므로, 해당 페이지가 스왑 스페이스에 있어도 하나의 페이지  테이블을 가지고있어야 했습니다.</p>\n<p><strong>Multi Level Paging방법에서는 PDT의 valid bit가 1인 PMT에 대해서만 메모리 공간을 할당하므로 메모리 공간 효율성이 뛰어납니다.</strong></p>\n<p>그러나 Multi Level로 페이지 테이블이 존재하는 경우 가상주소 변환에 있어 메모리 접근을 N회 해야한다는 단점이 있습니다. (TLB로 완화할 수 있습니다)</p>\n<p>이처럼 MultiLevel Paging에는 시간-공간 등가교환이 존재합니다.</p>\n<p><strong>(번외) Segmentation/Paging Hybrid 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093250-bb5c0f90-8f66-4cc1-8b47-ab1a13a3f84b.png\" alt=\"2\"></p>\n<p>Hybrid기법은 Segmentattion과 Paging기법을 혼합한 방법입니다.</p>\n<p>가상 메모리를 논리 단위의 세그먼트로 분할한 뒤, 이를 또 다시 페이지로 나눕니다.</p>\n<p>그렇기에 (그림 우측 상단의)가상 메모리 주소는 세그먼트 비트, 가상 페이지 번호인 Virtual Page Number,와 페이지 내에서의 Offset으로 이루어져 있습니다.</p>\n<p>즉, (S,P,D)값을 통해 물리 메모리 주소를 얻는것인데요, 방법은 아래와 같습니다.</p>\n<p><strong>1) 세그먼트 매핑 테이블 접근</strong></p>\n<p>세그먼트별로 존재하는 SMT에서 S번째 엔트리를 찾아갑니다. 여기서는 <strong>세그먼트 길이 검증, Protection Bit를 통해 자원의 공유와 보호를 수행</strong>합니다.</p>\n<p>또한 세그먼트에 대한 페이징 정보를 가지고있는 페이지 테이블 주소를 MMU에 전달합니다.</p>\n<p>물리메모리에는 Page 단위로 올라가므로 Residence bit는 존재하지 않습니다.</p>\n<p><strong>2) 페이지 매핑 테이블 접근</strong></p>\n<p>SMT에서 얻은 S(j)의 PMT 주소와 가상 페이지 번호인 VPN을 통해 물리 메모리에서 페이지의 주소를 획득합니다.</p>\n<p>이 때 Residence bit를 확인해 페이지가 존재하는지 확인하고 존재하지 않는다면 Page Fault Trap을 발생시켜 페이지 교체 알고리즘을 수행합니다.</p>\n<p><strong>3) PFN 획득 및 메모리 접근</strong></p>\n<p>PMT에서는 PFN을 얻었고, 여기에 페이지 크기를 곱하면 물리 메모리상 주소를 알 수 있습니다.</p>\n<p>Hybrid 기법은 페이징을 통해 메모리 사용률을 높혀준다는 장점과 세그멘테이션을 통해 보호와 공유를 용이하게 해준다는 장점이 있습니다.</p>\n<p>그러나 Hybrid방법에도 한계점은 존재합니다.</p>\n<ol>\n<li>여전히 페이지 테이블 크기가 많은 메모리 공간을 차지한다는 단점과</li>\n<li>Direct Mapping의 경우 가상 메모리 변환 시, 3회의 메모리 접근이 필요하다는 점입니다.\n<ol>\n<li>이는 TLB 활용으로 극복 가능합니다.</li>\n</ol>\n</li>\n</ol>\n<p>Fact Check</p>\n<ul>\n<li>\n<p>Protection Bit가 세그먼트에서 더 효율적인 이유</p>\n<p>→ 횟수에따른 용이성일것으로 생각, paging에서는 다음주소 참조시에도 또 확인해야해서</p>\n</li>\n<li>\n<p>Page Directory Table에서 또는 Page Table에서 Valid bit가 0인경우 swap공간에 있기는 한지?</p>\n<ul>\n<li>Multi Level Paging에서는 valid 가 0인 경우에 대해서 Page를 할당하지도 않는다! 따라서 swap공간에 있는게 아니라 사용하게되면 페이지를 다시 할당함.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","fields":{"slug":"다양한-페이징-기법-hybrid-multi-level-paging"},"frontmatter":{"title":"다양한 페이징 기법 [ Hybrid, Multi Level Paging]","date":"08.03.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"다양한-페이징-기법-hybrid-multi-level-paging","prev":{"excerpt":"불연속 메모리 할당기법 세그멘테이션, 페이징은 대표적인 불연속 메모리 할당기법입니다. 각각 세그먼트, 페이지라는 단위로 프로그램을 나누고 페이지/세그먼트 테이블을 통해 가상/물리 메모리를 매핑, 연속적인 가상 주소공간을 사용할 수 있도록 합니다. 특징 및 연속 할당기법과의 차이 1 여전히 명령어는 가상주소를 기반으로 실행됩니다. Segmentation 프로그램을 의미있는 단위인 Heap, Stack, Code, Data…","html":"<h2 id=\"불연속-메모리-할당기법\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9%EA%B8%B0%EB%B2%95\" aria-label=\"불연속 메모리 할당기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불연속 메모리 할당기법</h2>\n<p><strong>세그멘테이션, 페이징</strong>은 대표적인 불연속 메모리 할당기법입니다. 각각 세그먼트, 페이지라는 단위로 프로그램을 나누고 페이지/세그먼트 테이블을 통해 가상/물리 메모리를 매핑, 연속적인 가상 주소공간을 사용할 수 있도록 합니다.</p>\n<h3 id=\"특징-및-연속-할당기법과의-차이\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9%EA%B8%B0%EB%B2%95%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"특징 및 연속 할당기법과의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징 및 연속 할당기법과의 차이</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093229-eeb1540a-35fd-4f8c-905a-e454c845160a.png\" alt=\"1\"></p>\n<p>여전히 명령어는 가상주소를 기반으로 실행됩니다.</p>\n<p><strong>Segmentation</strong></p>\n<p>프로그램을 의미있는 단위인 Heap, Stack, Code, Data등 프로그램을 구성하는 논리적 단위인 “세그먼트”로 분할해 메모리에 적재하는 방법입니다.</p>\n<p><strong>Paging</strong></p>\n<p>프로세스를 고정된 크기(intel x86의 경우 4kb)의 page block으로 프로그램을 나눠 물리 메모리에 할당하는 방법</p>\n<h2 id=\"물리메모리-매핑-과정\" style=\"position:relative;\"><a href=\"#%EB%AC%BC%EB%A6%AC%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A7%A4%ED%95%91-%EA%B3%BC%EC%A0%95\" aria-label=\"물리메모리 매핑 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>물리메모리 매핑 과정</h2>\n<p><strong>가상 주소 공간과 실제 메모리 주소의 매핑은 각각 페이지와 세그먼트 매핑 테이블 (PMT, SMT)가 담당합니다.</strong></p>\n<h3 id=\"페이징-기법에서-매핑과정-direct-mapping\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-direct-mapping\" aria-label=\"페이징 기법에서 매핑과정 direct mapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Direct Mapping</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093232-74c55ebc-45cb-4529-b1c9-5843031ed337.png\" alt=\"2\"></p>\n<p><strong>기본 가정</strong></p>\n<p>32bit 컴퓨터로 가정합니다 → 하나의 명령이 처리할 수 있는 데이터 양(word)가 32bit, 한 워드에 최대로 표시할 수 있는 메모리 주소는 2^32 byte이므로 최대 메모리가 4GB 입니다.</p>\n<p>이 때 페이지 크기를 설정해봅시다. 페이지 크기는 내부 단편화 및 로드 속도를 고려해 정하게 되는데, 윈도우 시스템에서는 4KB로 사용한다고 합니다.</p>\n<p>그렇다면 이론상으로는 4GB(2^32 Byte)의 메모리상에 4KB(2^12 Byte)의 페이지가  2^20개 존재할 수 있습니다.</p>\n<p><strong>(1) 명령어 실행</strong></p>\n<p>그렇기에 명령어 32bit는 그림 우측 상단처럼 <strong>20bit의 VPN과 12bit의 Offset</strong>(페이지 내 데이터 위치)로 구분할 수 있습니다. 이를 각각 P,D라고 칭합니다.</p>\n<p><strong>(2)PPN(Physical Page Number) 조회</strong></p>\n<p>1에서 얻은 가상 페이지 주소(P)는 페이지 테이블의 행 번호입니다. 페이지 테이블에서는 VPN(가상페이지번호)을 통해 PPN(물리메모리 페이지번호)을 얻을 수 있습니다.</p>\n<p><strong>(3) 물리 메모리 주소 반환</strong></p>\n<p>2과정에서 얻은 PPN(Z)과 1과정에서 얻은 페이지 내 변위 Offset(D)를 통해 물리 메모리 주소를 정확하게 알 수 있습니다 ( = Z + D ) 해당 주소의 명령은 CPU로 전달됩니다.</p>\n<p>가상/물리 메모리에서 Page Number는 바뀌기때문에 PPN, VPN으로 구분하지만 <strong>Offset은 Page 내에서 상대적인 위치이므로 물리메모리에서도 동일하게 사용할 수 있습니다.</strong></p>\n<p><strong>단점</strong></p>\n<p>Page Table은 프로세스별로 하나씩 가지고있으며 이는 <strong>커널 메모리(PCB)에 존재</strong>합니다.</p>\n<p><strong>따라서 메모리 데이터를 얻기 위해 메모리를 2회 접근하는 오버헤드가 발생합니다.</strong></p>\n<h3 id=\"페이징-기법에서-매핑과정-associate-mapping--tlb\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-associate-mapping--tlb\" aria-label=\"페이징 기법에서 매핑과정 associate mapping  tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Associate Mapping  (TLB)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093235-7d5b2f89-6936-467f-a74b-5162bdae3305.png\" alt=\"3\"></p>\n<p>출처 : <a href=\"http://slideplayer.com/slide/5823226/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://slideplayer.com/slide/5823226/</a></p>\n<p>CPU칩셋 내부에 고속 하드웨어 서포트가 추가됩니다. TLB (Translation Lookaside Buffer)는 Page Table과 비슷한 구조를 띠지만, CPU 내에 위치해 병렬적으로 테이블을 탐색해 VPN → PPN 전환 속도를 더욱 빠르게 해줍니다.</p>\n<h3 id=\"페이징-기법에서-매핑과정-hybrid-small-tlb\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-hybrid-small-tlb\" aria-label=\"페이징 기법에서 매핑과정 hybrid small tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Hybrid (Small TLB)</h3>\n<p>TLB는 가격이 비싼 하드웨어이므로, 모든 페이지 테이블 정보를 담을만큼 충분한 크기를 가질 수 없습니다.</p>\n<p>시간 및 공간 지역성원리를 활용해, LRU로 교체되는 작은 TLB를 사용합니다.</p>\n<p>TLB 미스가 날 경우 TLB접근시간 + 메모리 접근 및 교체시간이 추가로 소요됩니다.</p>\n<h3 id=\"세그먼테이션-기법에서-매핑-과정\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91-%EA%B3%BC%EC%A0%95\" aria-label=\"세그먼테이션 기법에서 매핑 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그먼테이션 기법에서 매핑 과정</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093237-af52f4d4-1353-4652-a3e6-f48cb6951695.png\" alt=\"4\"></p>\n<p><strong>페이징 방법과의 차이</strong></p>\n<p>페이징에서 방법과 많은 부분이 유사합니다. 그러나 의미 단위인 “세그먼트”로 메모리를 나누었으므로 가상주소에서 최상위 N개 비트를 세그먼트 번호로 사용하면 됩니다.</p>\n<p>또한 페이징에서는 페이지가 고정 크기이므로 PPN을 통해 메모리에 접근할 수 있었지만 물리 메모리에서 세그먼트는 시작주소가 일정하지 않습니다. 그러므로 시작 주소를 직접 가지고있고, 세그먼트 길이도 제각각이므로 세그먼트 테이블에서 관리해 허용되지 않는 영역에 접근하는지 체크합니다. 즉, <strong>Offset이 세그먼트 길이보다 크면 Segmentation Fault를 발생시킵니다.</strong></p>\n<p><strong>세그먼트 크기</strong></p>\n<p>스택,힙,데이터, 코드의 대표적인 세그먼트 분류로 나누게 되면 최상위 2개 비트만으로 프로세스의 모든 세그먼트를 표현할 수 있습니다. 이를 <strong>대단위 세그먼트</strong> 라고 합니다.</p>\n<p>대단위 세그먼트에서는 외부 단편화 문제가 더 두드러지게 나타나고 세그먼트 로드 속도가 느리고 자주 사용되지 않는 데이터도 함께 로드되는 단점이 있습니다. 이를 위해 세그먼트를 더 세부적인 단위로 나누는 방법을 <strong>소단위 세그먼트</strong>라고 합니다.</p>\n<p>소단위 세그먼트는 프로세스당 세그먼트 수가 더 많으므로 세그먼트 테이블이 더 커진다는 단점이 있지만, 미사용 세그먼트를 구분해 메모리 사용률을 높일 수 있다는 장점이 있습니다.</p>\n<h3 id=\"전반적인-비교--segmentation-vs-paging\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EB%B0%98%EC%A0%81%EC%9D%B8-%EB%B9%84%EA%B5%90--segmentation-vs-paging\" aria-label=\"전반적인 비교  segmentation vs paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전반적인 비교 : Segmentation Vs Paging</h3>\n<p>세그멘테이션은 가변 길이의 세그먼트로 가상주소를 분리했으므로 외부 단편화가 발생할 수 있지만 논리 단위의 데이터 공유 및 보호가 용이합니다. 대단위 세그먼트로 분리하는 경우 메모리 사용률이 적어진다는 단점이 있지만, 소단위 세그먼트를 통해 극복할 수 있습니다. ( 세그먼트 테이블 크기와 Trade-Off )</p>\n<p>페이징은 고정 크기의 페이지로 가상 주소를 분리했으므로 내부 단편화가 발생할 수 있고 보호/공유 측면에서 복잡성이 존재하지만, 메모리 사용률 측면에서 높은 성능을 보이며 페이지 테이블</p>\n<h2 id=\"매핑-테이블로-알아보는-페이지세그먼트-변환\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%ED%95%91-%ED%85%8C%EC%9D%B4%EB%B8%94%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EB%B3%80%ED%99%98\" aria-label=\"매핑 테이블로 알아보는 페이지세그먼트 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매핑 테이블로 알아보는 페이지/세그먼트 변환</h2>\n<p>앞선 그림에서 확인한 세그먼트/페이지 매핑 테이블에는 주소 매핑을 위한 정보 말고도 각각을 설명하는 많은 정보를 담고있고 보호 및 효율을 위해 추가적인 동작을 합니다.</p>\n<p><strong>공통 구성요소</strong></p>\n<ul>\n<li>Present Bit : 물리메모리 상에 로드되어있는지 (Swap-in 여부, Swap Device에 존재할 경우 0 )</li>\n<li>Valid Bit : 스택 또는 힙의 미사용 공간은 invalid한 공간으로, 접근할 수 없음. 이를 마킹해 트랩을 통해 잘못된 영역으로의 접근을 막는다.</li>\n<li>Dirty Bit: 페이지/세그먼트가 메모리에 로드된 이후 변경되었는지 체킹해 이 비트가 세팅된 데이터는 주기적으로 메모리로 Flush작업을 한다.</li>\n<li>Protection Bit: 프로세스별로 해당 페이지에 RWX Access 권한을 마킹한 비트, 페이지 공유 및 보호를 가능하게 함.</li>\n<li>Swap Address: Swap device상에서 주소</li>\n</ul>\n<p><strong>페이지 테이블  구성요소</strong></p>\n<ul>\n<li>PPN: 물리메모리 페이지 번호</li>\n</ul>\n<p><strong>세그먼트 테이블 구성요소</strong></p>\n<ul>\n<li>Segment Address: 세그먼트 주소</li>\n<li>Segement Length: 세그먼트 크기</li>\n</ul>\n<h3 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h3>\n<p>세그멘테이션에서 가변 데이터인 스택, 힙에 대해 추가공간이 필요하면 어떻게할까?</p>\n<p>→ 런타임에서 길이가 증가/감소, 추가적인 빈 공간 리스트에 할당</p>\n<p>세그먼트 테이블은 프로세스별로 존재하는가?</p>\n<p>→Yes</p>\n<p>Valid bit가 Segmentation table 에서도 있는지 확인</p>\n<h3 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>\n<p><a href=\"https://talkingaboutme.tistory.com/entry/Memory-Sample-Memory-System\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://talkingaboutme.tistory.com/entry/Memory-Sample-Memory-System</a></p>","id":"e833f569-08c9-5577-a07b-57804ec11128","fields":{"slug":"세그멘테이션과-페이징-비교"},"frontmatter":{"date":"2023-02-27","title":"세그멘테이션과 페이징 (+ 비교 )","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},"next":{"excerpt":"물리메모리를 필요로 하는 프로세스가 N개 있다고 가정합시다.\nN개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 프로세스들이 필요한 가상공간의 크기 총 합이 물리메모리의 크기보다 커지면 우리는 N개의 프로그램을 동시에 실행하지 못할 것입니다. Swap Space 이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space…","html":"<p>물리메모리를 필요로 하는 프로세스가 N개 있다고 가정합시다.\nN개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 프로세스들이 필요한 가상공간의 크기 총 합이 물리메모리의 크기보다 커지면 우리는 N개의 프로그램을 동시에 실행하지 못할 것입니다.</p>\n<h3 id=\"swap-space\" style=\"position:relative;\"><a href=\"#swap-space\" aria-label=\"swap space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap Space</h3>\n<p>이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space에는 자주 사용되지 않는 페이지가 위치합니다.</p>\n<p>물리메모리에서 자주 사용되지 않는 페이지가 Swap Space로 옮기는것을 Swap-out,</p>\n<p>반대로 Swap Space에 존재하는 페이지를 사용하기 위해 물리 메모리에 옮기는것을 Swap-in</p>\n<p>이라고 합니다.</p>\n<h3 id=\"가상-메모리-지원을-위한-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A7%80%EC%9B%90%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"가상 메모리 지원을 위한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 지원을 위한 방법</h3>\n<p>이렇듯 스왑 공간까지 사용해 메모리를 더 큰것처럼 사용할 수 있도록 하는 방법을 가상 메모리(VIrtual Memory)라고 합니다.</p>\n<p>가상 메모리를 사용을 지원하기 위해서는 Swap-in 또는 Swap-out 시 참조할 <strong>디스크상 페이지 주소</strong>를 알고있어야 합니다. 두번째로는 <strong>Present Bit</strong>를 알고있어야 합니다. Present Bit는 페이지 테이블 상의 페이지가 실제 물리메모리에 적재되어있는지 여부를 나타내는 데이터입니다.</p>\n<p><strong>Present Bit가 1인 경우</strong></p>\n<p>물리메모리에 데이터가 존재합니다. 이 경우 일반적인 페이징 방법처럼 PFN을 MMU로 전달해 CPU가 메모리에 접근 할 수 있습니다.</p>\n<p><strong>Present Bit가 0인 경우</strong></p>\n<p>해당 페이지 엔트리는 물리메모리에 없고 Swap Space에 존재함을 의미합니다. 이를 <strong>Page Fault</strong>라고 합니다.</p>\n<p>이 때 MMU는 인터럽트(Page Fault Trap)을 발생시켜 Page Fault Handler를 동작하고 여기서 페이지 교체 작업이 발생합니다.</p>\n<p>Page Fault Handler는 Page Table Entry의 Present Bit를 1로 변경하고, 디스크 데이터를 물리메모리로 적재하는 I/O작업을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093270-5092c56f-513e-4842-8bd9-320ed0dc6557.png\" alt=\"1\"></p>\n<p>앞서 Page Fault Handler를 통해 디스크에서 물리 메모리에 페이지를 적재한다고 했습니다. 그렇다면 위 그림을 보고 의문점이 생겨야 합니다.</p>\n<p><strong>Swap out을 언제 실행해야 하는가?</strong></p>\n<p>프로그램이 언제든 새로 시작될 수 있을 뿐만 아니라 운영체제는 특성상 항상 어느정도의 여유공간을 확보하고 있어야합니다. 이러한 운영체제 특성상 물리메모리가 가득 찼을 때만 Swap out을 하게되면 많은 문제점들이 발생합니다.</p>\n<p>이때문에 운영체제는 메모리 여유공간의 **최댓값(High watermark), 최솟값(Low watermark)**을 가지고있습니다. <strong>여유공간이 최솟값보다 적어지면 여유공간의 크기가 최댓값보다 작을때까지 여유공간을 확보</strong>합니다.  해당 스레드는 페이지 데몬(page daemon), 스왑 데몬(swap daemon)이라고 불리며, 충분한 여유공간이 확보될때까지 동작하다가 확보되면 백그라운드 스레드로 돌아갑니다.</p>\n<p><strong>Swap-out을 수행하는데, 어떤 페이지를 Swap Out 해야하는가</strong></p>\n<p>뒤이어 페이지 교체 정책에서 설명합니다.</p>\n<h2 id=\"페이지-교체-정책\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 정책</h2>\n<p>페이지 교체 정책에 대해 이야기하기 전에 교체 정책의 성능을 측정하는 방법에 대해 알아보아야 합니다.</p>\n<p><strong>AMAT(Average Memory Access Time): 평균 메모리 접근시간 = P(Hit) * T(M) + P(Miss) * T(D)</strong></p>\n<p>설명하자면, 스왑공간을 사용하는 가상 메모리 시스템의 평균 메모리 접근시간은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">P(Hit): 캐시 히트 확률 * T(M): 메모리 접근 시간을 곱해준 값 +\nP(Miss):페이지 폴트 확률과 T(D): 디스크 접근 시간</code></pre></div>\n<h3 id=\"최적-교체-방식-optimal-replacement-policy\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EA%B5%90%EC%B2%B4-%EB%B0%A9%EC%8B%9D-optimal-replacement-policy\" aria-label=\"최적 교체 방식 optimal replacement policy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 교체 방식 (Optimal Replacement Policy)</h3>\n<p>최적 교체방식의 원리는 간단합니다. <strong>“가장 나중에 참조할 페이지를 축출한다”</strong> 입니다.</p>\n<p>최적 교체방식은 이상적인 방법이지만, 가장 나중에 참조할 페이지 찾기라는 <strong>미래를 예측하는 불가능한 과정을 포함</strong>합니다.</p>\n<p>최적의 방법은 비교 기준으로만 사용되며, 비교하고자 하는 알고리즘이 정답에 얼마나 가까운지 알 수 있습니다.</p>\n<h3 id=\"lruleast-recently-used\" style=\"position:relative;\"><a href=\"#lruleast-recently-used\" aria-label=\"lruleast recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU(Least Recently Used)</h3>\n<p>LRU방식은 과거 메모리 접근에 대한 정보를 사용합니다. 이름 그대로 <strong>가장 먼 시점에 사용된 페이지를 교체합니다.</strong></p>\n<p>메모리 접근 정보 중에서 **최근성(recency)**를 사용한 방법입니다. 얼마나 최근에 접근했는지에 대한 정보를 가지고있습니다. 더 최근에 접근한 페이지일수록 가까운 시점에 다시 접근할 확률 이 높다는 특성인 **캐시 지역성의 원칙(Principle of locality)**이라는 특성에 기반을 둡니다.</p>\n<p>이처럼 메모리 접근 정보에는 빈도(frequency)도 있지만, MFU(Most Frequently Used)알고리즘은 캐시의 지역성 특징과 맞지 않으므로 효율적으로 동작하지 않습니다.</p>\n<p>예를들어 100번째 페이지를 5000회 접근한 이후 한번도 접근하지 않는다면 빈도수는 높아서 계속 물리메모리에 남아있지만 사용되지는 않습니다.</p>\n<p>LRU는 메모리 교체 방식중 효율이 가장 좋은 방법으로, 주로 사용되는 페이지 교체 알고리즘입니다.</p>\n<h3 id=\"간단한-방식들-fifo-random-select\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B0%A9%EC%8B%9D%EB%93%A4-fifo-random-select\" aria-label=\"간단한 방식들 fifo random select permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 방식들( FIFO, Random Select)</h3>\n<p><strong>First In First Out : 선입선출</strong></p>\n<p>먼저 들어온것이 먼저 나갑니다. 매우 간단한 알고리즘이지만 성능이 떨어집니다.</p>\n<p><strong>Ramdom Select: 무작위 선택</strong></p>\n<p>무작위로 Swap out될 페이지를 선택합니다. 해당 방법은 그때마다 수행 결과가 달라집니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"17750e88-7178-50d4-b121-377268c8ac01","fields":{"slug":"페이지-교체와-정책-swap"},"frontmatter":{"date":"2023-03-09","title":"페이지 교체와 정책 (Swap)","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}