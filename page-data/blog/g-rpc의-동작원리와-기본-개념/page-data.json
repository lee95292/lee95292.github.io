{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/g-rpc의-동작원리와-기본-개념/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"grpc-개요\" style=\"position:relative;\"><a href=\"#grpc-%EA%B0%9C%EC%9A%94\" aria-label=\"grpc 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 개요</h1>\n<h2 id=\"grpc-소개-pros--cons\" style=\"position:relative;\"><a href=\"#grpc-%EC%86%8C%EA%B0%9C-pros--cons\" aria-label=\"grpc 소개 pros  cons permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 소개, Pros &#x26; Cons</h2>\n<p>MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다.</p>\n<ul>\n<li>[+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다.</li>\n<li>[+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다.\n<ul>\n<li><strong>Binary framing layer</strong>: 데이터를 <strong>바이너리로 이뤄진 프레임으로 전달, 송/수신 레이어에서 다시 재조립</strong>하는 기능을 제공하는 HTTP2에서 도입된 계층</li>\n<li><strong>Multiflexing</strong>지원: Binary framing을 통해 가능해짐. 여러 스트림에서 양방향으로 frame을 통신. <strong>비동기, 양방향 데이터 통신</strong></li>\n<li>이외에도 서버 푸시, 스트림 우선순위 등의 특징과 함께 성능이 대폭 개선됨.</li>\n</ul>\n</li>\n<li>[-] 데이터 스키마 수정 시 서버 및 클라이언트 코드를 모두 변경해야합니다.</li>\n<li>[-] human readable하지 않습니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021105-c50f8ef0-6537-4060-98dc-f42dd517319c.png\" alt=\"1\">\n[그림] - Soap, REST, gRPC의 기본 데이터 전송 포멧의 장단점 비교</p>\n<h2 id=\"간단하게-요약해보는-grpc-매커니즘\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9A%94%EC%95%BD%ED%95%B4%EB%B3%B4%EB%8A%94-grpc-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"간단하게 요약해보는 grpc 매커니즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 요약해보는 gRPC 매커니즘</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021110-d92e6249-993d-4055-a541-de3e9bdf957d.png\" alt=\"2\"></p>\n<ul>\n<li>서버는 클라이언트 호출을 핸들링하고, 클라이언트는 서버와 같은 메서드를 실행하는 Stub을 작성한다.</li>\n<li>gRPC는 서로 다른 <strong>다양한 언어</strong>로 작성된 서버/클라이언트 사이에서 통신할 수 있다.</li>\n<li>gRPC는 <strong>서버의 메서드를 로컬 객체인것처럼 호출한다.</strong></li>\n</ul>\n<h2 id=\"protocol-buffer를-통해-동작\" style=\"position:relative;\"><a href=\"#protocol-buffer%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8F%99%EC%9E%91\" aria-label=\"protocol buffer를 통해 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protocol Buffer를 통해 동작</h2>\n<p>Protocol Buffer란, gRPC에서 구조화된 데이터를 직렬화하기 위한 오픈소스 메커니즘입니다. 언어와 플랫폼에 중립적으로 동작합니다. (영향을 받지 않습니다)</p>\n<p>자세한 스펙은 <a href=\"https://protobuf.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/</a> 를 참고해주세요!</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bool</span> has_ponycopter <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>gRPC는 서버와 클라이언간 이진 바이트 통신을 하기 위해 Protocol Buffer를 기본 전략으로 사용합니다.</p>\n<p>*.proto파일에 데이터 구조를 정의합니다. 직렬화하고싶은 데이터를 위와 같이 key-value필드로 매핑해 *.proto 파일로 작성합니다.</p>\n<h2 id=\"컴파일-및-메시지-인코딩\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%9D%B8%EC%BD%94%EB%94%A9\" aria-label=\"컴파일 및 메시지 인코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일 및 메시지 인코딩</h2>\n<p><strong>protoc</strong>은 프로토콜 버퍼 컴파일러입니다.</p>\n<p>이는 *.proto 파일에서 정의한 내용으로 <strong>특정 언어가 데이터에 접근할 수 있는 클래스파일을 생성</strong>합니다.</p>\n<p>name(), set_name()과 같은 메서드를 통해 <strong>raw bytes에서 메시지로 직렬화하거나 그 반대로 파싱</strong>할 수 있습니다.</p>\n<h2 id=\"동작\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91\" aria-label=\"동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작</h2>\n<ul>\n<li>서버 측에서 서버는 서비스에서 선언한 메서드를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리합니다. gRPC 인프라는 들어오는 요청을 디코딩하고 서비스 메서드를 실행하며 서비스 응답을 인코딩합니다.</li>\n<li>클라이언트에는 메시지를 서버와 동일한 방식으로 바라보는 <strong>stub</strong>이라는 객체를 통해 메시지와 파라미터를 인코딩해 rpc를 수행하고, 서버가 처리한 결과를 디코딩해 처리합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021107-2b48721b-bd09-421a-bd36-72ea21d11cc0.png\" alt=\"3\"></p>\n<blockquote>\n<p>출처 Geeks for geeks</p>\n</blockquote>\n<h2 id=\"grpc-요청-타입\" style=\"position:relative;\"><a href=\"#grpc-%EC%9A%94%EC%B2%AD-%ED%83%80%EC%9E%85\" aria-label=\"grpc 요청 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 요청 타입</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021109-7b7dacd0-f65d-45cc-b5b0-af7188288e7e.png\" alt=\"4\"></p>\n<p>stream을 통해 대량 데이터가 전달될 수도 있습니다. 그래도 gRPC의 프로그래밍 API에서는 대부분 비동기 처리를 지원하므로, stream data 및 단일 요청에 대해서도 Blocking없이 비동기적으로 처리 가능합니다.</p>\n<p><strong>Unary RPC</strong></p>\n<p>클라이언트에서 단일 요청을 보내고, 서버가 단일 응답을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Server Streaming RPC</strong></p>\n<p>클라이언트가 단일 요청을 보내고, 서버가 스트림을 통해 여러개의 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfReplies</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Clinet Streaming RPC</strong></p>\n<p>클라이언트가 스트림을 통해 여러게의 메시지를 보내고, 서버가 단일 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfGreetings</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Bidrectional Streaming RPC</strong></p>\n<p>클라이언트와 서버가 독립적인 스트림을 주고받으며</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">BidiHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h2>\n<ul>\n<li>server와 client의 stub간 동기화가 필요하지 않나?\n<ul>\n<li>→ 그렇다. protocol buffer를 사용하는 경우, 스키마를 공유하기 위해 스키마 정보를 가진 proto파일을 동기화해 컴파일하거나, 컴파일된 protob파일을 동기화해서 사용해야 한다.</li>\n</ul>\n</li>\n<li>stub을 웹 브라우저에 올릴 수 없는 이유?\n<ul>\n<li>→ 기술적으로는 가능하다. but 엄격한 타입 정의를 통해 통신이 이뤄지는데,만약 스키마 변경 시 end-user에게는 전달되지 않아 장애가 발생할 수 있음.</li>\n</ul>\n</li>\n<li>기존 RPC와는 어떤 차이가 있나?\n<ul>\n<li>gRPC의 경우 HTTP2을 통해 통신한다고 가정하고 구현했으므로, protocol buffer를 통해 binary data로 컴파일하고, binary frame으로 통신해 오버헤드가 적다. (기존 RPC에서는 주로 XML같은 text 기반으로 통신했으므로, 비효율적이다)</li>\n</ul>\n</li>\n<li>text기반 통신이 binary기반 통신에 비해 비효율적인 이유는 무엇인가?\n<ul>\n<li>문자를 제외한 number, boolean을 표현할 때, 사용하는 데이터 공간이 더 크고, 이는 통신 속도에도 영향을 미친다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"keyword\" style=\"position:relative;\"><a href=\"#keyword\" aria-label=\"keyword permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>keyword</h2>\n<p>gRPC, Protocol Buffer, Multiflex, Data access object, Binary framing, Async</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://grpc.io/docs/what-is-grpc/introduction/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://grpc.io/docs/what-is-grpc/introduction/</a></p>\n<p><a href=\"https://web.dev/performance-http2/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://web.dev/performance-http2/</a> - (Refer:HTTP2 spec, binary framing, multiflexing)</p>\n<p><a href=\"https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0</a> (refer: pros&#x26;cons of gRPC)</p>\n<p><a href=\"https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/</a></p>\n<p><a href=\"https://codingffler.tistory.com/28\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://codingffler.tistory.com/28</a></p>","fields":{"slug":"g-rpc의-동작원리와-기본-개념"},"frontmatter":{"title":"gRPC의 동작원리와 기본 개념","date":"23.01.2023","category":"tech","tags":["gRPC","gRPC study"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"g-rpc의-동작원리와-기본-개념","prev":{"excerpt":"JPA에서 엔티티를 작성하는 방법 JPA에서 **엔티티(Entity)**는 관계형 데이터베이스의 테이블과 대응하며, JPA가 관리하는 클래스를 말합니다. 이는 Java 클래스로 선언하며, 보통 domain 패키지에 포함되고, 아래와 같이 구성됩니다 기본 엔티티 매핑 방법 @Entity JPA에서 테이블과 매핑할 클래스는 @Entity 애너테이션을 필수로 붙여야 합니다. @Entity…","html":"<h1 id=\"jpa에서-엔티티를-작성하는-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa에서 엔티티를 작성하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서 엔티티를 작성하는 방법</h1>\n<p>JPA에서 **엔티티(Entity)**는 관계형 데이터베이스의 테이블과 대응하며, JPA가 관리하는 클래스를 말합니다.</p>\n<p>이는 Java 클래스로 선언하며, 보통 domain 패키지에 포함되고, 아래와 같이 구성됩니다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"기본-엔티티-매핑-방법-entity\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95-entity\" aria-label=\"기본 엔티티 매핑 방법 entity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 엔티티 매핑 방법 @Entity</h2>\n<p>JPA에서 테이블과 매핑할 클래스는 @Entity 애너테이션을 필수로 붙여야 합니다. @Entity 적용 시에는, 클래스가 아래 주의사항을 따라야 합니다</p>\n<ul>\n<li>기본생성자 필수</li>\n<li>final, enum, interface, inner 클래스에는 사용 불가</li>\n<li>테이블에 저장할 필드는 final 키워드 사용 불가</li>\n</ul>\n<blockquote>\n<p>JPA는 자바 리플렉션(Java Reflection API)을 통해 엔티티 정보를 받는데, 이 때 생성자 인자 정보를 가져올 수 없으므로 기본 생성자는 필수적으로 필요합니다. 몇몇 JPA구현체(하이버네이트같은)에서는 바이트코드 조작(Bytecode Manipulation)을 통해 이런 문제를 회피한다고 합니다.</p>\n</blockquote>\n<blockquote>\n<p>자바는 클래스를 생성하면 기본 생성자를 자동으로 만들지만, 만약 생성자가 추가된다면 기본 생성자가 사라지므로 주의해야 합니다. (대부분의 IDE에서 잡아주긴 하지만..)</p>\n</blockquote>\n<p><strong>속성</strong></p>\n<ul>\n<li>name: 엔티티 이름 지정, 기본값 - 클래스명</li>\n</ul>\n<h2 id=\"매핑할-테이블을-지정하는-table\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%ED%95%91%ED%95%A0-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-table\" aria-label=\"매핑할 테이블을 지정하는 table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매핑할 테이블을 지정하는 @Table</h2>\n<p>@Table은 엔티티와 매핑할 데이터베이스 테이블을 지정합니다. 생략 시, 엔티티 이름을 테이블 이름으로 사용합니다.</p>\n<ul>\n<li>name속성: 매핑할 테이블 이름, 기본값 - 엔티티 이름</li>\n<li>catalog: catalog 기능이 있는 데이터베이스에서 catalog 매핑</li>\n<li>schema - schema기능이 있는 데이터베이스에서 schema를 매핑한다</li>\n<li>uniqueConstraints - DDL 생성 시, 유니크 제약조건을 만듭니다.</li>\n</ul>\n<blockquote>\n<p>catalog 기능: 데이터베이스의 인덱스, 뷰테이블, 사용자정보 등 메타데이터를 저장하는 객체</p>\n</blockquote>\n<h2 id=\"엔티티-내-필드-매핑-방법\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%82%B4-%ED%95%84%EB%93%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"엔티티 내 필드 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 내 필드 매핑 방법</h2>\n<p>MySQL,MsSQL등 다양한 RDBMS에는 데이터 타입이 존재합니다. JPA역시 Java의 데이터타입을 RDBMS와 매핑하기 위한 방법들이 존재합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"가장-많이-사용되는-column\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%B4-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-column\" aria-label=\"가장 많이 사용되는 column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가장 많이 사용되는 @Column</h3>\n<p>데이터베이스 테이블과 필드를 매핑하기 위해 사용합니다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li><strong>name</strong>: 필드와 매핑할 테이블 컬럼 이름, 기본값 - 필드명</li>\n<li><strong>nullable</strong>(DDL) : false로 지정 시 NOT NULL 제약조건 추가. 기본값 true</li>\n<li><strong>unique</strong>(DDL) : true로 지정 시 하나의 칼럼에 대해 유니크 제약조건. 기본값 false</li>\n<li><strong>columnDefinition</strong>: 데이터베이스 컬럼정보를 직접 입력</li>\n<li><strong>length</strong>: String 타입의 필드의 경우, 최대 길이 제약조건. 기본값 255</li>\n<li><strong>precision</strong>, <strong>scale:</strong> precision의 경우 소수점 제외 전체자리수, scale은 소수 자리수</li>\n<li>i<strong>nsertable</strong>, <strong>updatable</strong>: 저장 / 수정하고싶지 않을 때 false로 지정, 기본값 true</li>\n<li><strong>table</strong>: 하나의 엔티티를 두 개의 테이블에서 사용하려고 할 때 사용</li>\n</ul>\n<blockquote>\n<p>필드에 @Column을 사용하지 않으면, 모든 속성이 기본값으로 들어가게 된다.</p>\n</blockquote>\n<blockquote>\n<p>Java Primitive type은 Null이 들어올 수 없으므로, DDL 생성 시 nullable=true로 설정됨</p>\n</blockquote>\n<blockquote>\n<p>Wrapper Type을 사용하거나  nullable을 false로 지정해야 한다.</p>\n</blockquote>\n<blockquote>\n<p>@Column(<strong>columnDefinition</strong>=”varchar(100)”) 과 같이, 방언정보를 활용해 선언한다</p>\n</blockquote>\n<h3 id=\"날짜-필드를-매핑하는-temporal\" style=\"position:relative;\"><a href=\"#%EB%82%A0%EC%A7%9C-%ED%95%84%EB%93%9C%EB%A5%BC-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-temporal\" aria-label=\"날짜 필드를 매핑하는 temporal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>날짜 필드를 매핑하는 @Temporal</h3>\n<p>java의 날짜 타입인 java.util.Date, java.util.Calendar를 매핑한다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 시간포맷 지정, 기본값 없음(필수지정)\n<ul>\n<li>TemporalType.DATE: “날짜(<strong>date</strong>)”에 매핑 - 2023-01-01</li>\n<li>TemporalType.TIME: “시간(<strong>time</strong>)”에 매핑 - 12:03:21</li>\n<li>TemporalType.TIMESTAMP: “날짜 및 시간(<strong>timestamp</strong>)에 매핑” - 2023-01-01 12:03:21</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Java의 Date에는 날짜,시간이 모두 있지만, RDBMS는 date, time, timestamp로 나누어져있는 경우가 많아 @Temporal을 명시한 경우 value 속성을 필수로 지정해야한다.</p>\n</blockquote>\n<blockquote>\n<p>@Temporal을 생략하면, DB의 timestamp 타입으로 매핑된다.</p>\n</blockquote>\n<h3 id=\"enum-타입을-매핑하는-enumerated\" style=\"position:relative;\"><a href=\"#enum-%ED%83%80%EC%9E%85%EC%9D%84-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-enumerated\" aria-label=\"enum 타입을 매핑하는 enumerated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>enum 타입을 매핑하는 @Enumerated</h3>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 저장할 값 지정\n<ul>\n<li>(기본)EnumType.ORDINAL: enum 순서를 데이터베이스에 저장</li>\n<li>EnumType.STRING: enum 이름을 데이터베이스에 저장</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>EnumType.ORDINAL로 지정할 경우, 저장되는 크기가 작다는 장점이 있지만, 순서가 바뀌거나 사이에 새로운 내용이 추가되었을 때, 데이터베이스의 기존 데이터와 일치하지 않는다는 문제가 있다. 따라서, EnumType.STRING을 권장한다.</p>\n</blockquote>\n<h3 id=\"길이제한-없는-문자타입-lob\" style=\"position:relative;\"><a href=\"#%EA%B8%B8%EC%9D%B4%EC%A0%9C%ED%95%9C-%EC%97%86%EB%8A%94-%EB%AC%B8%EC%9E%90%ED%83%80%EC%9E%85-lob\" aria-label=\"길이제한 없는 문자타입 lob permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>길이제한 없는 문자타입 @Lob</h3>\n<p>데이터베이스의 CLOB, BLOB 타입과 매핑됩니다. 필드 타입이 문자면 CLOB, 나머지는 BLOB로 매핑됩니다.</p>\n<p>Example)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자 필드이므로 CLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> lobString<span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자필드가 아니므로 BLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> lobByte<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<blockquote>\n<p>CLOB: Character Large Object (대형 문자 객체) , BLOB: Binary Large Object(대형 이진 객체)로, 최대 4GB의 대형 문자/이진 객체를  데이터베이스 시스템 밖의 파일로 저장하는 타입입니다.</p>\n</blockquote>\n<h3 id=\"무시하고-매핑하지-않는-transient\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EC%8B%9C%ED%95%98%EA%B3%A0-%EB%A7%A4%ED%95%91%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-transient\" aria-label=\"무시하고 매핑하지 않는 transient permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무시하고 매핑하지 않는 @Transient</h3>\n<p>@Transient가 지정된 필드는 데이터베이스에 저장하지 않고, 따라서 조회하지도 않습니다.</p>\n<h3 id=\"jpa의-접근방식을-지정하는-access\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%A0%91%EA%B7%BC%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-access\" aria-label=\"jpa의 접근방식을 지정하는 access permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 접근방식을 지정하는 @Access</h3>\n<p>JPA가 엔티티 데이터에 접근하는 방식을 지정합니다.</p>\n<ul>\n<li>필드접근: AccessType.FIELD - 필드에 직접 접근. private여도 가능합니다.</li>\n<li>프로퍼티접근: AccessType.Property - getter를 통해 접근합니다.</li>\n</ul>\n<blockquote>\n<p>@Id 의 위치에 따라, @id가 프로퍼티(getter)에 있으면, 자동으로 AccessType.PROPERTY에 지정, 필드에 있으면 AccessType.FIELD에 지정됩니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 필드통한 접근</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> <span class=\"token class-name\">Id</span>\n\n<span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 프로퍼티 통한 접근 </span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"아까-봤던-엔티티-다시보기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B9%8C-%EB%B4%A4%EB%8D%98-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0\" aria-label=\"아까 봤던 엔티티 다시보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아까 봤던 엔티티 다시보기</h3>\n<p>내용들을 공부하기 전에 확인했던 엔티티입니다. 아래 엔티티를 확인하면, 필드에 선언된 애너테이션의 의미와 역할, 제한사항, 컬럼 등에 대해 이해할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"데이터베이스-스키마-자동생성\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99%EC%83%9D%EC%84%B1\" aria-label=\"데이터베이스 스키마 자동생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 스키마 자동생성</h2>\n<p>JPA는 위처럼 엔티티를 통해 데이터베이스 테이블이 어떻게 구성되는지 알 수 있습니다. 이를 통해 데이터베이스 스키마를 DDL(Data Definition Language)로 자동 생성해주는 기능을 갖습니다.</p>\n<p>(show-sql은 실행되는 쿼리를 콘솔에 출력해줍니다.)</p>\n<p>application.properties</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">spring.jpa.hibernate.ddl-auto: create\nspring.jpa.show-sql: true</code></pre></div>\n<p>application.yaml</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">jpa</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">show-sql</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\t\t<span class=\"token key atrule\">hibernate</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token key atrule\">ddl-auto</span><span class=\"token punctuation\">:</span> create\n</code></pre></div>\n<h3 id=\"ddl-auto-옵션\" style=\"position:relative;\"><a href=\"#ddl-auto-%EC%98%B5%EC%85%98\" aria-label=\"ddl auto 옵션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ddl-auto 옵션</h3>\n<table>\n<thead>\n<tr>\n<th>옵션</th>\n<th>환경</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>개발 초기</td>\n<td>기존 테이블을 삭제 후, 새로 생성 (DROP + CREATE)</td>\n</tr>\n<tr>\n<td>create-drop</td>\n<td>개발 초기</td>\n<td>애플리케이션을 시작할 때 CREATE, 종료할 때 DROP (CREATE + DROP)</td>\n</tr>\n<tr>\n<td>update</td>\n<td>테스트서버</td>\n<td>데이터베이스 테이블과 엔티티의 변경사항을 비교해 변경사항만 수정</td>\n</tr>\n<tr>\n<td>validate</td>\n<td>테스트서버 or</td>\n<td></td>\n</tr>\n<tr>\n<td>스테이징/운영서버</td>\n<td>데이터베이스 테이블과 엔티티 매핑정보가 차이가 있을 경우, 경고를 남기고 애플리케이션을 실행하지 않음.</td>\n<td></td>\n</tr>\n<tr>\n<td>none</td>\n<td>스테이징/운영서버</td>\n<td>자동생성기능을 사용하지 않음. ddl-auto 옵션을 제거하거나 유효하지 않은 옵션을 준것과 같음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>ddl-auto 옵션은 운영환경에서 사용할만큼 완벽하지 않다고 한다. 그렇기에 학습이나 참고용으로만 사용하는것이 좋다.</p>\n</blockquote>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  데이터베이스에 2GB이상의 데이터를 저장하기 위해 JPA에서 어떤 애너테이션을 사용해야하는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  ddl-auto 옵션의 validate는 무슨 역할을 하는가?</li>\n</ul>\n<p><strong>정답</strong></p>\n<ol>\n<li>@Lob 애너테이션을 사용하면 문자열의 경우 CLOB, 이외는 BLOB으로 매핑해줍니다. 다만, Java String의 경우 최대 길이가 2GB이므로, 내용이 절삭되는것에 유의해야 한다.</li>\n<li>데이터베이스 테이블과 엔티티의 매핑이 일치하는지 확인하고, 일치하지 않으면 경고와 함께 애플리케이션을 실행하지 않음</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>","id":"ccf75a49-36b1-5159-856c-f8b3cd59287f","fields":{"slug":"jpa에서-엔티티를-작성하는-방법"},"frontmatter":{"date":"2023-01-08","title":"JPA에서 엔티티를 작성하는 방법","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":4},"next":null}},"staticQueryHashes":[],"slicesMap":{}}