{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/멀티프로세서-스케줄링과-동기화/","result":{"data":{"markdownRemark":{"html":"<p>현대에는 4 또는 8코어 등 멀티코어를 통해 성능을 극대화하는 시도들이 성공을 거두면서, 다중 코어 시스템을 쉽게 찾아볼 수 있게 되었습니다.</p>\n<p>명령어를 실행하는 코어가 여러개라니 다다익선이라고 생각할 수 있습니다.</p>\n<ul>\n<li>\n<p>병렬화의 한계: 병렬화 할 수 있는 작업이 한정적이고, 많은 수의 작업을 병렬화하더라도 이를 병합하는데 오버헤드가 발생합니다.</p>\n<p><strong>하지만  병렬화에도 한계가 존재합니다. (컴퓨터구조론에서 자세히 다룹니다)</strong></p>\n</li>\n<li>\n<p>캐시/메모리 병목: 공유자원인 캐시 및 메모리의 특정 자원에 여러 코어가 접근하면 Lock등을 사용해 동시성을 확보해야 합니다.</p>\n<p>Lock에 의해 프로세서가 대기하는것을 Blocking이라고 하는데, 코어 수가 높을수록 같은 자원에 접근할 확률이 높아져 Blocking시간이 길어집니다.</p>\n<p>잘못된 동기화 알고리즘을 사용할 경우 성능이 급격하게 안좋아질 수 있습니다.</p>\n</li>\n</ul>\n<h2 id=\"멀티프로세서의-문제점\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"멀티프로세서의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서의 문제점</h2>\n<p>앞서 언급한 병렬화의 한계에서는 코어가 늘어날수록 성능이 비례하지 않는 이유에 관한 내용이었습니다.</p>\n<p>아래의 멀티프로세서 구조를 참고해 어떤 치명적인 문제가 있을지 알아보겠습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093159-1d3965f3-a3fd-4b46-95b5-4b02559d09a0.png\" alt=\"1\"></p>\n<ul>\n<li>일반적인 Personal Computer에서는 L3캐시까지 사용되는게 일반적입니다.</li>\n<li>L2캐시까지만 존재하는 경우도 있으며 Intel칩셋 역시 몇몇 모델에 공유 캐시가 존재함을 확인할 수 있습니다.\n<ul>\n<li>(<a href=\"https://en.wikipedia.org/wiki/Intel_Core\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Intel_Core</a>)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"캐시-일관성-문제-cache-coherance-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-coherance-problem\" aria-label=\"캐시 일관성 문제 cache coherance problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>캐시 일관성 문제 (Cache coherance problem)</strong></h3>\n<p>캐시는  메인 메모리에서 자주 사용되는 정보를 저장해놓는 데이터의 복사본입니다.</p>\n<p>각각의 코어는 근처에 L1, L2코어가 있고 L3 코어부터는 메모리 주변에 위치해있습니다.</p>\n<p><strong>프로세서에서 데이터 조회</strong>는 L1캐시에서 데이터를 조회하고 존재하지 않을 시 L2 ~ Main Memory까지 조회하는 방법을 사용하고,</p>\n<p><strong>프로세서가 데이터를 저장</strong>할때는 위치가 가까운 L1, L2캐시에는 쉽게 데이터를 저장할 수 있지만 L3캐시나 메인 메모리에는 쓰기 비용이 많이 들어 한번에 작성합니다.</p>\n<p>만약 Core 1이 A라는 데이터를 A’로 수정했다면, L1,L2캐시에 반영될 것입니다. 그런데 이 때 Core2가 A의 위치에서 데이터를 가져오고자 한다면 수정된 A’이 아니라 이전 데이터인 A를 가져오게 됩니다.</p>\n<p>이를 <strong>캐시 일관성 문제</strong> 라고 합니다.</p>\n<p>이는 데이터 버스를 모니터링하는 MESI등의 프로토콜을 사용해 캐시 접근을 감시해 캐시 불일치를 잡아내고, 무효화(캐시에서 삭제)하거나 원본 캐시 플러시를 통해 해결합니다.</p>\n<p>이를 <strong>버스 스누핑이라고 합니다. (</strong><a href=\"https://en.wikipedia.org/wiki/Bus_snooping\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Bus_snooping</a>) ****</p>\n<h3 id=\"원자성-보장-문제-atomicity-problem\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%9E%90%EC%84%B1-%EB%B3%B4%EC%9E%A5-%EB%AC%B8%EC%A0%9C-atomicity-problem\" aria-label=\"원자성 보장 문제 atomicity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원자성 보장 문제 (Atomicity problem)</h3>\n<p>(캐시 일관성 문제가 해결되어, 캐시에 있는 정보는 믿을 수 있다고 가정합니다)</p>\n<p>CPU는 병렬적으로 실행되므로 같은 데이터에 대해 접근하는 스레드가 여러개일 수 있습니다.</p>\n<p>이로 인한 동시성 문제가 생길 수 있고, 이는 운영체제 레벨에서 Lock을 제공해야 해결할 수 있습니다.</p>\n<p>또한 앞서 말했듯 프로세서 수가 많아질수록 Lock의 Blocking으로 인한 오버헤드가 발생합니다.</p>\n<h3 id=\"캐시-친화성-문제-cache-affinity-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%B9%9C%ED%99%94%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-affinity-problem\" aria-label=\"캐시 친화성 문제 cache affinity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 친화성 문제 (Cache affinity problem)</h3>\n<p>캐시의 기본 원리는 “더 자주 사용하는 소수의 데이터를 더 가까이 둔다” 입니다.</p>\n<p>또한  다수의 일반적인 프로그램은 어떤 경향성을 보입니다.</p>\n<ul>\n<li><strong>시간 지역성: 최근에 사용한 데이터를 다시 참조할 가능성이 높음(예시:반복문에서 동일변수 참조)</strong></li>\n<li><strong>공간 지역성: 최근에 사용한 데이터의 주변에 있는 데이터를 참조할 가능성이 높음(예시: 배열 순회)</strong></li>\n</ul>\n<p>위 가정들 때문에 캐시에는 다음에 참조할 데이터가 존재할 확률이 높은것이죠.</p>\n<p>만약 다수의 프로세서(CPU)에게 레디 큐에 있는 프로세스를 무작위로 실행한다면,</p>\n<p>A프로세스를 실행하기 위해 로드한 캐시들이 B 프로세스를 사용한다면 또다시 B 프로세스를 위한 캐시들을 로드해야 할 것이고, 심각한 성능 하락으로 이어집니다. (이를 Cache warm up이라고 합니다)</p>\n<h2 id=\"멀티프로세서에서의-스케줄링\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"멀티프로세서에서의 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서에서의 스케줄링</h2>\n<h3 id=\"단일-큐-멀티프로세서-스케줄링-sqms\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%ED%81%90-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-sqms\" aria-label=\"단일 큐 멀티프로세서 스케줄링 sqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 큐 멀티프로세서 스케줄링 SQMS</h3>\n<p>단일 큐 멀티프로세서 스케줄링 SQMS ( Single Queue Multiprocessor Scheduling )은 이름 그대로 <strong>프로세서가 여러개더라도 하나의 스케줄링 큐를 사용하는 것입니다.</strong></p>\n<p>이는 간단하게 생각해도 여러가지 문제가 있습니다.</p>\n<ol>\n<li>Ready Queue도 공유자원입니다. 여러 프로세스가 동시에 하나의 프로세스를 실행하고자 큐에서 빼면, 실제로는 하나의 프로세서만 동작하게 되기에, <strong>락을 걸어서 Queue를 임계구역으로 설정</strong>해야 합니다.</li>\n<li>Ready Queue를 임계구역으로 설정해 Lock을 적용하면, 심각한 성능 저하가 발생합니다.</li>\n<li>캐시에 친화적이지 않습니다.</li>\n</ol>\n<h3 id=\"멀티-큐-스케줄링-mqms\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%81%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-mqms\" aria-label=\"멀티 큐 스케줄링 mqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 큐 스케줄링 MQMS</h3>\n<p>멀티 큐 스케줄링 MQMS (Multi-Queue Multiprocessor Scheduling)은 <strong>CPU별로 Ready Queue를 두고, 프로세서별 스케줄링 큐에 작업을 균등하게 할당하는 방식입니다.</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093162-d1eed259-c233-4529-9df5-c59d8b7b740a.png\" alt=\"2\"></p>\n<p><strong>해결된 문제</strong></p>\n<ul>\n<li>SQMS에서는 Ready Queue가 공유자원이었는데, 이제 프로세서별로 하나의 큐가 있으므로 Lock에 의한 오버헤드가 사라졌습니다.</li>\n<li>프로세서는 무작위의 프로세스를 실행하지 않고 특정 프로세스만을 실행하므로 캐시 친화성이 떨어지는 문제가 해결되었습니다.</li>\n</ul>\n<p><strong>새로운 문제점과 해결방법</strong></p>\n<p><strong>워크로드 불균형</strong>: 만약 CPU 1에 할당된 프로세스 A가 엄청나게 오래 동작한다면? CPU1의 Ready Queue에는 많은 프로세스가 쌓이는 반면, CPU0은 큐에 프로세스가 없어 놀아버리는 사태가 발생합니다.</p>\n<h3 id=\"질문-목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"질문 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문 목록</h3>\n<p>(진짜 질문) 워크로드 불균형 문제는 작업 할당 시 할당된 작업이 적은 프로세서에게 할당하면 해결되는것 아닌가?</p>\n<p>(진짜질문) 데드락을 발생시키지 않는 Locking 방법이 있는지? ( 아직 진도 안나갔지만, Spin Lock이 멀티프로세서에서 어떻게 동작할지 생각해오기)</p>\n<p>싱글코어에서는 운영체제가 동기화를 위해 락을 사용하지 않아도 될까?</p>\n<ul>\n<li>\n<p>정답</p>\n<p>싱글코어 컨텍스트 스위칭 역시 인터럽트 기반으로 동작하고, 인터럽트는 실행중이던 마이크로 오퍼레이션까지만 실행한다. 마이크로 오퍼레이션이란, CPU Instruction이 포함하는 Fetch Decode Excecute Memory WriteBack보다 더 작은 단위이다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C_%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%EC%85%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/마이크로_오퍼레이션</a></p>\n<p>→ 당연히 동시성을 보장해주지 않는다</p>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"></a></strong>)**</p>\n<h3 id=\"sub-reference\" style=\"position:relative;\"><a href=\"#sub-reference\" aria-label=\"sub reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sub Reference</h3>\n<p>TLB <a href=\"https://wpaud16.tistory.com/304\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wpaud16.tistory.com/304</a></p>","fields":{"slug":"멀티프로세서-스케줄링과-동기화"},"frontmatter":{"title":"멀티프로세서 스케줄링과 동기화","date":"15.02.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3}},"pageContext":{"slug":"멀티프로세서-스케줄링과-동기화","prev":{"excerpt":"OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다. 책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다. 인터럽트의 종류 Hardware Inturrupt : 외부 기기 또는 사용자, 입/출력에 의한 불특정 시간에 발생해 Asynchronous Interrupt라고도 불립니다. Clock…","html":"<p>OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다.</p>\n<p>책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다.</p>\n<h3 id=\"인터럽트의-종류\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인터럽트의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 종류</h3>\n<p><strong>Hardware Inturrupt : 외부 기기 또는 사용자, 입/출력에 의한 불특정 시간에 발생해 Asynchronous Interrupt라고도 불립니다.</strong></p>\n<ul>\n<li>Clock Interrupt: 한 스레드가 프로세스를 과도하게 점유하는것을 막기 위해 지정된 시간마다 발생하는 인터럽트</li>\n<li>I/O Interrupt: 사용자의 입/출력(또는 예상치못한 외부 이벤트)에 의한 인터럽트</li>\n<li>Machine Check Interrupt: 기기 결함이 발견되었을 때 발생하는 인터럽트</li>\n</ul>\n<p><strong>Software Interrupt (or Trap, Synchronous Interrupt): SW의 예외 핸들링 또는 제어권을 얻기 위해 발생시키는 인터럽트입니다.</strong></p>\n<ul>\n<li>Supervisor Call(System Call Interrupt): 사용자 프로그램이 하드웨어 자원을 사용하기 위해 유저모드에서 커널모드로 들어갈 때 발생시키는 인터럽트.</li>\n<li>Program Check Interrupt: 0으로 나누기, 스택오버플로/언더플로같은 S.W Exception처리하는 인터럽트.</li>\n</ul>\n<h2 id=\"제한된-직접실행-개요\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%ED%95%9C%EB%90%9C-%EC%A7%81%EC%A0%91%EC%8B%A4%ED%96%89-%EA%B0%9C%EC%9A%94\" aria-label=\"제한된 직접실행 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제한된 직접실행 개요</h2>\n<p>먼저 Limited가 없는 직접 실행이라는 부분에 대해 알아보자면 , 운영체제가 프로그램의 실행에 관여하지 않고 CPU는 사용자 코드에서 진입점을 찾아 직접 실행함을 의미합니다. 이 경우 몇가지 문제가 발생합니다.</p>\n<p>프로세서(CPU)가 프로세스로 자원을 나눠줄 때 고려해야할 부분으로 크게 세 가지 중요한 요소가 있습니다.</p>\n<ol>\n<li><strong>제어권</strong>: 운영체제가 <strong>CPU 및 자원에 대한 제어권을 가진 상태로 프로세스를 실행</strong>해야 합니다. 제어권을 상실할 경우 프로세스가 자원을 무기한 점유하는 상황이 발생할 수도 있기 때문이죠.</li>\n<li><strong>성능:</strong> CPU앞서 말했듯 CPU는 초당 처리속도가 다른 하드웨어 기기에 비해 월등히 빠릅니다. 메모리 또는 하드디스크에서 데이터를 가져오는동안 CPU는 정말 많은 시간을 기다려야하겠죠. <strong>운영체제가 이런 I/O작업을 하는 프로세스의 제어권을 뺏고 다른 프로세스를 실행해 CPU활용률을 극대화</strong>합니다.</li>\n<li><strong>자원 보호:</strong> 제한없이 실행되는 프로세스는 전체 디스크,메모리를 읽고 쓸 수 있으므로, 이 부분에 대한 제어가 꼭 필요하다 <strong>( System Call Interface를 통한 User/Kernal Mode 분기)</strong></li>\n</ol>\n<p>요약하자면, 다른 장치에 비해 빠른 CPU의 <strong>성능</strong>을 최대한 <strong>안전하게</strong> 활용하기 위해 운영체제가 CPU의 제어권을 갖는 개념을 Limited Directed Execution: 제한된 직접 실행이라고 합니다.</p>\n<h3 id=\"인터럽트의-실행과정\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95\" aria-label=\"인터럽트의 실행과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 실행과정</h3>\n<p>프로세스가 CPU의 제어권을 갖고있는 상태에서 제어권을 얻기 위해선 인터럽트를 통해 제어권을 뺏어와야 합니다.</p>\n<p>인터럽트 발생: MCU(또는 PIC)라는 장비에 IDT(인터럽트 종류, ISR위치, 우선순위)를 전달하면서 시작됩니다.</p>\n<p>→ <strong>(하드웨어)프로세스 중단</strong></p>\n<ul>\n<li>Context Saving 발생: CPU register를 <strong>커널 스택</strong>에 대피시킨다.</li>\n<li>커널모드로 이동.</li>\n</ul>\n<p>→ <strong>(운영체제)인터럽트 처리(Interrupt Handling)</strong></p>\n<ul>\n<li>인터럽트를 요청한 장치 또는 메모리 주소, 인터럽트의 원인을 확인하고 ISR 주소로 이동해 ISR을 실행한다.</li>\n</ul>\n<p><strong>인터럽트 서비스 루틴 실행</strong> : 예를들어 마우스로 음악 프로그램을 더블클릭 해 인터럽트가 발생했다면, 해당 프로그램을 프로세스 레디 큐에 등록하는 작업을 한다.</p>\n<p>→ <strong>(하드웨어)상태 복구: 커널 스택에 저장된 CPU레지스터들을 불러오고</strong>, 복구한 PC레지스터로 이동해 원래 프로세스 실행</p>\n<p>→ (프로그램): 복구한 PC레지스터부터 다시 실행하므로, 기존 실행시점에서 다시 동작합니다.</p>\n<h3 id=\"interrupt로-context-switch가일어나는-경우\" style=\"position:relative;\"><a href=\"#interrupt%EB%A1%9C-context-switch%EA%B0%80%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"interrupt로 context switch가일어나는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt로 Context Switch가일어나는 경우</h3>\n<p>만약 Timer Interrupt가 발생하고 그로인해 ISR에서 스케쥴러로 분기 →  Process A의 버스트 시간이 끝나 Ready상태로 바꾸는 상황을 가정해보겠습니다.</p>\n<p>(아직 스케줄러에 대해 배우지 않았지만 참고로, 스케쥴러 알고리즘은 매 타임 퀀텀마다, I/O로 인한 블록마다 동작하도록 ISR에 정의되어있습니다.  새로운 프로세스가 등록될때에도 비교를 위해 동작합니다. )</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093145-c874af7d-2608-4373-97ec-94798ef0ea46.png\" alt=\"Interrupt_And_ContextSwitch drawio\"></p>\n<p>인터럽트가 동작하는 구조는 같지만, 내부에서 동작하는 스케쥴링 처리로 인해 ISR이후 Process(j)로 실행됩니다.</p>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(i)를 중단하고 Process(i)실행시점의 <strong>레지스터를 커널 스택으로 대피</strong>합니다.</li>\n<li>커널모드로 변경합니다.</li>\n</ul>\n<p><strong>(운영체제의 Timer Interrupt에 대한 ISR 동작)</strong></p>\n<ul>\n<li>커널 스택에 있는 Process(i)의 레지스터를 Process(i)의 PCB에 저장해줍니다.</li>\n<li>j의 PCB에 저장된 Process(j)의 레지스터를 커널스택으로 옮깁니다.</li>\n<li>j프로세스의 실행주소(PC)로 return from trap합니다.</li>\n</ul>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(j)의 커널스택에 있는 레지스터를 CPU로 복구합니다.</li>\n<li>유저모드로 변경합니다.</li>\n</ul>\n<p><strong>(프로그램)</strong></p>\n<p>Process(j)를 실행</p>\n<h3 id=\"인터럽트의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"인터럽트의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 우선순위</h3>\n<p><strong>전원 이상(Power fail) > 기계 착오(Machine Check) > 외부 신호(External) > 입출력(I/O) > 명령어 잘못 > 프로그램 검사(Program Check) > SVC(SuperVisor Call)</strong></p>\n<p>만약 우선순위가 낮은 인터럽트를 수행하는 중에 우선순위가 높은 인터럽트가 발생하면 우선적으로 처리한 뒤 다시 낮은 순위의 ISR로 돌아가 처리합니다. (재귀적 우선순위 처리)</p>\n<h3 id=\"질문목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D\" aria-label=\"질문목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문목록</h3>\n<p>Interrupt, Trap, Exception의 차이를 시스템 관점에서</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.4 Process Management](</strong><a href=\"https://www.youtube.com/watch?v=jZuTw2tRT7w\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <strong>)</strong></p>\n<p>(sub reference)</p>\n<p><a href=\"https://raisonde.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8Interrupt%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://raisonde.tistory.com/entry/인터럽트Interrupt의-개념과-종류</a></p>\n<p><a href=\"https://justzino.tistory.com/4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://justzino.tistory.com/4</a></p>\n<p><a href=\"https://wiki.osdev.org/Interrupt_Service_Routine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wiki.osdev.org/Interrupt_Service_Routine</a></p>\n<p>커널의 메모리구조 - <a href=\"https://kariskan.tistory.com/52\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kariskan.tistory.com/52</a></p>","id":"d18acb80-a184-5ffd-a668-8349d3729d5f","fields":{"slug":"인터럽트와-제한된-직접-실행"},"frontmatter":{"date":"2023-02-14","title":"인터럽트와 제한된 직접 실행","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},"next":{"excerpt":"프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다. 주소공간 1 컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다. 이는 프로세스 하나가 실행될때 만들어지는 가상의 주소공간이고, 프로그램 코드 영역에서는…","html":"<p>프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다.</p>\n<h1 id=\"주소공간\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84\" aria-label=\"주소공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소공간</h1>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093193-30acf0ce-093c-41b6-aacd-b9b791c2ff85.png\" alt=\"1\"></p>\n<p>컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다.</p>\n<p>이는 프로세스 <strong>하나가 실행될때 만들어지는 가상의 주소공간</strong>이고, 프로그램 코드 영역에서는 <strong>0을 기준</strong>으로 주소를 참고합니다.  이같은 주소공간은 물리메모리상에 프로세스의 개수만큼 존재합니다.</p>\n<p>현대의 컴퓨터들은 메모리 영역을 가상화하기 위해 “주소공간”이라는 개념을 만들어 명령어를 실행할 때 명령어의 물리메모리상 실제 위치를 알고있지 않아도 되도록 구성했습니다.</p>\n<p>운영체제에서 프로세스를 실행할 때 <strong>주소변환을 통한 가상화</strong>로 다른 프로세스로부터 <strong>보호와 고립</strong>이 가능하도록 합니다.</p>\n<h2 id=\"주소변환-baselimit-방법-연속할당-방법에서-사용\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EB%B3%80%ED%99%98-baselimit-%EB%B0%A9%EB%B2%95-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"주소변환 baselimit 방법 연속할당 방법에서 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소변환: base/limit 방법 (연속할당 방법에서 사용)</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093194-a99d68fe-1d74-4b80-b0c5-6dc4006860e4.png\" alt=\"2\"></p>\n<p>주소변환을 통해 명령어를 실행할 때 물리메모리 주소에 대해 생각하지 않아도 되는 메모리 가상화가 가능해집니다.</p>\n<p>CPU는 base, limit레지스터를 가지고있어 <strong>가상주소가 limit을 넘어갈 경우</strong> 예외를 발생시켜 <strong>프로세스를 보호</strong>합니다. <strong>base레지스터는 physical address로 접근 시 주소를 변환</strong>하는데 사용합니다.</p>\n<p>또한 Context Switch시에는 base/limit을 PCB에서 불러와 갱신합니다.</p>\n<h1 id=\"연속-메모리-할당-방법\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95\" aria-label=\"연속 메모리 할당 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리 할당 방법</h1>\n<p>연속 메모리할당 방법이란: 프로세스가 필요로 하는 데이터를 메모리에 연속적으로 할당하는 방식으로, 이후에 배울 발전된 방식인 “불연속 메모리 할당”과 대비되는 개념입니다.</p>\n<p>(관계 정리)</p>\n<p>Continuous Memory Allocation: 연속 메모리 할당</p>\n<ul>\n<li>Uni Programming</li>\n<li>Multi Programming\n<ul>\n<li>Fixed Allocation: 고정 할당</li>\n<li>Variable Allocation: 가변 할당</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093195-92e059e3-2461-4979-92c9-60e0ebfb77a2.png\" alt=\"3\"></p>\n<h3 id=\"uni-programming\" style=\"position:relative;\"><a href=\"#uni-programming\" aria-label=\"uni programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uni Programming</h3>\n<p><strong>Uni Programming</strong>은 운영체제 개발 초기에 단일 사용자가 단일 프로그램을 사용하는 모델에서 개발된 할당방식입니다.</p>\n<p>하나의 PC에서 하나의 프로그램만 메모리를 할당받을 수 있었죠. 아래와 같은 문제점이 있습니다.</p>\n<ul>\n<li>CPU활용도 낮음</li>\n<li>메모리 활용도 낮음(공간의 낭비가 큼)</li>\n</ul>\n<h3 id=\"multi-programming\" style=\"position:relative;\"><a href=\"#multi-programming\" aria-label=\"multi programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi Programming</h3>\n<p>Uni Programming은 위같은 문제점들과 다중 사용자 니즈에 맞춰 점차 사라졌습니다.</p>\n<p>이후 여러 프로세스를 메모리에 할당할 수 있는 방법인 Multi Programming이 등장하고, CPU를 시분할 방식으로 사용해 다양한 프로세스를 동시에 사용하는것처럼 동작할 수 있게 되었습니다.</p>\n<p><strong>Multi Programming: Fixed Allocation (고정 할당 방법)</strong></p>\n<p>여러 프로세스가 사용할 수 있는 공간을 고정된 크기로 나누는 방법입니다.</p>\n<ul>\n<li><strong>내부 단편화가 발생합니다</strong>:  5kb만큼 필요한 프로세스가 있더라도 고정된 크기(예를 들어 10MB)를 할당받아, 파티션 내부에서 낭비하는공간이 발생합니다.</li>\n<li>프로세스가 고정 파티션 크기보다 클 수 있습니다.</li>\n</ul>\n<p><strong>Multi Programming: Variable Allocation (가변 할당 방법)</strong></p>\n<p>프로세스가 사용할 공간을 프로세스의 크기에 맞춰 나누는 방법입니다.  프로세스가 시작할때, 종료할때 Allocation Table을 변경하면서 파티션을 관리합니다.</p>\n<p><strong>가변 할당 정책</strong>에 따라 운영체제에서 관리하는 가용공간 리스트를 탐색해 메모리를 할당합니다.</p>\n<p>Best-fit: 가용 공간을 탐색 후 프로세스가 필요한메모리와 가장 차이가 적은 파티션에 할당</p>\n<p>First-fit: 메모리 크기만큼 할당할 수 있는 첫 파티션에 할당</p>\n<p>Worst-fit: 메모리 크기를 할당할 수 있는 가장 큰 파티션에 할당</p>\n<p>속도: First > Best, Worst</p>\n<p>공간효율: Best > First, Worst</p>\n<p>Fixed Allocation의 문제점들을 다소 극복했지만 아직 문제점이 남아있습니다.</p>\n<ul>\n<li><strong>외부 단편화가 발생합니다:</strong> 크기가 작은 프로세스가 종료해 메모리에서 해제되면 사용중인 파티션 사이에 사용하지 못하는 공간이 발생</li>\n<li>Allocation Table을 순회해야하는 오버헤드 발생</li>\n</ul>\n<h3 id=\"연속-메모리할당-방법의-문제점\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"연속 메모리할당 방법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리할당 방법의 문제점</h3>\n<p>앞서 설명한 여러 <strong>연속 메모리 할당 방법들에는 공통적인 문제</strong>가 남아있습니다.</p>\n<ul>\n<li>프로세스가 필요한 메모리를 시작하는 시점에 알 수 없음</li>\n<li>프로세스가 새로 시작할 때 프로그램 데이터를 모두 디스크 → 메모리로 데이터를 옮겨야하는데, 이는 상당히 느린 방법</li>\n<li>내/외부 단편화로 인한 메모리공간 낭비가 어떤 방식으로든 남아있음</li>\n</ul>\n<p>이런 문제점들은 이후 페이징, 세그멘테이션을 공부하며 해결할 수 있습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"79df45f7-38b0-5842-9e5b-c64401618056","fields":{"slug":"연속메모리-할당과-주소-공간"},"frontmatter":{"date":"2023-02-20","title":"연속메모리 할당과 주소 공간","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}