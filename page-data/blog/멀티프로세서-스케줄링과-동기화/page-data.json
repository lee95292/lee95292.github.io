{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/멀티프로세서-스케줄링과-동기화/","result":{"data":{"markdownRemark":{"html":"<p>현대에는 4 또는 8코어 등 멀티코어를 통해 성능을 극대화하는 시도들이 성공을 거두면서, 다중 코어 시스템을 쉽게 찾아볼 수 있게 되었습니다.</p>\n<p>명령어를 실행하는 코어가 여러개라니 다다익선이라고 생각할 수 있습니다.</p>\n<ul>\n<li>\n<p>병렬화의 한계: 병렬화 할 수 있는 작업이 한정적이고, 많은 수의 작업을 병렬화하더라도 이를 병합하는데 오버헤드가 발생합니다.</p>\n<p><strong>하지만  병렬화에도 한계가 존재합니다. (컴퓨터구조론에서 자세히 다룹니다)</strong></p>\n</li>\n<li>\n<p>캐시/메모리 병목: 공유자원인 캐시 및 메모리의 특정 자원에 여러 코어가 접근하면 Lock등을 사용해 동시성을 확보해야 합니다.</p>\n<p>Lock에 의해 프로세서가 대기하는것을 Blocking이라고 하는데, 코어 수가 높을수록 같은 자원에 접근할 확률이 높아져 Blocking시간이 길어집니다.</p>\n<p>잘못된 동기화 알고리즘을 사용할 경우 성능이 급격하게 안좋아질 수 있습니다.</p>\n</li>\n</ul>\n<h2 id=\"멀티프로세서의-문제점\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"멀티프로세서의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서의 문제점</h2>\n<p>앞서 언급한 병렬화의 한계에서는 코어가 늘어날수록 성능이 비례하지 않는 이유에 관한 내용이었습니다.</p>\n<p>아래의 멀티프로세서 구조를 참고해 어떤 치명적인 문제가 있을지 알아보겠습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093159-1d3965f3-a3fd-4b46-95b5-4b02559d09a0.png\" alt=\"1\"></p>\n<ul>\n<li>일반적인 Personal Computer에서는 L3캐시까지 사용되는게 일반적입니다.</li>\n<li>L2캐시까지만 존재하는 경우도 있으며 Intel칩셋 역시 몇몇 모델에 공유 캐시가 존재함을 확인할 수 있습니다.\n<ul>\n<li>(<a href=\"https://en.wikipedia.org/wiki/Intel_Core\">https://en.wikipedia.org/wiki/Intel_Core</a>)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"캐시-일관성-문제-cache-coherance-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-coherance-problem\" aria-label=\"캐시 일관성 문제 cache coherance problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>캐시 일관성 문제 (Cache coherance problem)</strong></h3>\n<p>캐시는  메인 메모리에서 자주 사용되는 정보를 저장해놓는 데이터의 복사본입니다.</p>\n<p>각각의 코어는 근처에 L1, L2코어가 있고 L3 코어부터는 메모리 주변에 위치해있습니다.</p>\n<p><strong>프로세서에서 데이터 조회</strong>는 L1캐시에서 데이터를 조회하고 존재하지 않을 시 L2 ~ Main Memory까지 조회하는 방법을 사용하고,</p>\n<p><strong>프로세서가 데이터를 저장</strong>할때는 위치가 가까운 L1, L2캐시에는 쉽게 데이터를 저장할 수 있지만 L3캐시나 메인 메모리에는 쓰기 비용이 많이 들어 한번에 작성합니다.</p>\n<p>만약 Core 1이 A라는 데이터를 A’로 수정했다면, L1,L2캐시에 반영될 것입니다. 그런데 이 때 Core2가 A의 위치에서 데이터를 가져오고자 한다면 수정된 A’이 아니라 이전 데이터인 A를 가져오게 됩니다.</p>\n<p>이를 <strong>캐시 일관성 문제</strong> 라고 합니다.</p>\n<p>이는 데이터 버스를 모니터링하는 MESI등의 프로토콜을 사용해 캐시 접근을 감시해 캐시 불일치를 잡아내고, 무효화(캐시에서 삭제)하거나 원본 캐시 플러시를 통해 해결합니다.</p>\n<p>이를 <strong>버스 스누핑이라고 합니다. (</strong><a href=\"https://en.wikipedia.org/wiki/Bus_snooping\">https://en.wikipedia.org/wiki/Bus_snooping</a>) ****</p>\n<h3 id=\"원자성-보장-문제-atomicity-problem\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%9E%90%EC%84%B1-%EB%B3%B4%EC%9E%A5-%EB%AC%B8%EC%A0%9C-atomicity-problem\" aria-label=\"원자성 보장 문제 atomicity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원자성 보장 문제 (Atomicity problem)</h3>\n<p>(캐시 일관성 문제가 해결되어, 캐시에 있는 정보는 믿을 수 있다고 가정합니다)</p>\n<p>CPU는 병렬적으로 실행되므로 같은 데이터에 대해 접근하는 스레드가 여러개일 수 있습니다.</p>\n<p>이로 인한 동시성 문제가 생길 수 있고, 이는 운영체제 레벨에서 Lock을 제공해야 해결할 수 있습니다.</p>\n<p>또한 앞서 말했듯 프로세서 수가 많아질수록 Lock의 Blocking으로 인한 오버헤드가 발생합니다.</p>\n<h3 id=\"캐시-친화성-문제-cache-affinity-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%B9%9C%ED%99%94%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-affinity-problem\" aria-label=\"캐시 친화성 문제 cache affinity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 친화성 문제 (Cache affinity problem)</h3>\n<p>캐시의 기본 원리는 “더 자주 사용하는 소수의 데이터를 더 가까이 둔다” 입니다.</p>\n<p>또한  다수의 일반적인 프로그램은 어떤 경향성을 보입니다.</p>\n<ul>\n<li><strong>시간 지역성: 최근에 사용한 데이터를 다시 참조할 가능성이 높음(예시:반복문에서 동일변수 참조)</strong></li>\n<li><strong>공간 지역성: 최근에 사용한 데이터의 주변에 있는 데이터를 참조할 가능성이 높음(예시: 배열 순회)</strong></li>\n</ul>\n<p>위 가정들 때문에 캐시에는 다음에 참조할 데이터가 존재할 확률이 높은것이죠.</p>\n<p>만약 다수의 프로세서(CPU)에게 레디 큐에 있는 프로세스를 무작위로 실행한다면,</p>\n<p>A프로세스를 실행하기 위해 로드한 캐시들이 B 프로세스를 사용한다면 또다시 B 프로세스를 위한 캐시들을 로드해야 할 것이고, 심각한 성능 하락으로 이어집니다. (이를 Cache warm up이라고 합니다)</p>\n<h2 id=\"멀티프로세서에서의-스케줄링\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"멀티프로세서에서의 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서에서의 스케줄링</h2>\n<h3 id=\"단일-큐-멀티프로세서-스케줄링-sqms\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%ED%81%90-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-sqms\" aria-label=\"단일 큐 멀티프로세서 스케줄링 sqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 큐 멀티프로세서 스케줄링 SQMS</h3>\n<p>단일 큐 멀티프로세서 스케줄링 SQMS ( Single Queue Multiprocessor Scheduling )은 이름 그대로 <strong>프로세서가 여러개더라도 하나의 스케줄링 큐를 사용하는 것입니다.</strong></p>\n<p>이는 간단하게 생각해도 여러가지 문제가 있습니다.</p>\n<ol>\n<li>Ready Queue도 공유자원입니다. 여러 프로세스가 동시에 하나의 프로세스를 실행하고자 큐에서 빼면, 실제로는 하나의 프로세서만 동작하게 되기에, <strong>락을 걸어서 Queue를 임계구역으로 설정</strong>해야 합니다.</li>\n<li>Ready Queue를 임계구역으로 설정해 Lock을 적용하면, 심각한 성능 저하가 발생합니다.</li>\n<li>캐시에 친화적이지 않습니다.</li>\n</ol>\n<h3 id=\"멀티-큐-스케줄링-mqms\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%81%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-mqms\" aria-label=\"멀티 큐 스케줄링 mqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 큐 스케줄링 MQMS</h3>\n<p>멀티 큐 스케줄링 MQMS (Multi-Queue Multiprocessor Scheduling)은 <strong>CPU별로 Ready Queue를 두고, 프로세서별 스케줄링 큐에 작업을 균등하게 할당하는 방식입니다.</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093162-d1eed259-c233-4529-9df5-c59d8b7b740a.png\" alt=\"2\"></p>\n<p><strong>해결된 문제</strong></p>\n<ul>\n<li>SQMS에서는 Ready Queue가 공유자원이었는데, 이제 프로세서별로 하나의 큐가 있으므로 Lock에 의한 오버헤드가 사라졌습니다.</li>\n<li>프로세서는 무작위의 프로세스를 실행하지 않고 특정 프로세스만을 실행하므로 캐시 친화성이 떨어지는 문제가 해결되었습니다.</li>\n</ul>\n<p><strong>새로운 문제점과 해결방법</strong></p>\n<p><strong>워크로드 불균형</strong>: 만약 CPU 1에 할당된 프로세스 A가 엄청나게 오래 동작한다면? CPU1의 Ready Queue에는 많은 프로세스가 쌓이는 반면, CPU0은 큐에 프로세스가 없어 놀아버리는 사태가 발생합니다.</p>\n<h3 id=\"질문-목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"질문 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문 목록</h3>\n<p>(진짜 질문) 워크로드 불균형 문제는 작업 할당 시 할당된 작업이 적은 프로세서에게 할당하면 해결되는것 아닌가?</p>\n<p>(진짜질문) 데드락을 발생시키지 않는 Locking 방법이 있는지? ( 아직 진도 안나갔지만, Spin Lock이 멀티프로세서에서 어떻게 동작할지 생각해오기)</p>\n<p>싱글코어에서는 운영체제가 동기화를 위해 락을 사용하지 않아도 될까?</p>\n<ul>\n<li>\n<p>정답</p>\n<p>싱글코어 컨텍스트 스위칭 역시 인터럽트 기반으로 동작하고, 인터럽트는 실행중이던 마이크로 오퍼레이션까지만 실행한다. 마이크로 오퍼레이션이란, CPU Instruction이 포함하는 Fetch Decode Excecute Memory WriteBack보다 더 작은 단위이다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C_%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%EC%85%98\">https://ko.wikipedia.org/wiki/마이크로_오퍼레이션</a></p>\n<p>→ 당연히 동시성을 보장해주지 않는다</p>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\"></a></strong>)**</p>\n<h3 id=\"sub-reference\" style=\"position:relative;\"><a href=\"#sub-reference\" aria-label=\"sub reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sub Reference</h3>\n<p>TLB <a href=\"https://wpaud16.tistory.com/304\">https://wpaud16.tistory.com/304</a></p>","fields":{"slug":"멀티프로세서-스케줄링과-동기화"},"frontmatter":{"title":"멀티프로세서 스케줄링과 동기화","date":"02.15.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null,"description":null},"timeToRead":3}},"pageContext":{"slug":"멀티프로세서-스케줄링과-동기화","prev":{"excerpt":"개요 스케쥴링이란, CPU 자원을 계획에 따라 여러 프로세스에게 나누어주는 방법입니다. 여러가지 스케쥴링 항목에 대해 공부하기 전에, 왜 스케쥴러를 사용하는지에 대해 생각하면 더 편하게 이해할 수 있습니다. 앞서 공부한 프로세스의 상태 중, CPU를 할당받기 위해 Ready → Running 상태의 전이를 담당하는것이 스케쥴링입니다. 그래서 기본적으로 Ready Queue…","html":"<h3 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h3>\n<p>스케쥴링이란, CPU 자원을 계획에 따라 여러 프로세스에게 나누어주는 방법입니다. 여러가지 스케쥴링 항목에 대해 공부하기 전에, 왜 스케쥴러를 사용하는지에 대해 생각하면 더 편하게 이해할 수 있습니다.</p>\n<p>앞서 공부한 프로세스의 상태 중, CPU를 할당받기 위해 <strong>Ready → Running</strong> 상태의 전이를 담당하는것이 스케쥴링입니다. 그래서 기본적으로 Ready Queue에 여러 프로세스가 대기중이고, 스케쥴링 정책은 이 큐에 있는 프로세스를 어떻게 실행할지에 대한 이야기라고 생각하면 됩니다.</p>\n<p>운영체제는 목적에 따라 여러 종류가 있습니다. 대화형 시스템, 배치 시스템 등..</p>\n<p>대화형 시스템에서는 CPU의 활용성이 조금 떨어지더라도 유저의 요청에 <strong>반응하는 시간</strong>이 빨라야하고,</p>\n<p>대규모 데이터를 처리하는 배치 시스템에서는 응답시간보다는 <strong>처리량</strong>이 우선일 것입니다.</p>\n<p>응답시간, 처리량같이 운영체제별로 스케쥴링의 목적이 있고, 이외에도 공평성, 무한대기 방지, 활용률 등 다양한 평가항목이 있어, 스케쥴링 알고리즘을 선택할 때 고려해야 합니다.</p>\n<h3 id=\"스케쥴링-성능평가-용어-정리\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%84%B1%EB%8A%A5%ED%8F%89%EA%B0%80-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC\" aria-label=\"스케쥴링 성능평가 용어 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 성능평가 용어 정리</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093035-ef33201e-3ca0-4f2b-b94a-d3414eb4bc3c.png\" alt=\"1\"></p>\n<ul>\n<li><strong>Response Time, 응답시간 / T(response) - T(arrival) :</strong> 레디큐에 도착해 처음으로 스케쥴될때까지 걸린 시간</li>\n<li><strong>Waiting Time, 대기시간 / T(sum of waiting) :</strong> 레디큐에 도착해 running이 되기까지 걸린 시간의 합\n<ul>\n<li><strong>응답시간은 Ready Queue도착에서 첫 스케쥴까지 걸린시간, 대기시간은 프로세스가 종료되기까지 Ready Queue에 있는 시간의 총 합을 의미합니다.</strong></li>\n</ul>\n</li>\n<li><strong>Burst Time, 실행시간 / T(completion) - T(start)</strong> : CPU를 할당받아 실행한 시간</li>\n<li><strong>Turnaround Time, 반환시간 / T(completion)- T(arrival) :</strong> 레디큐에 도착해 작업을 완료하기까지 걸린 시간</li>\n</ul>\n<p>위와 같은 기준들로 <strong>“성능”</strong> 을 평가할 수 있으며, 여러 프로세스가 번갈아가며 실행하므로, 일반적으로는 반환시간 또는 대기시간의 <strong>평균</strong>을통해 스케쥴링의 적합성을 판단합니다.</p>\n<p>또한, <strong>공정성</strong>도 중요한 평가요소 중 하나입니다. 스케쥴링 방법을 공부하다보면 알겠지만, 일반적인 경우 처리량과 공정성은 등가교환 관계이기 때문에 주의해야 합니다.</p>\n<h2 id=\"스케쥴링-방법들\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EB%B0%A9%EB%B2%95%EB%93%A4\" aria-label=\"스케쥴링 방법들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 방법들</h2>\n<p><strong>먼저 알고가야 할것. 선점형 vs 비선점형</strong></p>\n<p>유저 이벤트로 인한 프로세스 시작이나 I/O 종료 인터럽트로 인해 Ready Queue에 다양한 프로세스들이 들어옵니다.</p>\n<p>이 때, 새로운 프로세스가 즉시 CPU 할당을 받아서(뺏어와서) 실행할 수 있는 스케쥴링 종류를 선점형(Preemitive), 그렇지 않고 해당 프로세스의 Burst Time이 끝나는것을 기다려하는 스케쥴링 종류를 비선점형(Non-Preemitive)라고 합니다</p>\n<h3 id=\"fcfs-또는-fifo-알고리즘\" style=\"position:relative;\"><a href=\"#fcfs-%EB%98%90%EB%8A%94-fifo-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"fcfs 또는 fifo 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FCFS (또는 FIFO) 알고리즘</h3>\n<p>First Come First Service (First In First Out) 즉, 선착순/선입선출 알고리즘입니다. Ready Queue에 들어온 순서대로 CPU를 할당해줍니다. 비선점형 스케쥴링 알고리즘입니다</p>\n<p>일상생활에서는 공평하게 처리하기 위해 자주 사용되는 알고리즘입니다. 매우 간단하고 얼핏보면 공평해보이지만, 아래의 경우를 확인해보면 비효율적인 알고리즘인걸 알 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>70</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>만약 A,B,C가 거의 동시에 도착해 A,B,C순으로 처리한다고 할 때, 평균 반환시간을 체크해보면</p>\n<p><strong>Average Turnaround Time : (60 + 70 + 80) /3  = 70</strong>  으로, 굉장히 비효율적입니다.</p>\n<p>라면 하나를 사려고 계산대에 줄을 섰는데, 앞에서 엄청 많은 물건을 계산하고있는 상황을 생각해보면 편할겁니다.</p>\n<p>이처럼 짧은 시간동안 자원을 사용하는 프로세스가 오랜 시간동안 할당을 기다려야 하는 현상을 <strong>Convoy Effect</strong>라고 합니다.</p>\n<h3 id=\"sjf-알고리즘--non-preemitive\" style=\"position:relative;\"><a href=\"#sjf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98--non-preemitive\" aria-label=\"sjf 알고리즘  non preemitive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF 알고리즘 / Non Preemitive</h3>\n<p>Shortest Job First 즉, 짧은 작업을 우선해서 처리하는 알고리즘입니다.</p>\n<p>비선점형으로 동작하는 경우부터 살펴보겠습니다.</p>\n<p>FCFS에서는 실행시간이 짧은 프로세스가 앞서 실행되는 긴 프로세스의 실행을 기다려하는 Convoy Effect가 문제였습니다.</p>\n<p>SJF에서는 레디큐에 있는 Job들 중, <strong>짧은것을 우선적으로 실행</strong>합니다.</p>\n<p>마트에서 줄이 짧은 사람을 먼저 계산하게 해줍니다!</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>B</th>\n<th>C</th>\n<th>A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>10</td>\n<td>10</td>\n<td>60</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>10</td>\n<td>20</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>앞선 FIFO의 예시입니다. A,B,C가 동시에 도착하면  B,C가 먼저 스케쥴되어 반환시간을 계산하면</p>\n<p><strong>Average Turnaround Time :(10+20+80) / 3  = 36.6</strong> , 반환시간이 절반정도로 줄어든걸 확인할 수 있습니다.</p>\n<p><strong>SJF 문제점</strong></p>\n<p>비선점형이라는 것을 고려하면 아래와 같이 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093037-73ffbddf-8875-4583-81d7-03c9aaf5c377.png\" alt=\"2\"></p>\n<p>B,C는 time:10에 도착했으므로 이미 실행중인 A를 종료시키지 못하고, time:60까지 기다립니다. 이 경우 반환시간은</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>60</td>\n<td>70</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (60+60+70)/3 = 63.3으로, 앞선 FSFS와 큰 차이가 없습니다.</strong></p>\n<h3 id=\"srtf또는-sctf-알고리즘\" style=\"position:relative;\"><a href=\"#srtf%EB%98%90%EB%8A%94-sctf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"srtf또는 sctf 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRTF(또는 SCTF) 알고리즘</h3>\n<p>SRTF: Shortes Remaining Time First (= SCTF: Shortest Time to Completion First)는 <strong>최소 잔여시간이 적은 프로세스를 선점형으로 실행</strong>하는 알고리즘입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093039-804b66a5-2dee-48b4-985d-ad66c1171e54.png\" alt=\"3\"></p>\n<p>앞선 SJF와 비교해보면 B,C가 도착한 time: 10시점에 <strong>더 짧게 남은 잡을 계산해 CPU를 선점한다는걸 확인할 수 있습니다</strong>.</p>\n<p>이 경우 반환시간을 계산해보겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>80</td>\n<td>20</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (80+20+30)/3 = 43.3으로, B,C가 늦게 도착한 경우에 평균 반환시간을 개선할 수 있었습니다.</strong></p>\n<p><strong>SRTF 문제점</strong></p>\n<p><strong>SRTF에도 공정성, 응답시간 측면에서 문제점이 있습니다.</strong></p>\n<p>만약 실행시간이 10인 프로세스가 레디 큐에 계속 들어온다면, 남은 실행시간이 20인 프로세스는 CPU를 할당받지 못하는 상태가 되고(Starvation), 응답시간이 계속 늘어납니다.</p>\n<p>또한 <strong>운영체제는 Ready Queue에 있는 프로세스의 실행시간을 알지 못합니다.</strong></p>\n<h3 id=\"round-robin-알고리즘\" style=\"position:relative;\"><a href=\"#round-robin-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"round robin 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Round Robin 알고리즘</h3>\n<p>Round Robin알고리즘은 일정 Time Quantum을 기점으로 Ready Queue에 있는 모든 프로세스들에게 공정하게 실행시간을 배분해주는 알고리즘을 말합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093040-38af8a4a-e01d-4f0b-a85e-62aa5b91541e.png\" alt=\"4\"></p>\n<p><strong>문제점 해결</strong></p>\n<p>해당 방식으로 실행하면 SRTF에서 실행시간이 많이 남은 프로세스가 CPU를 계속 할당받지 못하는 공평성 문제가 해결되고, 응답시간이 대폭 개선됩니다.</p>\n<p><strong>특징</strong></p>\n<p>대화형 시스템에 적합합니다.</p>\n<p>새로 Ready상태가 되거나 실행시간을 마친 Job은  Ready Queue의 <strong>맨 뒤로</strong> 갑니다.</p>\n<ul>\n<li>A가 실행되고 나서 C가 Ready상태가 되었다면,  …. → A → C 순으로 실행됩니다.</li>\n<li>반대로 C가 Ready Queue에 도착하고 A의 실행이 끝난다면, …→ C → A 순으로 실행됩니다.</li>\n</ul>\n<p><strong>새로운 문제점</strong></p>\n<p>평균 반환시간 관점으로 보았을 때, 최악의 알고리즘입니다.</p>\n<p>또한 적절한 Time Quantum을 설정해야합니다. 잦은 Context Switch는 성능 저하를 불러옵니다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>반환시간, 응답시간, 공평성은 등가교환 관계입니다.</p>\n<p>SJF, SRTF는 반환시간이 개선되지만 응답시간, 공정성 측면에서는 비효율적이고</p>\n<p>RR의 경우 응답시간과 공평성은 해결했지만 반환시간이 비효율적입니다.</p>\n<p>뒤이어 배울 MLFQ등을 통해 각각의 장점을 절충하는 스케쥴러의 동작을 공부해보겠습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\"></a></strong>)**</p>","id":"90477195-e249-580a-9f20-cf0887f0663b","fields":{"slug":"기본-cpu-스케쥴링-fcfs-sjf-srtf-rr"},"frontmatter":{"date":"2023-02-14","title":"기본 CPU 스케쥴링 [ FCFS, SJF, SRTF, RR]","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null,"description":null},"timeToRead":3},"next":{"excerpt":"프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다. 주소공간 1 컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다. 이는 프로세스 하나가 실행될때 만들어지는 가상의 주소공간이고, 프로그램 코드 영역에서는…","html":"<p>프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다.</p>\n<h1 id=\"주소공간\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84\" aria-label=\"주소공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소공간</h1>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093193-30acf0ce-093c-41b6-aacd-b9b791c2ff85.png\" alt=\"1\"></p>\n<p>컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다.</p>\n<p>이는 프로세스 <strong>하나가 실행될때 만들어지는 가상의 주소공간</strong>이고, 프로그램 코드 영역에서는 <strong>0을 기준</strong>으로 주소를 참고합니다.  이같은 주소공간은 물리메모리상에 프로세스의 개수만큼 존재합니다.</p>\n<p>현대의 컴퓨터들은 메모리 영역을 가상화하기 위해 “주소공간”이라는 개념을 만들어 명령어를 실행할 때 명령어의 물리메모리상 실제 위치를 알고있지 않아도 되도록 구성했습니다.</p>\n<p>운영체제에서 프로세스를 실행할 때 <strong>주소변환을 통한 가상화</strong>로 다른 프로세스로부터 <strong>보호와 고립</strong>이 가능하도록 합니다.</p>\n<h2 id=\"주소변환-baselimit-방법-연속할당-방법에서-사용\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EB%B3%80%ED%99%98-baselimit-%EB%B0%A9%EB%B2%95-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"주소변환 baselimit 방법 연속할당 방법에서 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소변환: base/limit 방법 (연속할당 방법에서 사용)</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093194-a99d68fe-1d74-4b80-b0c5-6dc4006860e4.png\" alt=\"2\"></p>\n<p>주소변환을 통해 명령어를 실행할 때 물리메모리 주소에 대해 생각하지 않아도 되는 메모리 가상화가 가능해집니다.</p>\n<p>CPU는 base, limit레지스터를 가지고있어 <strong>가상주소가 limit을 넘어갈 경우</strong> 예외를 발생시켜 <strong>프로세스를 보호</strong>합니다. <strong>base레지스터는 physical address로 접근 시 주소를 변환</strong>하는데 사용합니다.</p>\n<p>또한 Context Switch시에는 base/limit을 PCB에서 불러와 갱신합니다.</p>\n<h1 id=\"연속-메모리-할당-방법\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95\" aria-label=\"연속 메모리 할당 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리 할당 방법</h1>\n<p>연속 메모리할당 방법이란: 프로세스가 필요로 하는 데이터를 메모리에 연속적으로 할당하는 방식으로, 이후에 배울 발전된 방식인 “불연속 메모리 할당”과 대비되는 개념입니다.</p>\n<p>(관계 정리)</p>\n<p>Continuous Memory Allocation: 연속 메모리 할당</p>\n<ul>\n<li>Uni Programming</li>\n<li>Multi Programming\n<ul>\n<li>Fixed Allocation: 고정 할당</li>\n<li>Variable Allocation: 가변 할당</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093195-92e059e3-2461-4979-92c9-60e0ebfb77a2.png\" alt=\"3\"></p>\n<h3 id=\"uni-programming\" style=\"position:relative;\"><a href=\"#uni-programming\" aria-label=\"uni programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uni Programming</h3>\n<p><strong>Uni Programming</strong>은 운영체제 개발 초기에 단일 사용자가 단일 프로그램을 사용하는 모델에서 개발된 할당방식입니다.</p>\n<p>하나의 PC에서 하나의 프로그램만 메모리를 할당받을 수 있었죠. 아래와 같은 문제점이 있습니다.</p>\n<ul>\n<li>CPU활용도 낮음</li>\n<li>메모리 활용도 낮음(공간의 낭비가 큼)</li>\n</ul>\n<h3 id=\"multi-programming\" style=\"position:relative;\"><a href=\"#multi-programming\" aria-label=\"multi programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi Programming</h3>\n<p>Uni Programming은 위같은 문제점들과 다중 사용자 니즈에 맞춰 점차 사라졌습니다.</p>\n<p>이후 여러 프로세스를 메모리에 할당할 수 있는 방법인 Multi Programming이 등장하고, CPU를 시분할 방식으로 사용해 다양한 프로세스를 동시에 사용하는것처럼 동작할 수 있게 되었습니다.</p>\n<p><strong>Multi Programming: Fixed Allocation (고정 할당 방법)</strong></p>\n<p>여러 프로세스가 사용할 수 있는 공간을 고정된 크기로 나누는 방법입니다.</p>\n<ul>\n<li><strong>내부 단편화가 발생합니다</strong>:  5kb만큼 필요한 프로세스가 있더라도 고정된 크기(예를 들어 10MB)를 할당받아, 파티션 내부에서 낭비하는공간이 발생합니다.</li>\n<li>프로세스가 고정 파티션 크기보다 클 수 있습니다.</li>\n</ul>\n<p><strong>Multi Programming: Variable Allocation (가변 할당 방법)</strong></p>\n<p>프로세스가 사용할 공간을 프로세스의 크기에 맞춰 나누는 방법입니다.  프로세스가 시작할때, 종료할때 Allocation Table을 변경하면서 파티션을 관리합니다.</p>\n<p><strong>가변 할당 정책</strong>에 따라 운영체제에서 관리하는 가용공간 리스트를 탐색해 메모리를 할당합니다.</p>\n<p>Best-fit: 가용 공간을 탐색 후 프로세스가 필요한메모리와 가장 차이가 적은 파티션에 할당</p>\n<p>First-fit: 메모리 크기만큼 할당할 수 있는 첫 파티션에 할당</p>\n<p>Worst-fit: 메모리 크기를 할당할 수 있는 가장 큰 파티션에 할당</p>\n<p>속도: First > Best, Worst</p>\n<p>공간효율: Best > First, Worst</p>\n<p>Fixed Allocation의 문제점들을 다소 극복했지만 아직 문제점이 남아있습니다.</p>\n<ul>\n<li><strong>외부 단편화가 발생합니다:</strong> 크기가 작은 프로세스가 종료해 메모리에서 해제되면 사용중인 파티션 사이에 사용하지 못하는 공간이 발생</li>\n<li>Allocation Table을 순회해야하는 오버헤드 발생</li>\n</ul>\n<h3 id=\"연속-메모리할당-방법의-문제점\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"연속 메모리할당 방법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리할당 방법의 문제점</h3>\n<p>앞서 설명한 여러 <strong>연속 메모리 할당 방법들에는 공통적인 문제</strong>가 남아있습니다.</p>\n<ul>\n<li>프로세스가 필요한 메모리를 시작하는 시점에 알 수 없음</li>\n<li>프로세스가 새로 시작할 때 프로그램 데이터를 모두 디스크 → 메모리로 데이터를 옮겨야하는데, 이는 상당히 느린 방법</li>\n<li>내/외부 단편화로 인한 메모리공간 낭비가 어떤 방식으로든 남아있음</li>\n</ul>\n<p>이런 문제점들은 이후 페이징, 세그멘테이션을 공부하며 해결할 수 있습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"79df45f7-38b0-5842-9e5b-c64401618056","fields":{"slug":"연속메모리-할당과-주소-공간"},"frontmatter":{"date":"2023-02-20","title":"연속메모리 할당과 주소 공간","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null,"description":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}