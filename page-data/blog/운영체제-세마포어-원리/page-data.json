{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/운영체제-세마포어-원리/","result":{"data":{"markdownRemark":{"html":"<p>앞서 TAS를 통한 Atomic한 락 설정 방법을 공부했습니다. Atomic한 락 설정을 통해 Preemption으로 인한 이상현상 없이 임계구역을 보호하기 위해 운영체제는 몇가지 방법들을 사용합니다.</p>\n<h1 id=\"세마포어\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\" aria-label=\"세마포어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어</h1>\n<p>세마포어란, 다익스트라가 제안한 알고리즘으로, Busy Waiting으로 인한 성능저하 문제를 해결합니다.</p>\n<p><strong>기본적인 동작방법</strong></p>\n<ol>\n<li>세마포어는 세마포어변수 S와 P,V연산으로 이뤄집니다.\n<ol>\n<li>세마포어 변수인 S변수는 공유자원에 접근할 수 있는 자원의 개수를 의미합니다.</li>\n<li>P연산은 임계구역에 접근하기 전 진입가능한지를 검사하며, 가능하지 않다면 Wait Queue에 들어갑니다.</li>\n<li>V연산은 임계구역에서 나올 때 사용합니다. S변수를 원복하고, Wait Queue에서 임계구역으로 진입하려는 프로세스를 깨웁니다.</li>\n</ol>\n</li>\n<li>각 P,V연산은 하나의 instruction cycle에서 수행되어 Interrupt로 인해 끊기지 않습니다. (이를 Indivisable, 또는 Atomic하다고 합니다.)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">Init</span><span class=\"token punctuation\">(</span>initS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tS <span class=\"token operator\">=</span> initS\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> S <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n\tS<span class=\"token operator\">-=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> Waiting Process in Queue<span class=\"token operator\">:</span>\n\t\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> # 다른 프로세스가 임계구역으로 접근하므로<span class=\"token punctuation\">,</span> S변수는 그대로<span class=\"token operator\">!</span>\n\t<span class=\"token keyword\">else</span><span class=\"token operator\">:</span>\n\t\tS<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">P</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">//Critical Section</span>\n\t<span class=\"token function\">V</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>세마포어의 특징: 임계구역 제한방식의 차이</strong></p>\n<p>Busy Waiting와과 Sleep-Wakeup을 통한 임계구역 제한에는 분명한 차이가 있습니다.</p>\n<p>프로세스와 상태변화(<a href=\"https://blog.mglee.dev/blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.mglee.dev/blog/프로세스의-개념과-상태-변화/</a> 참고)에 대해 이해하고 있어야합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/65ab6312-f58f-4a4b-b8ed-7d49180d44d0\" alt=\"1\"></p>\n<p>Semaphore의 <strong>Sleep-Wakeup에서는 블로킹된 프로세스는 CPU를 잡아먹지 않습니다.</strong></p>\n<ul>\n<li>Sleep을 하면 프로세스의 상태가 Running → Asleep(이하 Waiting)상태가 됩니다.</li>\n<li>Wakeup동작은 프로세스 상태를 Waiting → Ready로 바꿔줍니다. (But, 이 과정은 순서를 보장하지 않아, 공정성 문제가 발생합니다)</li>\n</ul>\n<p><strong>Spin Lock 방식은 블로킹된 프로세스가 CPU를 점유하며 아무동작도 하지 않습니다.</strong></p>\n<ul>\n<li>블로킹된 프로세스는 Ready ↔ Running상태를 오가며 락을 획득할때까지 기다립니다.</li>\n</ul>\n<p><strong>Busy Waiting Vs Sleep Wakeup ?</strong></p>\n<p>Sleep Wakeup 방법에서는 락을 획득하지 못해 대기하는 스레드가 Running state로 들어가는 일이 없으므로, Blocking으로 인한 CPU IDLE상태가 되지 않습니다. 따라서 <strong>일반적으로 성능이 더 좋은 Sleep-Wakeup방식을 사용합니다.</strong></p>\n<p><strong>이진 세마포어와 카운팅 세마포어</strong></p>\n<p>세마포어에는 이진 세마포어, 카운팅 세마포어로 나뉩니다.</p>\n<p><strong>이진 세마포어는</strong> 세마포어변수가 1이므로, 하나의 스레드만 임계구역에 접근할 수 있어 임계구역에 대한 상호배제를 지켜주기 때문에, Mutex라고도 불립니다. (Mutual Exclusion의 약자)</p>\n<p><strong>카운팅 세마포어는</strong> S(>1)개의 스레드가 임계구역에 접근할 수 있습니다. 카운팅 세마포어는 그 자체만으로 상호배제를 달성하지는 못합니다. 그러나 카운팅 세마포어를 적절히 사용하면 운영체제에서 발생하는 여러 동시성 문제를 해결할 수 있습니다. (Producer/Consumer 문제, 식사하는 철학자 문제 등)</p>\n<h3 id=\"세마포어-summay\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-summay\" aria-label=\"세마포어 summay permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어: Summay</h3>\n<ul>\n<li>세마포어는 Busy Waiting으로 인한 성능 저하를 해결한 동시성 제어 방법입니다.</li>\n<li>P를 통해 세마포어변수 S(S>0)를 줄여 락을 획득,임계구역으로 접근하고</li>\n<li>V를 통해 S를 증가, 락을 반납하고 Wait상태의 스레드를 깨워주고 임계구역에서 나갑니다.</li>\n<li>S==0일 때, 임계구역에 진입할 수 없어  Blocking된 스레드는 Wait상태에 접어들고, 다른 스레드의 V연산을 통해 Wakeup 합니다.</li>\n<li>Counting Semapore는 세마포어변수가 1보다 커, 많은 스레드가 접근할 수 있고, S를 접근가능한 스레드 수로 정의했을 때, 상호배제가 지켜지지 않습니다. 하지만 아래와 같이 다양한 용도로 사용할 수 있습니다.\n<ul>\n<li>이는 실행하는 스레드 수를 제한하는 Thread Throttling에 사용됩니다.  세마포어 변수를 통해 S개를 초과하는 스레드에 대해 Blocking해주면, 자주 사용되는 페이지 집합이 메모리 크기를 초과해 발생하는 Thrashing을 방지할수도 있고, 과도한 Context Switch로 인한 캐시 미스도 방지할 수 있습니다.</li>\n<li>다음 글에서 소개할 Producer/Consumer 문제에서 Buffer의 사용량을 체크하는 용도로 사용되기도 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><strong>OSTEP: Operating Systems: Three Easy Pieces</strong> - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><strong>HPC Lab. KOREATECH, OS Lecture-</strong> <a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></p>","fields":{"slug":"운영체제-세마포어-원리"},"frontmatter":{"title":"운영체제 세마포어 원리","date":"04.02.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"운영체제-세마포어-원리","prev":{"excerpt":"Thread와 동작원리 <이미지 출처 https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean > Thread는 Process 내에서 분기하는 또 다른 실행 흐름입니다. 주소공간 멀티스레드 환경에서 프로세스의 주소공간은, 스레드의 개수만큼 스택 공간이 필요합니다. 이를 Thread-local, 또는 Thread-stack…","html":"<h1 id=\"thread와-동작원리\" style=\"position:relative;\"><a href=\"#thread%EC%99%80-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"thread와 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread와 동작원리</h1>\n<img width=\"768\" alt=\"멀티스레드/프로세스 메모리 구조\" src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/72ccb320-559b-4d78-8c05-766cbd01904c\">\n<p>&#x3C;이미지 출처 <a href=\"https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean</a> ></p>\n<p>Thread는 Process 내에서 분기하는 또 다른 실행 흐름입니다.</p>\n<p><strong>주소공간</strong></p>\n<p>멀티스레드 환경에서 프로세스의 주소공간은, 스레드의 개수만큼 스택 공간이 필요합니다. 이를 <strong>Thread-local</strong>, 또는 <strong>Thread-stack</strong>이라고 합니다.</p>\n<p>멀티스레드 모델에서 주소공간 배치의 안정성이 떨어졌지만, 일반적으로 Thread-local공간은 크기가 매우 작으므로, 주소 침범으로 인한 문제가 발생하는 경우는 거의 없습니다. (Recursion을 과도하게 많이 사용할 경우를 대비해 Recursion Limit을 설정합니다. )</p>\n<p><strong>문맥교환(Context Switch)</strong></p>\n<p>PC(Program Counter)가 프로세스별로 한 개였던 단일 스레드 기반 동작과 달리, 멀티스레드 방식에서는 각 스레드마다 PC를 가지고있습니다. PC레지스터 뿐만 아니라 실행시 스레드의 정보를 담고있는 다양한 레지스터를 TCB(Thread Control Block)에 저장합니다. 이는 PCB와 마찬가지로 커널 메모리영역에 저장됩니다.</p>\n<p>스레드간의 문맥 교환은 TCB 에 있는 데이터를 CPU 레지스터로 로드하면서 시작됩니다. TCB를 독자적으로 가졌던것과 달리, 주소공간은 공유하므로 Page Table은 그대로 사용합니다.</p>\n<p><strong>멀티스레드의</strong> <strong>장점</strong></p>\n<hr>\n<p><strong>응답성</strong> 측면에서는 병렬실행을 통한 장점을 가져올 수 있습니다. 일부 스레드가 I/O작업을 처리할때 다른 스레드가 사용자 요청을 처리합니다.</p>\n<p><strong>캐시친화적</strong> 측면에서는 가장 큰 공간을 차지하는 힙 영역을 공유하므로, 캐시 히트 확률이 올라갑니다.</p>\n<p><strong>자원 활용율</strong> 측면에서, 멀티프로세서(CPU)로 구동 시 프로세서 활용률이 높아집니다.</p>\n<h2 id=\"멀티스레드의-동시성-관리\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B4%80%EB%A6%AC\" aria-label=\"멀티스레드의 동시성 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티스레드의 동시성 관리</h2>\n<p>앞서 살펴본것처럼 멀티 스레드는 성능측면에서 많은 장점이 있습니다. 높은 성능을 가져오는 주된 이유는 “자원 공유”이지만, 자원을 공유해 사용할때는 <strong>동시성 문제</strong>에 대한 관리를 적절히 해주어야 합니다.</p>\n<p><strong>동시성 문제란?</strong></p>\n<p>스레드는 <strong>비동기적</strong>으로 동작합니다. 이들은 다른 스레드의 동작과 무관하게 동작하고, 다른 스레드가 어떤 자원을 변경하는지 모릅니다.</p>\n<p>그렇기에 경쟁상태(race condition)에 있는 스레드들의 실행 결과는 <strong>비결정적</strong>입니다. Timer Interrupt로 인해 프로그램 입장에서 랜덤한 시간에 발생하는 스케쥴링 때문입니다.</p>\n<p><strong>경쟁상태의 스레드들이 비결정적으로 동작하는 예시</strong></p>\n<p>간단하게 설명하자면, A,B 스레드가 money값(100)을 읽어(Read) 200을 더하고(Add) 저장하는(Save) 과정을 수행한다고 합시다. 여기에서 동작하는 Read, Add, Save과정은 일괄적으로 처리되지 않습니다.</p>\n<p>앞서 설명했듯, 스레드의 동작과는 상관없이 동작하는 Scheduling으로 인해 Atomic하지 않습니다. 아래와 같이 동작할 수도 있습니다.</p>\n<p>→ A스레드의 Read(100), Add(300),</p>\n<p><strong>→ A에서 B스레드로 Context Switch(Scheduled)</strong></p>\n<p>→ B스레드의 Read(100), Add(300), Save(400)</p>\n<p><strong>→ B에서 A스레드로 Context Switch(Scheduled)</strong></p>\n<p>→ A 스레드의 Save(400)</p>\n<p>위 과정에서 A,B 두 스레드가 100인 money값을 각각 300씩 더해주었지만, 저장된 값은 400으로, <strong>스케줄링 타이밍에 따라 공유자원인 money를 수정하는 스레드의 동작을 예측할 수 없습니다.</strong></p>\n<p>이를 동시성이 보장되지 않은 상태라고 합니다.</p>\n<p><strong>동시성을 보장하는 방법</strong></p>\n<p>아래 조건을 만족하면 동시성이 보장되었다고 합니다.</p>\n<ol>\n<li>\n<p><strong>상호배제(Mutual Exclusion): 임계구역에는 단 하나의 실행흐름만이 동작할 수 있다.</strong></p>\n<p>임계구역이란, 공유자원을 수정하는 코드 영역을 일컫습니다. 상호배제는 동시성 프로그래밍의 가장 기본조건으로, 임계구역에서 공유자원을 수정하는 스레드는 하나여야함을 말합니다.</p>\n</li>\n<li>\n<p><strong>진행(Progress): 임계구역에 존재하는 실행흐름만이 임계구역으로의 접근을 막을 수 있다.</strong></p>\n<p>에를 들어, 임계구역에 아무 프로세스도 존재하지 않는데 진입하지 못하는 경우가 있을 수 있습니다.</p>\n</li>\n<li>\n<p><strong>한정대기(Bounded Waiting, for Fairness) : 임계구역에 접근하기 위해 대기하는 시간은 한정적이어야 한다.</strong></p>\n<p>다른 스레드의 임계구역 접근때문에 무한히 대기하는 스레드가 생길 수 있습니다.</p>\n</li>\n</ol>\n<p>동시성 프로그래밍의 구체적인 에시를 살펴보겠습니다.</p>\n<h3 id=\"변수를-통한-동시성-보장-방법\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EB%B2%95\" aria-label=\"변수를 통한 동시성 보장 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수를 통한 동시성 보장 방법</h3>\n<p>Thread-safe하게 동작하는것은 굉장히 복잡합니다. 아래 예시들을 통해 동시성이 보장된것같지만 그렇지 않은 예시들을 살펴보겠습니다.</p>\n<ol>\n<li>turn을 통한 할당</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> turn <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nturn <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> turn <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nturn <span class=\"token operator\">=</span> <span class=\"token number\">0</span></code></pre></div>\n<p><strong>Progress조건을 위배합니다</strong>. 하나의 스레드가 두 번 임계영역에 접근하고자 할 때, 임계구역에 어떤 스레드도 없지만 진입할 수 없습니다.</p>\n<ol>\n<li>flag를 통한 할당</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False</code></pre></div>\n<p>(여기부터 스케쥴링이 등장)</p>\n<p><strong>한정대기 조건을 위배</strong>합니다. flag[x] = True 이후 <strong>preemption</strong>된다면, 두 스레드 모두 flag를 할당받기 때문에, 무한대기 상태에 빠집니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repaet\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repaet\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False</code></pre></div>\n<p>이를 방지하기 위해 flag[x]=True구문을 while구문 아래에 넣게 된다면, while구문 이후에 preemption되었을 때,  두 스레드 모두 임계구역에 들어올 수 있어 <strong>상호배제 조건을 위배합니다.</strong></p>\n<h1 id=\"동시성-문제의-해결방법-hw-support\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C%EC%9D%98-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-hw-support\" aria-label=\"동시성 문제의 해결방법 hw support permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제의 해결방법: HW support</h1>\n<ol>\n<li>Dekker’s, Dijkstra’s 알고리즘 등 앞선 SW 해결 방식에서는 preemption으로 인해 동시성 보장이 확실시되지 않으며,</li>\n<li>Spin Lock(Busy Waitting)기반으로 자원 점유를 기다리기때문에 효율성 측면에서 오버헤드가 발생합니다.</li>\n<li>구현이 복잡합니다.</li>\n</ol>\n<p>이에 HW또는 OS측면에서 동시성 보장을 보장하기도 합니다.</p>\n<h3 id=\"tas--testandset-instruction-\" style=\"position:relative;\"><a href=\"#tas--testandset-instruction-\" aria-label=\"tas  testandset instruction  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TAS ( TestAndSet Instruction )</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">boolean <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span>boolean<span class=\"token operator\">*</span> lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tboolean old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">*</span>lock <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TAS(Test And Set Instruction) CPU level에서 구현되어, 기계적으로 Atomic하게 수행하는것을 보장하는 명령집합입니다. 불특정 시간에 Preemption되는 상황에서도 상호배제가 지켜집니다!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TAS</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">break</span>\nend <span class=\"token keyword\">while</span>\n<span class=\"token char\">''</span>'\nCRITICAL SECTION\n<span class=\"token char\">''</span>'\nlock <span class=\"token operator\">=</span> false</code></pre></div>\n<p><strong>TAS를 통해 상호배제를 보장하는 방법</strong></p>\n<p>TAS는 현재 값을 출력함과 동시에 Flag값을 True로 변경합니다.</p>\n<p>lock 전역변수에는 False,True가 들어있으며, <strong>False의경우 대기, True의 경우 점유</strong>라는 의미를 갖습니다.</p>\n<p>스레드들 중, TAS가 수행되는 동안 lock변수가 True여서 점유할 수 있게 되면, TAS명령어는 Atomic하게 True를 리턴함과 동시에 전역 Lock변수를 False로 바꿔줍니다.</p>\n<p>TAS명령은 Interrupt를 받지 않아 선정당하지 않고 Atomic하게 동작하고, 앞선 SW를 통한 해결방법보다 간단합니다.</p>\n<p><strong>TAS를 통한 동시성 제어의 제한점</strong></p>\n<p>이 방법은 상호배제와 진행을 충족하지만, 여러 스레드에서 동작할 때 <strong>공정성 측면의 한정대기는 지켜지지 않습니다.</strong></p>\n<p>Lock을 요청한 순서가 고려되어있지 않기 때문에 특정 스레드가 Lock을 계속 획득하지 못해 응답시간이 지연되는 starvation이 발생하기 때문입니다.</p>\n<p>또한 여러 개 스레드의 동시성을 제어하기 위해서는 추가적인 제어가 필요하며, Spin Lock기반이라는 점은 SW방법과 크게 다르지 않습니다.</p>\n<p>(++)</p>\n<hr>\n<p>세마포어 방식에서 사용하는 Sleep Wakeup:\nSleep 상태에서 락에 블로킹당하면 Wait큐로 들어갔다가 Ready Queue로 가기때문에, 실행순서 보장 안됨</p>\n<p>Yield의 경우, Ready Queue로 돌아가기때문에, 스케줄링 순서 보장 (공정한 스케줄링 보장)</p>\n<p>스케줄링 효율성과 공정성에 대한 등가교환 존재</p>\n<hr>\n<p>Thread throttling vs Thread pool</p>\n<p>Thread throttling과 thread pool은 모두 다중 스레드 환경에서 효율적인 자원 관리를 위해 사용되는 기술입니다.</p>\n<p>Thread throttling은 작업 수행에 필요한 리소스(보통은 CPU)를 효율적으로 활용하기 위해 작업의 실행을 지연시키는 것입니다. 예를 들어, 일정 시간 동안 특정 수의 작업만 허용하는 방식으로 스레드를 제어할 수 있습니다. 이렇게 하면 실행 중인 작업의 수가 일정하게 유지되므로 CPU 사용률이 향상되고 전체 시스템 성능이 향상될 수 있습니다.</p>\n<p>Thread pool은 스레드를 사전에 생성하고 작업을 처리할 때마다 사용 가능한 스레드 중 하나를 선택하여 할당하는 것입니다. 이렇게 하면 작업 수행에 필요한 스레드 생성 및 삭제의 오버헤드를 줄일 수 있습니다. Thread pool은 일반적으로 대규모 애플리케이션에서 사용되며, 많은 양의 요청을 처리할 때 유용합니다.</p>\n<p>따라서, Thread throttling은 실행중인 작업의 수를 제어하여 CPU 사용률을 조절하고 전체 시스템 성능을 향상시키는 반면, Thread pool은 스레드 생성 및 삭제 오버헤드를 줄이고 작업 처리를 더 효율적으로 처리할 수 있도록 돕습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><strong>OSTEP: Operating Systems: Three Easy Pieces</strong> - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><strong>HPC Lab. KOREATECH, OS Lecture-</strong> <a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></p>","id":"a63297cb-e2dd-5ad9-bd01-3b96e82a52d5","fields":{"slug":"운영체제-멀티스레드와-동시성-문제"},"frontmatter":{"date":"2023-03-22","title":"운영체제 멀티스레드와 동시성 문제","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":4},"next":{"excerpt":"데드락이란? 할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태 프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다. DeadLock drawio 운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래…","html":"<p><strong>데드락이란?</strong></p>\n<p>할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태</p>\n<p>프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/c99a815a-150e-4ba7-b500-9f8be5e5c88d\" alt=\"DeadLock drawio\"></p>\n<p>운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래 <strong>4가지 조건이 모두 충족</strong>되어야만 데드락이 발생함을 보였습니다.</p>\n<ol>\n<li>상호배제. Mutual Exclusion: 두 개의 프로세스가 필요로 하는 자원을 배타적으로 점유해야 한다.</li>\n<li>비선점. Non Preemption: 프로세스의 실행중, 다른 프로세스가 자원의 점유를 빼앗을 수 없다.</li>\n<li>점유 대기. Hold and Wait: 할당된 자원을 가진 상태로 다른 자원을 기다린다.</li>\n<li>환형 대기. Circular Wait: 여러 프로세스가 순환적으로 자원 할당을 기다린다.</li>\n</ol>\n<p><strong>데드락 예방 방법</strong></p>\n<p>그러므로, 데드락을 <strong>예방</strong>하는 방법은 위 네 가지중 한가지를 부정해주면 됩니다.</p>\n<ol>\n<li>상호배제조건 제거: 자원을 배타적으로 점유하는 조건을 제거, 자원 공유\n<ol>\n<li>락을 사용하지 않았을 때의 문제점이 그대로 발생한다.</li>\n</ol>\n</li>\n<li>비선점 조건 제거: 자원의 할당을 선점해올 수 있도록 방법 제공\n<ol>\n<li>구현이 매우 복잡해지며, 성능 오버헤드가 발생한다.</li>\n</ol>\n</li>\n<li>점유대기 제거: 프로세스의 시작시점에 필요한 모든 자원을 요청한다\n<ol>\n<li>사용하지 않는 자원을 점유하고있는 비용과, 기아상태로 인한 무한대기가 발생한다.</li>\n</ol>\n</li>\n<li>환형대기 제거: 자원을 선형으로 분류해 순서를 매기고, 증가하는 순서로만 자원을 요청.  (TODO Check 필요)\n<ol>\n<li>가장 현실적인 방법. 이것마저도 꽤 큰 성능 오버헤드 발생</li>\n</ol>\n</li>\n</ol>\n<p><strong>데드락 회피 방법</strong></p>\n<p>또, 데드락은 <strong>회피방법이</strong> 존재합니다. 예방방법과 달리, 운영체제가 실행중에 동작하는 방법이기에 회피방법이라 부릅니다.</p>\n<p>교착상태가 발생할 수 있는 자원 할당을 피하고, 안전한 상태에서만 자원 할당을 하는 방법입니다.</p>\n<p>앞선 예방방법에서도 비용 및 성능 오버헤드로 인한 한계점을 보았듯, 회복 방법 역시 태생적 한계점이 존재합니다.</p>\n<ol>\n<li>운영체제가 프로세스의 최대 자원 할당 수를 알고있어야 하고,</li>\n<li>프로세스의 수가 고정되어야 합니다 ( Process Create X )</li>\n<li>자원의 종류와 숫자가 고정되어야 합니다.</li>\n</ol>\n<p><strong>Banker’s Algorithm</strong></p>\n<p>TODO<strong>안전하지 않은 순서에 대한 예제 체크, 예시 고치기</strong></p>\n<p>다익스트라가 제안한것으로 유명한 은행원 알고리즘은, 대표적인 데드락 회피 방법입니다.</p>\n<p>프로세스와 프로세스의 최대 할당 자원, 현재 할당 자원을 알고있을 때, 최대 할당자원을 넘어가지 않는 안전순서열을 만들어 자원을 할당하는 방법입니다.</p>\n<p>운영체제는 총 14개의 자원을 갖고있다고 가정하겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Process</th>\n<th>최대 할당 자원 수</th>\n<th>현재 할당 자원 수</th>\n<th>필요한 자원 수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>12</td>\n<td>5</td>\n<td>7</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>C</td>\n<td>5</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>현재 할당된 자원 수는 12개입니다. 가용 자원 수는 4개입니다.</li>\n<li>C에 1개의 자원을 할당해 실핼시키고, C가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 8개입니다. (4 -1 + 5)</li>\n<li>B에 자원 4개를 할당해 실행시키고, B가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 9개입니다 ( 8 - 4 + 5)</li>\n<li>A에 7개의 자원을 할당하고, 모든 프로그램을 종료합니다.</li>\n</ol>\n<p>자원을 안전하게 분배할 수 있는 순서는 C → B → A가 유일합니다. (Safe Sequence)</p>\n<p>안전순서열로 보장된 실행순서로 프로세스를 실행하면 데드락을 회피할 수 있으며, 안전하지 않은 상태에서의 실행은 데드락이 발생할 수 있는 확률이 있음을 의미합니다.</p>\n<p>은행원 알고리즘은 하나의 종류의 자원이 여러개 필요하다고 가정하고 시작한다는 한계가 있습니다. 사용된다고 하더라도, 프로세스 스케줄링 루틴은 자주 일어나는 작업인데, 낮은 빈도로 발생하는 데드락을 위해 스케줄링 과정에 프로세스를 감시해야 하므로 높은 오버헤드가 존재합니다.</p>\n<p><strong>데드락 탐지 및 복구방법</strong></p>\n<p>데드락 탐지 및 복구방법은 운영체제가 실행중에 동작하는 방법인것은 회피방법과 같지만, 이 방법은 데드락이 발생 후 처리하는 방식이라는 차이점이 있습니다.</p>\n<p>먼저, 어떤 프로세스가 데드락 상태인지 판별하기 위해 Resourse Allocation Graph를 탐색해 데드락 상태인 프로세스를 탐지합니다. 이는 RAG의 자원 대기를 나타내는 그래프의 사이클을 판별하면 됩니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/9c9597e1-5c08-4225-a435-27f3e797cad0\" alt=\"2\"></p>\n<p><em>이미지 출처: <a href=\"https://velog.io/@jerry92/OS-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9Cdeadlock%EC%9D%98-%EC%A1%B0%EA%B1%B4%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@jerry92/OS-교착상태deadlock의-조건과-해결-방법</a></em></p>\n<p>사이클 내에 존재하는 프로세스는 아래 두 가지 방법중 하나로 데드락에서 탈출해야 합니다.</p>\n<ol>\n<li>\n<p>프로세스 중단: 사이클에 속하는 하나 이상 또는 전체 프로세스를 중단합니다. 전체 프로세스를 중단하는것은 대규모 작업이 될 수도 있고, 연관된 다른 프로세스까지 종료하게 된다면, 작업 손실이 발생할 수도 있습니다.</p>\n<p>이에 프로세스 age나 우선순위 등을 고려해 한개씩 삭제하는게 좋습니다.</p>\n</li>\n<li>\n<p>자원 선점: 교착상테에 놓인 자원을 선점할 때까지 프로세스의 자원을 다른 프로세스가 선점하도록 하므로써 데드락을 탈출합니다.</p>\n</li>\n</ol>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>OSTEP: Operating Systems: Three Easy Pieces - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C%5D(https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)\">Wikipedia, Deadlock</a></p>\n<p><a href=\"%5Bhttps://en.wikipedia.org/wiki/Deadlock%5D(https://en.wikipedia.org/wiki/Deadlock)\">Eng Wikipedia, Deadlock</a></p>","id":"d025e9b6-ba19-5963-9469-e8cf4cca48a4","fields":{"slug":"운영체제-데드락과-예방-회피-복구"},"frontmatter":{"date":"2023-04-16","title":"운영체제 데드락과 예방,회피,복구","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}