{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/jpa-연관관계-매핑-기초/","result":{"data":{"markdownRemark":{"html":"<p>테이블과 객체 사이에는 많은 패러다임 불일치가 있다고 앞선 챕터에서 설명했습니다. 그 중 가장 간극이 크다고 여겨지는 불일치중 하나는 <strong>연관관계의 참조</strong>에 대한 불일치 문제입니다.</p>\n<p>JPA가 이런 연관관계 참조 불일치 문제를 어떤 방식으로 해결하는지 살펴보겠습니다.</p>\n<p>이번 챕터에서는 객체 연관관계 매핑의 기초적이고 개념적인 부분을 체크합니다. 실제 프로덕트에 개발을 고려하고있다면, [다음 글 링크] 를 확인하세요!</p>\n<p><strong>JPA의</strong> <strong>연관관계 매핑을 공부하기 전, 알아야할 내용!</strong></p>\n<ul>\n<li>방향성: 양방향, 단방향이 있습니다. [팀 → 멤버] 참조 [멤버 → 팀]으로참조하는 하나의 방향만 있는 경우 단방향, 두 방향 모두 참조가 가능하다면 양방향이라고 합니다. <strong>단방향 관계는 객체에만 존재하고, 테이블은 항상 양방향 관계이므로 단방향 관계가 존재하지 않습니다.</strong> Foreign key와  Join을 통해 양쪽 테이블을 참조할 수 있기 때문입니다.</li>\n<li>다중성: [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)] 관계가 있습니다. 여러 회원이 하나의 팀에 속하므로 다대일 관계이고, 팀은 여러 회원이 소속될 수 있으므로 일대다 관계입니다.</li>\n<li>연관관계의 주인: 객체는 단방향 참조 두 개를 통해 양방향 관계를 만듭니다. 따라서, 연관관계의 주인을 정하고 이를 통해서 연관관계를 관리해야 합니다. ( 추후 설명 )</li>\n</ul>\n<p><strong>RDBMS의 외래 키</strong></p>\n<p>RDBMS에서는 외래 키는 다른 테이블의 Primary Key를 참조하는 컬럼을 말합니다. 여기에 RDBMS에서 제공하는 외래 키 제약조건(Foreign Key Constraint) DDL을 선언해주면 , <strong>참조 무결성을 보장합니다.</strong></p>\n<p>참조 무결성은 보통 삭제동작에서 검증하며, 부모 레코드가 삭제되어 고아 레코드가 되는것을 방지하고,</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088579-d6d0d2ee-1508-4fee-8f78-6179a0462961.png\" alt=\"1\"></p>\n<p>먼저 팀과 멤버가 갖는 <strong>객체, 테이블</strong> 각각에서의 연관관계를 확인하며 연관관계가 갖는 특성을 살펴보겠습니다.</p>\n<ul>\n<li>\n<p>객체에서의 연관관계</p>\n<ul>\n<li>Member.team필드로 참조를 통한 연관관계를 갖습니다.</li>\n<li>이는 <strong>단방향 관계</strong>입니다. member.getTeam()을 통해 팀을 알 수 있지만, team.getMembers()를 통해 멤버 정보를 알 수 없기 때문입니다.</li>\n</ul>\n</li>\n<li>\n<p>테이블에서의 연관관계</p>\n<ul>\n<li>TEAM_ID라는 외래 키를 통해 연관관계를 맺습니다.</li>\n<li>TEAM_ID를 통해 Member를 기준으로 Join할 수도 있고, Team을 기준으로 Join할수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>객체와 테이블 연관관계의 가장 큰 차이점: 객체는 [member → team], [team → member] 로 참조를 두 개 만들어도, 양방향 관계가 아니다!</p>\n<ul>\n<li>만약 두 방향의 참조가 모두 있다고 가정해보자.  team에 member들이 소속되어있고, member도 team 필드를 가지고있다.</li>\n<li>만약 멤버가 팀을 옮겨서 member.setTeam(anotherTeam); 으로 팀을 옮겼다고 해도, <strong>team 객체에는 옮긴 멤버의 참조가 남아있다.</strong>  단방향 관계 두 개를 따로 관리해야하는 것이다. (연관관계의 주인, mappedby가 필요한 이유)</li>\n<li>하지만 테이블은 Foreign Key를 통해 Join하므로, 멤버의 TEAM_ID필드가 변경된 경우, Team테이블에서도 Join을 통해 멤버를 조회했을 때 정상적으로 확인된다(옮긴 멤버가 조회되지 않는다)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jpa에서의-객체-매핑\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C%EC%9D%98-%EA%B0%9D%EC%B2%B4-%EB%A7%A4%ED%95%91\" aria-label=\"jpa에서의 객체 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서의 객체 매핑</h3>\n<p>Member와 Team엔티티가 연관관계를 맺는 예시입니다. 아래에서는 해당 엔티티를 통해 연관관계 매핑을 설명합니다.</p>\n<p>Member 엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>@ManyToOne: 다대일관계라는 정보를 갖는 매핑 애너테이션입니다. 매핑 시 <strong>연관관계의 주인 엔티티에</strong> 필수적으로 사용해야합니다. 양방향의 경우, 연관관계를 갖는 각 필드에 알맞는 애너테이션을 추가합니다.</li>\n<li>@JoinColumn: 외래키를 name속성의 컬럼에 매핑합니다. 생략 가능하며, 생략 시 [필드이름  + 연관 엔티티 식별자 이름] 으로 기본값을 갖습니다. (따라서 위의 경우는 “team_id” 컬럼!)</li>\n</ul>\n<h3 id=\"연관관계-저장\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%80%EC%9E%A5\" aria-label=\"연관관계 저장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계 저장</h3>\n<p>엔티티를 저장할 때는, 연관관계 엔티티를 저장하려 하는 경우, <strong>연관 엔티티 역시 영속상태여야 한다.</strong></p>\n<blockquote>\n<p>이것을 보고 궁금해서 직접 실험해봤는데, 영속하지 않은 상태에서 setTeam한 후, 영속시켜도 정상적으로 동작하는것을 확인했다.  내부적으로 어떤 차이가 있는지는 확인이 필요하다.</p>\n</blockquote>\n<h3 id=\"조회\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%ED%9A%8C\" aria-label=\"조회 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조회</h3>\n<ul>\n<li>객체 그래프 탐색을 통한 조회(프록시를 이용)\n<ul>\n<li>객체지향적인 방법!</li>\n</ul>\n</li>\n<li>객체지향 쿼리 사용(JPQL: SQL 방언으로 변환)\n<ul>\n<li>파라미터를 쿼리에 바인딩하는 전통적 방법과 유사하다.</li>\n<li>연관 엔티티는 Join문을 통해 조회한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"수정\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A0%95\" aria-label=\"수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수정</h3>\n<p><strong>연관 엔티티 수정</strong>은 특별한 방법 없이 엔티티를 수정하면 플러시 시점에 변경감지가 작동한다.</p>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<p>연관 엔티티를 제거할 때는, <strong>연관관계의 주인이 먼저 삭제될 수 없다(외래 키 제약조건) 이 경우, 데이터베이스에서 참조 무결성 오류가 발생한다.</strong></p>\n<p>따라서, 외래키를 가지고있는 부모 엔티티의 연관관계를 삭제하거나, 자식 엔티티를 삭제해 연관관계를 지운 후 부모 엔티티를 삭제할 수 있다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  테이블이 양방향 참조를 할 수 있는 이유는 무엇인가요? (객체와 참조 방향성 측면에서 어떤 차이가 있나요?)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속되지 않은 엔티티를 영속상태의 엔티티에 연관객체로 지정할 수 있나요?\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  비영속상태의 team와 영속상태의 member에서, member.setTeam(team)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속상태의 team와 비영속상태의 member에서, member.setTeam(team) 후 member 영속</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16%5D(https://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16)\">MS learn - 외래 키 제약조건</a></p>","fields":{"slug":"jpa-연관관계-매핑-기초"},"frontmatter":{"title":"JPA 연관관계 매핑 기초","date":"17.01.2023","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"jpa-연관관계-매핑-기초","prev":{"excerpt":"JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다. 데이터베이스에는 유일성 최소성을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.…","html":"<p>JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다.</p>\n<p>데이터베이스에는 <strong>유일성</strong> <strong>최소성</strong>을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088482-446952cd-6dc2-42a8-b0dd-10e0a9e20137.png\" alt=\"1\"></p>\n<p><strong>유일성</strong>이란, 여러 레코드들 중, 하나의 레코드를 특정지을 수 있는 키의 특성입니다.</p>\n<p>예를들어 이름,생일과 같은 특성은 레코드를 하나로 특정지을 수 없지만, [**학교 , 학번]**의 조합이나 [**주민등록번호]**와 같은 특성은 레코드를 유일하게 특정지을 수 있으므로 유일성을 만적하는 특성입니다.</p>\n<p><strong>최소성</strong>이란, 레코드를 유일하게 식별하는데 꼭 필요한 최소한의 특성만 선택되어야한다는 키의 특성입니다.</p>\n<p>예를 들어, <strong>[이름, 나이, 주민등록번호]</strong> 의 속성 조합으로 유일성을 만족하지만, 이름과 나이 없이 주민등록번호만으로 레코드를 유일하게 식별할 수 있으므로, <strong>최소성을 만족하지 못하는 키</strong>이고, <strong>[주민등록번호]</strong> 로 구성된 키는 <strong>최소성을 만족한다</strong>고 할 수 있습니다.</p>\n<h2 id=\"jpa의-기본-키-매핑-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa의 기본 키 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 기본 키 매핑 방법</h2>\n<p>데이터베이스 시스템에서는 보통 레코드의 기본 키를 설정하기 위한 디폴트 설정이 있습니다. 앞서 소개한 주민등록번호나 학교+학번은 사실 <strong>비즈니스 상 변경</strong>될 수도 있는 값이고, <strong>인덱스를 통해</strong> <strong>효율적으로 탐색</strong>하기에는 부적절한 키입니다.</p>\n<p>그렇기때문에 데이터베이스 시스템에서는 비즈니스 로직과 관계 없는 고유한 값을 만들어 기본 키로 채택하는데요,   이번 글은 JPA에서 엔티티와 데이터베이스 테이블 간 “기본 키”를 어떻게 생성하고 매핑하는지 알아보겠습니다.</p>\n<p>참고로 좋은 데이터베이스 기본 키를 선택하는 기준은 아래와 같습니다.</p>\n<ul>\n<li>Null값을 허용하지 않음</li>\n<li>변하지 않음</li>\n<li>유일함</li>\n</ul>\n<p>JPA로 엔티티를 한번 이상 만들어봤다면, 기본적으로 아래 구조를 띄는것을 알 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 구성하면, Member테이블의 Key인 Id필드는 언제 지정될까요? 영속성 관리에서 배운것처럼, 엔티티는 바로 데이터베이스에 저장되지 않고 1차캐시에 저장됩니다.</p>\n<p><em><strong>고치기</strong></em></p>\n<p>만약 데이터베이스의 기본 키 생성 전략이 직접할당일 경우에는, 애플리케이션에서 엔티티의 키를 설정할 방법이 없을것입니다.</p>\n<p>JPA에서는 데이터베이스 벤더별로 각기 다른 키 생성 전략과 자바 엔티티를 매핑하기 위해, @Id 컬럼에 여러 옵션들을 제공합니다.</p>\n<h2 id=\"기본-키-생성-전략\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5\" aria-label=\"기본 키 생성 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 키 생성 전략</h2>\n<p>기본키를 어떤 방식으로 생성하느냐에 따라, <strong>개발자가 키를 직접 설정하는</strong> 직접할당 전략, <strong>자동으로 키를 생성하는</strong>  IDENTITY, SEQUENCE, TABLE, AUTO 전략을 살펴봅니다.</p>\n<p>아래의 Java 타입을 선언한 뒤, Id애너테이션을 통해 필드가 기본 키로 매핑되도록 합니다.</p>\n<p>@<strong>Id필드 타입</strong></p>\n<p>Id 애너테이션은 다음과 같은 자바 타입에서만 적용 가능합니다</p>\n<ul>\n<li>Primitive Types</li>\n<li>Wrapper Types</li>\n<li>String</li>\n<li>java.util.Date</li>\n<li>java.sql.Date</li>\n<li>java.math.[bigDecimal, bigInteger]</li>\n</ul>\n<h3 id=\"직접-할당-전략\" style=\"position:relative;\"><a href=\"#%EC%A7%81%EC%A0%91-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5\" aria-label=\"직접 할당 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>직접 할당 전략</h3>\n<p>기본 키 직접 할당 전략은 프로그래머가 <strong>엔티티매니저에 영속되기 전에</strong> 엔티티의 키를 직접 할당하는 방식입니다.</p>\n<p>이 방식에서 식별자 값 없이 영속시키면 PersistenceExeption이 발생합니다.</p>\n<p><strong>설정방법:  Id</strong> 필드에 @Id 애너테이션을 적용하면 기본키를 직접 할당방식으로 테이블이 생성됩니다.</p>\n<h3 id=\"identity-전략\" style=\"position:relative;\"><a href=\"#identity-%EC%A0%84%EB%9E%B5\" aria-label=\"identity 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IDENTITY 전략</h3>\n<p>IDENTITY전략은 기본 키 생성 전략을 데이터베이스에 위임하는 방식입니다.</p>\n<p>보통 AUTO_INCREMENT같은 자동 키 생성방법을 제공하는 MySQL, Postgresql, DB2등에서 사용합니다.</p>\n<p><strong>설정방법: 필드에</strong> GeneratedValue 애너테이션, strategy 옵션을 GenerationType.IDENTITY로 설정</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">IDENTITY</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>em.persist(member) → insert query 날리고 → select query(id 포함된 레코드) → 영속성 컨텍스트에 저장</strong></p>\n<p><strong>주의사항</strong></p>\n<p>영속성 컨텍스트에 저장될때는 필수로 식별자 값이 필요한데, IDENTITY 전략에서는 기본 키를 데이터베이스에서 지정하므로, <strong>식별자를 알 수없다</strong>.</p>\n<p>그러므로 IDENTITY전략을 사용하는 엔티티는 <strong>영속되는 시점에 INSERT쿼리를 데이터베이스에 전달</strong>한다.</p>\n<p>따라서 <strong>IDENTITY전략에서는 트랜잭션을 지원하는 쓰기지연이 동작하지 않는다.</strong></p>\n<p><strong>최적화 방법</strong></p>\n<p>IDENTITY전략에서는 영속 시 INSERT쿼리를 데이터베이스에 전달하고, 식별자를 얻기 위해 추가로 조회작업을 해야해서 총 <strong>2번의 통신이 이뤄진다.</strong></p>\n<p>JDBC3에서 추가된 Statement.getGeneratedKeys()를 사용하면, 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다.</p>\n<h3 id=\"sequence-전략\" style=\"position:relative;\"><a href=\"#sequence-%EC%A0%84%EB%9E%B5\" aria-label=\"sequence 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SEQUENCE 전략</h3>\n<p>데이터베이스에서 시퀀스는 유일한 값을 순서대로 생성하는 데이터베이스 오브젝트입니다. Sequence를 제공하는 Oracle,Postgresql, DB2,H2등에서 사용가능합니다.</p>\n<p>SEQUENCE방법은 이를 통해 기본 키를 생성합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>엔티티에 @SequenceGenerator 등록: 시퀀스 생성기 등록  옵션은 아래와 같습니다.\n<ul>\n<li>name : 엔티티에서 갖는 시퀀스생성기 이름(필수)</li>\n<li>sequenceName : 데이터베이스의 시퀀스 이름</li>\n<li>initialValue : DDL 생성시 처음 시작하는 숫자</li>\n<li>allocationSize:시퀀스 호출 시 증가하는 숫자, 기본값 50 (최적화에 사용)</li>\n<li>catalog, schema: 데이터베이스의  catalog, schema</li>\n</ul>\n</li>\n<li>@GeneratedValue의 strategy 속성을 GenerationType.SEQUENCE로 설정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@SequenceGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>  \n\tsequenceName<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ\"</span><span class=\"token punctuation\">,</span> \n\tinitialValue<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> \n\tallocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span>  \n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy<span class=\"token operator\">=</span><span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SEQUENCE</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>@SequenceGenerator의 옵션이 다양하게 존재하는것을 확인할 수 있다.</p>\n<p><strong>참고사항1. 시퀀스 동작구조</strong></p>\n<p>IDENTITY전략과 마찬가지로 ,데이터베이스에서 식별자 값을 가져와야 하지만 IDENTITY전략이 영속성 컨텍스트에서 Insert 쿼리를 날린 뒤 조회를 한것과는 달리, SEQUENCE 전략에서는 데이터베이스 시퀀스만 조회해 식별자값만 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> emp_seq<span class=\"token punctuation\">.</span>NEXTVAL\n     <span class=\"token punctuation\">,</span> emp_seq<span class=\"token punctuation\">.</span>CURRVAL\n  <span class=\"token keyword\">FROM</span> dual</code></pre></div>\n<p>따라서 <strong>SEQUENCE전략은 트랜잭션을 사용하는 쓰기지연 방식을 지원하지만, 시퀀스를 추가적으로 조회한다</strong>.</p>\n<p><strong>참고사항 2. allocationSize의 기본값이 50이다.</strong></p>\n<p><strong>hibernate.id.new_generator_mappings 설정이 true인 경우, allocationSize</strong>는 <strong>기본적으로 50으로 설정됩니다. 이는 JPA의 시퀀스 접근횟수를 줄이기 위함이고, 아래와 같이 동작합니다.</strong></p>\n<ul>\n<li>JPA에서 데이터베이스 시퀀스에 접근</li>\n<li>시퀀스는 <strong>allocationSize값인 50만큼 시퀀스를 생성</strong></li>\n<li>JPA는 메모리에 1 ~ 50까지의 시퀀스를 메모리에 할당.</li>\n<li>50개까지 엔티티가 생성되어도, 시퀀스를 생성하기 위해 DB에 접근하지 않아도 됨.</li>\n</ul>\n<p>멀티서버 환경에서는 엔티티가 생성된 순서대로 ID가 증가하지는 않지만, Insert성능 측면에서 가장 훌륭함.</p>\n<h3 id=\"table-전략\" style=\"position:relative;\"><a href=\"#table-%EC%A0%84%EB%9E%B5\" aria-label=\"table 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TABLE 전략</h3>\n<p>TABLE전략은 키 생성용 테이블을 만들고, 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략입니다. 또한, 테이블을 사용하므로 모든 데이터베이스에서 적용가능합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>필드에 @GeneratedValue 등록, 아래의 속성 추가\n<ul>\n<li>strategy = GenerationType.Table,</li>\n<li>generator = 시퀀스 생성테이블 이름(TableGenerator의 name속성 값) 등록</li>\n</ul>\n</li>\n<li>엔티티에 @TableGenerator 등록 : 속성들이 많은데, 시퀀스 테이블을 구성하기 위한 이름과 관련된것들이 많습니다. 아래에서 설명합니다.\n<ul>\n<li>name: 식별자 생성기 이름 (필수)</li>\n<li>table:  키 생성 테이블명 (기본값 - hibernate_sequence)</li>\n<li>pkColumnValue:  키로 사용할 이름 [ Default - 엔티티명 ]</li>\n<li>pkColumnName: 시퀀스 컬럼명 [ Default - sequence_name]</li>\n<li>valueColumnName: 시퀀스 값 컬럼명 [ Default - next_val ]</li>\n<li>initalValue: 초기 값 [ Default - 0 ]</li>\n<li>allocationSize; 시퀀스 한번 호출에 증가하는 숫자(최적화용), [ Default  1 or 50: 최적화 설정 적용여부에 따라 ]</li>\n<li>catalog, schema: 데이터베이스 catalog, schema 이름</li>\n<li>uniqueConstraints: 유니크 제약조건</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@TableGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>\n\ttable<span class=\"token operator\">=</span><span class=\"token string\">\"MY_SEQUENCE\"</span><span class=\"token punctuation\">,</span>\n\tpkColumnValue<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ\"</span><span class=\"token punctuation\">,</span> allocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Board</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TABLE</span><span class=\"token punctuation\">,</span>\n\t\tgenerator <span class=\"token operator\">=</span> <span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 등록 하게 되면, 아래와 같이 시퀀스 이름과 시퀀스 값을 컬럼으로 갖는 테이블을 만들어 시퀀스를 관리합니다</p>\n<p>앞서 @TableGenerator의 속성들 중 <del>Column</del> 같은 이름에 사용되는 속성들이 많이 보이는데요, 시퀀스테이블을 구성할 때 사용하는 이름입니다.</p>\n<table>\n<thead>\n<tr>\n<th>sequence_name</th>\n<th>next_val</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BOARD_SEQ</td>\n<td>102</td>\n</tr>\n<tr>\n<td>MEMBER_SEQ</td>\n<td>50</td>\n</tr>\n</tbody>\n</table>\n<p><strong>참고사항: 테이블전략 동작구조</strong></p>\n<p>(시퀀스)테이블의 값을 조회하고, 이 값을 기반으로 Update쿼리를 한번 더 날리기때문에, 시퀀스 전략보다 네트워크 통신을 1회 더 한다는 단점이 있습니다.</p>\n<p>이는 SEQUENCE방법과 같이 allocationSize를 통해 최적화할 수 있습니다.</p>\n<h3 id=\"auto-전략\" style=\"position:relative;\"><a href=\"#auto-%EC%A0%84%EB%9E%B5\" aria-label=\"auto 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AUTO 전략</h3>\n<p>@GeneratedValue.strategy의 기본 설정값인 AUTO전략입니다.</p>\n<p>AUTO 전략은 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE중 하나를 자동으로 선택합니다.</p>\n<ul>\n<li><strong>데이터베이스가 변경되어도 코드를 수정할 필요가 없습니다.</strong></li>\n<li>MySQL은 IDENTITY, Oracle은 SEQUENCE방법 선택합니다.</li>\n</ul>\n<h2 id=\"매우매우-중요한-뽀인트\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%EC%9A%B0%EB%A7%A4%EC%9A%B0-%EC%A4%91%EC%9A%94%ED%95%9C-%EB%BD%80%EC%9D%B8%ED%8A%B8\" aria-label=\"매우매우 중요한 뽀인트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매우매우 중요한 뽀인트</h2>\n<p>JPA에서 <strong>키 생성 전략은 INSERT성능에 중요한 영향을 미친다!!!</strong></p>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  자동 키 생성전략: IDENTITY, SEQUENCE, TABLE 방법에서 영속성 컨텍스트에 식별자를 동기화하기 위해 각각은 어떻게 동작하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  allocationSize 속성은 어떻게 키 생성 전략에서 최적화를 수행하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  AUTO 생성전략은 무엇이고, 어떤 장점이 있나요?</li>\n</ul>\n<h2 id=\"챕터에-없지만-알아볼-내용\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EC%97%86%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EB%B3%BC-%EB%82%B4%EC%9A%A9\" aria-label=\"챕터에 없지만 알아볼 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 없지만 알아볼 내용</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  Table 방식과 Sequence 방식은 근본적으로 어떤 차이점이 있나요? (시퀸스는 테이블과 어떻게 다른가요?)</p>\n</li>\n</ul>\n<h3 id=\"정답\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%8B%B5\" aria-label=\"정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정답</h3>\n<ul>\n<li>각 방법에 대한 답변\n<ul>\n<li>IDENTITY의 경우, 데이터베이스에 키 생성전략을 위임한다. AUTO_INCREMENT같이 자동으로 기본 키를 설정해주는 MYSQL등에서 사용한다. (MySQL AUTO_INCREMENT가 적용되었을 때, id없이 insert 쿼리가 가능하다!). [ 삽입/조회 쿼리 발생, 쓰기지연 불가 ]</li>\n<li>SEQUENCE는 증가하는 값을 생성해내는 객체로, 조회만을 통해 증가하는 값을 할당받아 엔티티의 키로 지정한다. [ 조회쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n<li>TABLE은 키 할당 정보를 관리하는 테이블을 생성해 키를 매핑한다. Sequence와 유사하게 동작합니다. [ 조회/수정쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n</ul>\n</li>\n<li>Table, Sequence방법에서 사용하는 최적화 전략으로, 키를 allocationSize만큼 할당받아 사용. 식별자를 생성하기 위해 N회 쿼리를 날리는것에서 N/allocationSize 만큼만 쿼리를 날리게 됨.</li>\n<li>AUTO방식은 데이터베이스 방언에 맞는 자동 키 생성방식을 설정합니다. 데이터베이스 벤더가 변경되어도 코드가 변경될 필요가 없다는 장점이 있습니다.</li>\n</ul>\n<hr>\n<ul>\n<li>시퀀스는 select 시퀀스네임.nextval from dual 을 통해 다음 값을 조회하고 자동으로 증가합니다. 따라서 테이블 방식과 달리, Update 쿼리를 사용할 필요가 없어 효율적입니다.</li>\n</ul>","id":"b78f1971-39d1-5252-8584-8372d1a2ca74","fields":{"slug":"jpa에서-기본-키-매핑-방법-종류"},"frontmatter":{"date":"2023-01-13","title":"JPA에서 기본 키 매핑 방법 종류","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":4},"next":{"excerpt":"이글에서는 다대일, 일대다 매핑과 연관관계의 주인에 대해 알아보겠습니다. 일대다, 다대일 관계 JPA의 일대다, 다대일에서는 항상 연관관계의 주인이 “다” 쪽이고, 외래키 역시 “다”쪽에서 관리합니다. 예를들어 Member와 Team이 있다면, 항상 Member가 Team을 참조할 수 있는 외래키를 가지고있는 것이죠. RDBMS…","html":"<p>이글에서는 <strong>다대일, 일대다 매핑</strong>과 <strong>연관관계의 주인</strong>에 대해 알아보겠습니다.</p>\n<h3 id=\"일대다-다대일-관계\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A4%EB%8C%80%EC%9D%BC-%EA%B4%80%EA%B3%84\" aria-label=\"일대다 다대일 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다, 다대일 관계</h3>\n<p>JPA의 일대다, 다대일에서는 항상 연관관계의 주인이 “다” 쪽이고, 외래키 역시 “다”쪽에서 관리합니다. 예를들어 Member와 Team이 있다면, 항상 Member가 Team을 참조할 수 있는 외래키를 가지고있는 것이죠.</p>\n<p>RDBMS의 레코드는 컬럼에 하나의 값만 들어가는 <a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity)%5D(https://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity))\">원자성</a>을 가지고있으므로, 일대다 관계에서 “일” 쪽이 “다”의 외래키를 들고있을 수 없기 때문이죠.</p>\n<p>하지만 객체는 다릅니다. 하나의 객체가 List를 가지고있을 수도 있기때문에, “일”쪽에서 연관관계의 주인이 되고싶어할 수 도 있습니다. 이런 경우, JoinTable을 통해 제 3의 테이블이 Member와 Team의 연관관계를 관리하게되고, Team객체에서도 외래키를 수정할 수 있게 되죠. 하지만, 이는 잘 사용하지 않습니다.</p>\n<h2 id=\"연관관계의-주인\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8\" aria-label=\"연관관계의 주인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인</h2>\n<p>연관관계의 주인이란, 연관관계에서 외래키의 등록/수정/삭제 권한을 갖는 엔티티를 의미합니다.</p>\n<p>외래키를 통한 양방향 관계인 데이터베이스 테이블과 달리, <strong>양방향 매핑 관계</strong>에서 객체는 두 개의 단방향 참조로 이루어져있으므로 <strong>외래 키를 관리할 주체를 mappedby를 통해 설정</strong>해야 합니다. (연관관계의 주인이 아닌 쪽에 mappedBy를 설정한다)</p>\n<h2 id=\"다대일-단방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089333-f4316b73-a8d9-4317-b6a1-0378f10bc01e.png\" alt=\"2\"></p>\n<p><strong>다대일 단방향관계에서는 항상 연관관계의 주인은 “다” 쪽</strong>입니다. 아래 예시에서도 멤버와 팀의 경우, 멤버에서 외래키를 들고있으며, 테이블에서도 외래키를 가지고있는것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team객체에서는 Member로의 참조가 없습니다.하지만 Member는 Team의 id 컬럼을 TEAM_ID로 매핑해 사용합니다.</p>\n<p>또한, ManyToOne같은 다대일, 일대다 관계에서는 “다”측이 자동으로 연관관계의 주인이 되어 외래키를 관리합니다.</p>\n<h2 id=\"일대다-단방향\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"일대다 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089331-adbb4ebb-c020-42ca-9fd3-2daa425141af.png\" alt=\"1\"></p>\n<p>일대다 단방향 매핑은 많이 사용되지 않는 매핑입니다. Team, Member관계에서 Team이 연관관계를 가지고있기 위해서는 JoinTable이라는 제 3의 테이블이 등장합니다. 이를 통해 Team에서 JoinTable에 있는 외래키를 관리해, Team이 외래키를 관리하는것 “처럼” 보이게 해주죠.</p>\n<p>보통은 일대다 단방향 관계에서도 JoinColumn을 통해 “다”쪽에서 외래키를 관리합니다.</p>\n<p>일대다 단방향 관계에서 JoinColumn, JoinTable이 어떻게 생성되는지 실험해봤으니, 궁금하다면 <a href=\"%5Bhttps://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md%5D(https://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md)\">실험 리포지토리</a>에서 확인해보시길 바랍니다.</p>\n<h2 id=\"다대일-일대다-양방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EC%96%91%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 일대다 양방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일, 일대다 양방향</h2>\n<p>앞선 단방향 관계에서 점선 하나가 추가되었습니다. (연관관계의 주인이 아닌 방향 참조) 다대일 양방향 연관관계는 신경쓸 것이 많습니다. 두 객체가 서로에 대한 참조를 가지고있기에**, 데이터의 불일치가 발생**할 수 있습니다.</p>\n<p>먼저 코드를 살펴보고, 고려해야할 사항을 뒤따라 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>team <span class=\"token operator\">=</span> team<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//중복, 무한루프에 빠지지 않도록 체크</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span>team<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">contain</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\t\t\tteam<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"team\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addMember</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tmembers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞선 다대일 단방향 관계와 달라진 점들이 있습니다. 양방향 관계에서 특히 주의해야할 부분입니다.</p>\n<h3 id=\"편의-메서드-작성-중복-불일치-및-무한루프--방지\" style=\"position:relative;\"><a href=\"#%ED%8E%B8%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%A4%91%EB%B3%B5-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%B0%8F-%EB%AC%B4%ED%95%9C%EB%A3%A8%ED%94%84--%EB%B0%A9%EC%A7%80\" aria-label=\"편의 메서드 작성 중복 불일치 및 무한루프  방지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>편의 메서드 작성 (중복, 불일치 및 무한루프  방지)</h3>\n<p>위에서 연관관계를 설정할 때, 기본 setter를 사용하는것이 아닌, 편의 메서드를 작성한 부분을 확인할 수 있습니다. (addMember, setTeam에 해당)</p>\n<p>앞서 말했듯 객체의 양방향은 두 개의 단방향이므로, 팀이 멤버를 추가했어도 멤버는 팀을 설정하지 않아 데이터 불일치가 발생하므로, 팀 → 멤버 추가, 멤버 → 팀 추가에 대한 코드를 함께 작성하고, 이를 팀,멤버 엔티티 모두에 작성하는것이 좋습니다. 이를 통해서 데이터의 불일치를 방지할 수 있습니다.</p>\n<ul>\n<li>데이터 삽입 시에는 중복삽입이 발생할 수 있습니다.</li>\n<li>toString문에서는 무한루프가 발생합니다. 이를 순환참조라고 합니다.\n<ul>\n<li>member. toStirng → member.Team.toString→ member.Team.members.toString() ….</li>\n<li>이를 방지하기 위해, DTO를 사용하거나, Mapper, Json관련 애너테이션을 사용합니다.</li>\n<li><a href=\"%5Bhttps://dev-coco.tistory.com/133%5D(https://dev-coco.tistory.com/133)\">순환참조 문제 해결 방법들</a>을 참고해주세요. 저는 mapper 라이브러리를 사용해 DTO에서 데이터를 관리하는 방법을 사용합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"연관관계의-주인-설정\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8-%EC%84%A4%EC%A0%95\" aria-label=\"연관관계의 주인 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인 설정</h3>\n<p><strong>앞선 단방향 관계에서는 연관관계를 매핑하는 필드가 멤버에 존재했으므로 외래키의 관리하는 쪽(=연관관계의 주인)은 멤버였습니다.</strong></p>\n<p>하지만 양방향 연관관계는 멤버, 팀 모두가 참조를 가지고있으므로, 연관관계의 주인을 <strong>직접 설정</strong>해야합니다.</p>\n<p><strong>mappedBy속성은 연관관계의 주인을 어디로할지(외래키를 어디서 수정할지)에 대해서 명시합니다. (@OneToMany(mappedBy=\"team\")에 해당)</strong></p>\n<p>참고로, ManyToOne은 연관관계의 주인인 Many쪽에서 외래키 필드를 관리하므로,  mappedBy속성이 없습니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul>\n<li>mappedBy속성은 어느 경우에 어디에 사용하는가?</li>\n<li>편의메서드를 작성하는 이유는?</li>\n<li><a href=\"%5Bhttps://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s%5D(https://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s)\">백기선님의 “이것도 모르면 JPA쓰지마라(다시 공부하거나) ”</a></li>\n</ul>\n<h3 id=\"추가질문\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8\" aria-label=\"추가질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가질문</h3>\n<ul>\n<li>OneToMany 단방향 관계에서 외래키 관리는 어떻게 동작하는가?</li>\n</ul>\n<h3 id=\"복습-및-추가질문-정답\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5-%EB%B0%8F-%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%8B%B5\" aria-label=\"복습 및 추가질문 정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습 및 추가질문 정답</h3>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>책 -  김영한 저 Java ORM 표준 JPA 프로그래밍 (에이콘 출판, 2015)</p>","id":"b08e891d-8149-5376-a6a4-18f0bce3c1d1","fields":{"slug":"jpa-다대일-일대다-매핑"},"frontmatter":{"date":"2023-01-18","title":"JPA 다대일, 일대다 매핑","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":3}}},"staticQueryHashes":[],"slicesMap":{}}