{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/jpa-다대일-일대다-매핑/","result":{"data":{"markdownRemark":{"html":"<p>이글에서는 <strong>다대일, 일대다 매핑</strong>과 <strong>연관관계의 주인</strong>에 대해 알아보겠습니다.</p>\n<h3 id=\"일대다-다대일-관계\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A4%EB%8C%80%EC%9D%BC-%EA%B4%80%EA%B3%84\" aria-label=\"일대다 다대일 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다, 다대일 관계</h3>\n<p>JPA의 일대다, 다대일에서는 항상 연관관계의 주인이 “다” 쪽이고, 외래키 역시 “다”쪽에서 관리합니다. 예를들어 Member와 Team이 있다면, 항상 Member가 Team을 참조할 수 있는 외래키를 가지고있는 것이죠.</p>\n<p>RDBMS의 레코드는 컬럼에 하나의 값만 들어가는 <a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity)%5D(https://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity))\">원자성</a>을 가지고있으므로, 일대다 관계에서 “일” 쪽이 “다”의 외래키를 들고있을 수 없기 때문이죠.</p>\n<p>하지만 객체는 다릅니다. 하나의 객체가 List를 가지고있을 수도 있기때문에, “일”쪽에서 연관관계의 주인이 되고싶어할 수 도 있습니다. 이런 경우, JoinTable을 통해 제 3의 테이블이 Member와 Team의 연관관계를 관리하게되고, Team객체에서도 외래키를 수정할 수 있게 되죠. 하지만, 이는 잘 사용하지 않습니다.</p>\n<h2 id=\"연관관계의-주인\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8\" aria-label=\"연관관계의 주인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인</h2>\n<p>연관관계의 주인이란, 연관관계에서 외래키의 등록/수정/삭제 권한을 갖는 엔티티를 의미합니다.</p>\n<p>외래키를 통한 양방향 관계인 데이터베이스 테이블과 달리, <strong>양방향 매핑 관계</strong>에서 객체는 두 개의 단방향 참조로 이루어져있으므로 <strong>외래 키를 관리할 주체를 mappedby를 통해 설정</strong>해야 합니다. (연관관계의 주인이 아닌 쪽에 mappedBy를 설정한다)</p>\n<h2 id=\"다대일-단방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089333-f4316b73-a8d9-4317-b6a1-0378f10bc01e.png\" alt=\"2\"></p>\n<p><strong>다대일 단방향관계에서는 항상 연관관계의 주인은 “다” 쪽</strong>입니다. 아래 예시에서도 멤버와 팀의 경우, 멤버에서 외래키를 들고있으며, 테이블에서도 외래키를 가지고있는것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team객체에서는 Member로의 참조가 없습니다.하지만 Member는 Team의 id 컬럼을 TEAM_ID로 매핑해 사용합니다.</p>\n<p>또한, ManyToOne같은 다대일, 일대다 관계에서는 “다”측이 자동으로 연관관계의 주인이 되어 외래키를 관리합니다.</p>\n<h2 id=\"일대다-단방향\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"일대다 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089331-adbb4ebb-c020-42ca-9fd3-2daa425141af.png\" alt=\"1\"></p>\n<p>일대다 단방향 매핑은 많이 사용되지 않는 매핑입니다. Team, Member관계에서 Team이 연관관계를 가지고있기 위해서는 JoinTable이라는 제 3의 테이블이 등장합니다. 이를 통해 Team에서 JoinTable에 있는 외래키를 관리해, Team이 외래키를 관리하는것 “처럼” 보이게 해주죠.</p>\n<p>보통은 일대다 단방향 관계에서도 JoinColumn을 통해 “다”쪽에서 외래키를 관리합니다.</p>\n<p>일대다 단방향 관계에서 JoinColumn, JoinTable이 어떻게 생성되는지 실험해봤으니, 궁금하다면 <a href=\"%5Bhttps://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md%5D(https://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md)\">실험 리포지토리</a>에서 확인해보시길 바랍니다.</p>\n<h2 id=\"다대일-일대다-양방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EC%96%91%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 일대다 양방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일, 일대다 양방향</h2>\n<p>앞선 단방향 관계에서 점선 하나가 추가되었습니다. (연관관계의 주인이 아닌 방향 참조) 다대일 양방향 연관관계는 신경쓸 것이 많습니다. 두 객체가 서로에 대한 참조를 가지고있기에**, 데이터의 불일치가 발생**할 수 있습니다.</p>\n<p>먼저 코드를 살펴보고, 고려해야할 사항을 뒤따라 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>team <span class=\"token operator\">=</span> team<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//중복, 무한루프에 빠지지 않도록 체크</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span>team<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">contain</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\t\t\tteam<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"team\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addMember</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tmembers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞선 다대일 단방향 관계와 달라진 점들이 있습니다. 양방향 관계에서 특히 주의해야할 부분입니다.</p>\n<h3 id=\"편의-메서드-작성-중복-불일치-및-무한루프--방지\" style=\"position:relative;\"><a href=\"#%ED%8E%B8%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%A4%91%EB%B3%B5-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%B0%8F-%EB%AC%B4%ED%95%9C%EB%A3%A8%ED%94%84--%EB%B0%A9%EC%A7%80\" aria-label=\"편의 메서드 작성 중복 불일치 및 무한루프  방지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>편의 메서드 작성 (중복, 불일치 및 무한루프  방지)</h3>\n<p>위에서 연관관계를 설정할 때, 기본 setter를 사용하는것이 아닌, 편의 메서드를 작성한 부분을 확인할 수 있습니다. (addMember, setTeam에 해당)</p>\n<p>앞서 말했듯 객체의 양방향은 두 개의 단방향이므로, 팀이 멤버를 추가했어도 멤버는 팀을 설정하지 않아 데이터 불일치가 발생하므로, 팀 → 멤버 추가, 멤버 → 팀 추가에 대한 코드를 함께 작성하고, 이를 팀,멤버 엔티티 모두에 작성하는것이 좋습니다. 이를 통해서 데이터의 불일치를 방지할 수 있습니다.</p>\n<ul>\n<li>데이터 삽입 시에는 중복삽입이 발생할 수 있습니다.</li>\n<li>toString문에서는 무한루프가 발생합니다. 이를 순환참조라고 합니다.\n<ul>\n<li>member. toStirng → member.Team.toString→ member.Team.members.toString() ….</li>\n<li>이를 방지하기 위해, DTO를 사용하거나, Mapper, Json관련 애너테이션을 사용합니다.</li>\n<li><a href=\"%5Bhttps://dev-coco.tistory.com/133%5D(https://dev-coco.tistory.com/133)\">순환참조 문제 해결 방법들</a>을 참고해주세요. 저는 mapper 라이브러리를 사용해 DTO에서 데이터를 관리하는 방법을 사용합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"연관관계의-주인-설정\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8-%EC%84%A4%EC%A0%95\" aria-label=\"연관관계의 주인 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인 설정</h3>\n<p><strong>앞선 단방향 관계에서는 연관관계를 매핑하는 필드가 멤버에 존재했으므로 외래키의 관리하는 쪽(=연관관계의 주인)은 멤버였습니다.</strong></p>\n<p>하지만 양방향 연관관계는 멤버, 팀 모두가 참조를 가지고있으므로, 연관관계의 주인을 <strong>직접 설정</strong>해야합니다.</p>\n<p><strong>mappedBy속성은 연관관계의 주인을 어디로할지(외래키를 어디서 수정할지)에 대해서 명시합니다. (@OneToMany(mappedBy=\"team\")에 해당)</strong></p>\n<p>참고로, ManyToOne은 연관관계의 주인인 Many쪽에서 외래키 필드를 관리하므로,  mappedBy속성이 없습니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul>\n<li>mappedBy속성은 어느 경우에 어디에 사용하는가?</li>\n<li>편의메서드를 작성하는 이유는?</li>\n<li><a href=\"%5Bhttps://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s%5D(https://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s)\">백기선님의 “이것도 모르면 JPA쓰지마라(다시 공부하거나) ”</a></li>\n</ul>\n<h3 id=\"추가질문\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8\" aria-label=\"추가질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가질문</h3>\n<ul>\n<li>OneToMany 단방향 관계에서 외래키 관리는 어떻게 동작하는가?</li>\n</ul>\n<h3 id=\"복습-및-추가질문-정답\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5-%EB%B0%8F-%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%8B%B5\" aria-label=\"복습 및 추가질문 정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습 및 추가질문 정답</h3>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>책 -  김영한 저 Java ORM 표준 JPA 프로그래밍 (에이콘 출판, 2015)</p>","fields":{"slug":"jpa-다대일-일대다-매핑"},"frontmatter":{"title":"JPA 다대일, 일대다 매핑","date":"01.18.2023","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":3}},"pageContext":{"slug":"jpa-다대일-일대다-매핑","prev":{"excerpt":"테이블과 객체 사이에는 많은 패러다임 불일치가 있다고 앞선 챕터에서 설명했습니다. 그 중 가장 간극이 크다고 여겨지는 불일치중 하나는 연관관계의 참조에 대한 불일치 문제입니다. JPA가 이런 연관관계 참조 불일치 문제를 어떤 방식으로 해결하는지 살펴보겠습니다. 이번 챕터에서는 객체 연관관계 매핑의 기초적이고 개념적인 부분을 체크합니다. 실제 프로덕트에 개발을 고려하고있다면, [다음 글 링크] 를 확인하세요! JPA…","html":"<p>테이블과 객체 사이에는 많은 패러다임 불일치가 있다고 앞선 챕터에서 설명했습니다. 그 중 가장 간극이 크다고 여겨지는 불일치중 하나는 <strong>연관관계의 참조</strong>에 대한 불일치 문제입니다.</p>\n<p>JPA가 이런 연관관계 참조 불일치 문제를 어떤 방식으로 해결하는지 살펴보겠습니다.</p>\n<p>이번 챕터에서는 객체 연관관계 매핑의 기초적이고 개념적인 부분을 체크합니다. 실제 프로덕트에 개발을 고려하고있다면, [다음 글 링크] 를 확인하세요!</p>\n<p><strong>JPA의</strong> <strong>연관관계 매핑을 공부하기 전, 알아야할 내용!</strong></p>\n<ul>\n<li>방향성: 양방향, 단방향이 있습니다. [팀 → 멤버] 참조 [멤버 → 팀]으로참조하는 하나의 방향만 있는 경우 단방향, 두 방향 모두 참조가 가능하다면 양방향이라고 합니다. <strong>단방향 관계는 객체에만 존재하고, 테이블은 항상 양방향 관계이므로 단방향 관계가 존재하지 않습니다.</strong> Foreign key와  Join을 통해 양쪽 테이블을 참조할 수 있기 때문입니다.</li>\n<li>다중성: [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)] 관계가 있습니다. 여러 회원이 하나의 팀에 속하므로 다대일 관계이고, 팀은 여러 회원이 소속될 수 있으므로 일대다 관계입니다.</li>\n<li>연관관계의 주인: 객체는 단방향 참조 두 개를 통해 양방향 관계를 만듭니다. 따라서, 연관관계의 주인을 정하고 이를 통해서 연관관계를 관리해야 합니다. ( 추후 설명 )</li>\n</ul>\n<p><strong>RDBMS의 외래 키</strong></p>\n<p>RDBMS에서는 외래 키는 다른 테이블의 Primary Key를 참조하는 컬럼을 말합니다. 여기에 RDBMS에서 제공하는 외래 키 제약조건(Foreign Key Constraint) DDL을 선언해주면 , <strong>참조 무결성을 보장합니다.</strong></p>\n<p>참조 무결성은 보통 삭제동작에서 검증하며, 부모 레코드가 삭제되어 고아 레코드가 되는것을 방지하고,</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088579-d6d0d2ee-1508-4fee-8f78-6179a0462961.png\" alt=\"1\"></p>\n<p>먼저 팀과 멤버가 갖는 <strong>객체, 테이블</strong> 각각에서의 연관관계를 확인하며 연관관계가 갖는 특성을 살펴보겠습니다.</p>\n<ul>\n<li>\n<p>객체에서의 연관관계</p>\n<ul>\n<li>Member.team필드로 참조를 통한 연관관계를 갖습니다.</li>\n<li>이는 <strong>단방향 관계</strong>입니다. member.getTeam()을 통해 팀을 알 수 있지만, team.getMembers()를 통해 멤버 정보를 알 수 없기 때문입니다.</li>\n</ul>\n</li>\n<li>\n<p>테이블에서의 연관관계</p>\n<ul>\n<li>TEAM_ID라는 외래 키를 통해 연관관계를 맺습니다.</li>\n<li>TEAM_ID를 통해 Member를 기준으로 Join할 수도 있고, Team을 기준으로 Join할수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>객체와 테이블 연관관계의 가장 큰 차이점: 객체는 [member → team], [team → member] 로 참조를 두 개 만들어도, 양방향 관계가 아니다!</p>\n<ul>\n<li>만약 두 방향의 참조가 모두 있다고 가정해보자.  team에 member들이 소속되어있고, member도 team 필드를 가지고있다.</li>\n<li>만약 멤버가 팀을 옮겨서 member.setTeam(anotherTeam); 으로 팀을 옮겼다고 해도, <strong>team 객체에는 옮긴 멤버의 참조가 남아있다.</strong>  단방향 관계 두 개를 따로 관리해야하는 것이다. (연관관계의 주인, mappedby가 필요한 이유)</li>\n<li>하지만 테이블은 Foreign Key를 통해 Join하므로, 멤버의 TEAM_ID필드가 변경된 경우, Team테이블에서도 Join을 통해 멤버를 조회했을 때 정상적으로 확인된다(옮긴 멤버가 조회되지 않는다)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jpa에서의-객체-매핑\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C%EC%9D%98-%EA%B0%9D%EC%B2%B4-%EB%A7%A4%ED%95%91\" aria-label=\"jpa에서의 객체 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서의 객체 매핑</h3>\n<p>Member와 Team엔티티가 연관관계를 맺는 예시입니다. 아래에서는 해당 엔티티를 통해 연관관계 매핑을 설명합니다.</p>\n<p>Member 엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>@ManyToOne: 다대일관계라는 정보를 갖는 매핑 애너테이션입니다. 매핑 시 <strong>연관관계의 주인 엔티티에</strong> 필수적으로 사용해야합니다. 양방향의 경우, 연관관계를 갖는 각 필드에 알맞는 애너테이션을 추가합니다.</li>\n<li>@JoinColumn: 외래키를 name속성의 컬럼에 매핑합니다. 생략 가능하며, 생략 시 [필드이름  + 연관 엔티티 식별자 이름] 으로 기본값을 갖습니다. (따라서 위의 경우는 “team_id” 컬럼!)</li>\n</ul>\n<h3 id=\"연관관계-저장\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%80%EC%9E%A5\" aria-label=\"연관관계 저장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계 저장</h3>\n<p>엔티티를 저장할 때는, 연관관계 엔티티를 저장하려 하는 경우, <strong>연관 엔티티 역시 영속상태여야 한다.</strong></p>\n<blockquote>\n<p>이것을 보고 궁금해서 직접 실험해봤는데, 영속하지 않은 상태에서 setTeam한 후, 영속시켜도 정상적으로 동작하는것을 확인했다.  내부적으로 어떤 차이가 있는지는 확인이 필요하다.</p>\n</blockquote>\n<h3 id=\"조회\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%ED%9A%8C\" aria-label=\"조회 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조회</h3>\n<ul>\n<li>객체 그래프 탐색을 통한 조회(프록시를 이용)\n<ul>\n<li>객체지향적인 방법!</li>\n</ul>\n</li>\n<li>객체지향 쿼리 사용(JPQL: SQL 방언으로 변환)\n<ul>\n<li>파라미터를 쿼리에 바인딩하는 전통적 방법과 유사하다.</li>\n<li>연관 엔티티는 Join문을 통해 조회한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"수정\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A0%95\" aria-label=\"수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수정</h3>\n<p><strong>연관 엔티티 수정</strong>은 특별한 방법 없이 엔티티를 수정하면 플러시 시점에 변경감지가 작동한다.</p>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<p>연관 엔티티를 제거할 때는, <strong>연관관계의 주인이 먼저 삭제될 수 없다(외래 키 제약조건) 이 경우, 데이터베이스에서 참조 무결성 오류가 발생한다.</strong></p>\n<p>따라서, 외래키를 가지고있는 부모 엔티티의 연관관계를 삭제하거나, 자식 엔티티를 삭제해 연관관계를 지운 후 부모 엔티티를 삭제할 수 있다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  테이블이 양방향 참조를 할 수 있는 이유는 무엇인가요? (객체와 참조 방향성 측면에서 어떤 차이가 있나요?)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속되지 않은 엔티티를 영속상태의 엔티티에 연관객체로 지정할 수 있나요?\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  비영속상태의 team와 영속상태의 member에서, member.setTeam(team)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속상태의 team와 비영속상태의 member에서, member.setTeam(team) 후 member 영속</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16%5D(https://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16)\">MS learn - 외래 키 제약조건</a></p>","id":"228d870b-db70-59ed-ba74-50e933c33e29","fields":{"slug":"jpa-연관관계-매핑-기초"},"frontmatter":{"date":"2023-01-17","title":"JPA 연관관계 매핑 기초","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":2},"next":{"excerpt":"gRPC 개요 gRPC 소개, Pros & Cons MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다. [+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다. [+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다. Binary framing layer…","html":"<h1 id=\"grpc-개요\" style=\"position:relative;\"><a href=\"#grpc-%EA%B0%9C%EC%9A%94\" aria-label=\"grpc 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 개요</h1>\n<h2 id=\"grpc-소개-pros--cons\" style=\"position:relative;\"><a href=\"#grpc-%EC%86%8C%EA%B0%9C-pros--cons\" aria-label=\"grpc 소개 pros  cons permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 소개, Pros &#x26; Cons</h2>\n<p>MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다.</p>\n<ul>\n<li>[+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다.</li>\n<li>[+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다.\n<ul>\n<li><strong>Binary framing layer</strong>: 데이터를 <strong>바이너리로 이뤄진 프레임으로 전달, 송/수신 레이어에서 다시 재조립</strong>하는 기능을 제공하는 HTTP2에서 도입된 계층</li>\n<li><strong>Multiflexing</strong>지원: Binary framing을 통해 가능해짐. 여러 스트림에서 양방향으로 frame을 통신. <strong>비동기, 양방향 데이터 통신</strong></li>\n<li>이외에도 서버 푸시, 스트림 우선순위 등의 특징과 함께 성능이 대폭 개선됨.</li>\n</ul>\n</li>\n<li>[-] 데이터 스키마 수정 시 서버 및 클라이언트 코드를 모두 변경해야합니다.</li>\n<li>[-] human readable하지 않습니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021105-c50f8ef0-6537-4060-98dc-f42dd517319c.png\" alt=\"1\">\n[그림] - Soap, REST, gRPC의 기본 데이터 전송 포멧의 장단점 비교</p>\n<h2 id=\"간단하게-요약해보는-grpc-매커니즘\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9A%94%EC%95%BD%ED%95%B4%EB%B3%B4%EB%8A%94-grpc-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"간단하게 요약해보는 grpc 매커니즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 요약해보는 gRPC 매커니즘</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021110-d92e6249-993d-4055-a541-de3e9bdf957d.png\" alt=\"2\"></p>\n<ul>\n<li>서버는 클라이언트 호출을 핸들링하고, 클라이언트는 서버와 같은 메서드를 실행하는 Stub을 작성한다.</li>\n<li>gRPC는 서로 다른 <strong>다양한 언어</strong>로 작성된 서버/클라이언트 사이에서 통신할 수 있다.</li>\n<li>gRPC는 <strong>서버의 메서드를 로컬 객체인것처럼 호출한다.</strong></li>\n</ul>\n<h2 id=\"protocol-buffer를-통해-동작\" style=\"position:relative;\"><a href=\"#protocol-buffer%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8F%99%EC%9E%91\" aria-label=\"protocol buffer를 통해 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protocol Buffer를 통해 동작</h2>\n<p>Protocol Buffer란, gRPC에서 구조화된 데이터를 직렬화하기 위한 오픈소스 메커니즘입니다. 언어와 플랫폼에 중립적으로 동작합니다. (영향을 받지 않습니다)</p>\n<p>자세한 스펙은 <a href=\"https://protobuf.dev/\">https://protobuf.dev/</a> 를 참고해주세요!</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bool</span> has_ponycopter <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>gRPC는 서버와 클라이언간 이진 바이트 통신을 하기 위해 Protocol Buffer를 기본 전략으로 사용합니다.</p>\n<p>*.proto파일에 데이터 구조를 정의합니다. 직렬화하고싶은 데이터를 위와 같이 key-value필드로 매핑해 *.proto 파일로 작성합니다.</p>\n<h2 id=\"컴파일-및-메시지-인코딩\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%9D%B8%EC%BD%94%EB%94%A9\" aria-label=\"컴파일 및 메시지 인코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일 및 메시지 인코딩</h2>\n<p><strong>protoc</strong>은 프로토콜 버퍼 컴파일러입니다.</p>\n<p>이는 *.proto 파일에서 정의한 내용으로 <strong>특정 언어가 데이터에 접근할 수 있는 클래스파일을 생성</strong>합니다.</p>\n<p>name(), set_name()과 같은 메서드를 통해 <strong>raw bytes에서 메시지로 직렬화하거나 그 반대로 파싱</strong>할 수 있습니다.</p>\n<h2 id=\"동작\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91\" aria-label=\"동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작</h2>\n<ul>\n<li>서버 측에서 서버는 서비스에서 선언한 메서드를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리합니다. gRPC 인프라는 들어오는 요청을 디코딩하고 서비스 메서드를 실행하며 서비스 응답을 인코딩합니다.</li>\n<li>클라이언트에는 메시지를 서버와 동일한 방식으로 바라보는 <strong>stub</strong>이라는 객체를 통해 메시지와 파라미터를 인코딩해 rpc를 수행하고, 서버가 처리한 결과를 디코딩해 처리합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021107-2b48721b-bd09-421a-bd36-72ea21d11cc0.png\" alt=\"3\"></p>\n<blockquote>\n<p>출처 Geeks for geeks</p>\n</blockquote>\n<h2 id=\"grpc-요청-타입\" style=\"position:relative;\"><a href=\"#grpc-%EC%9A%94%EC%B2%AD-%ED%83%80%EC%9E%85\" aria-label=\"grpc 요청 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 요청 타입</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021109-7b7dacd0-f65d-45cc-b5b0-af7188288e7e.png\" alt=\"4\"></p>\n<p>stream을 통해 대량 데이터가 전달될 수도 있습니다. 그래도 gRPC의 프로그래밍 API에서는 대부분 비동기 처리를 지원하므로, stream data 및 단일 요청에 대해서도 Blocking없이 비동기적으로 처리 가능합니다.</p>\n<p><strong>Unary RPC</strong></p>\n<p>클라이언트에서 단일 요청을 보내고, 서버가 단일 응답을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Server Streaming RPC</strong></p>\n<p>클라이언트가 단일 요청을 보내고, 서버가 스트림을 통해 여러개의 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfReplies</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Clinet Streaming RPC</strong></p>\n<p>클라이언트가 스트림을 통해 여러게의 메시지를 보내고, 서버가 단일 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfGreetings</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Bidrectional Streaming RPC</strong></p>\n<p>클라이언트와 서버가 독립적인 스트림을 주고받으며</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">BidiHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h2>\n<ul>\n<li>server와 client의 stub간 동기화가 필요하지 않나?\n<ul>\n<li>→ 그렇다. protocol buffer를 사용하는 경우, 스키마를 공유하기 위해 스키마 정보를 가진 proto파일을 동기화해 컴파일하거나, 컴파일된 protob파일을 동기화해서 사용해야 한다.</li>\n</ul>\n</li>\n<li>stub을 웹 브라우저에 올릴 수 없는 이유?\n<ul>\n<li>→ 기술적으로는 가능하다. but 엄격한 타입 정의를 통해 통신이 이뤄지는데,만약 스키마 변경 시 end-user에게는 전달되지 않아 장애가 발생할 수 있음.</li>\n</ul>\n</li>\n<li>기존 RPC와는 어떤 차이가 있나?\n<ul>\n<li>gRPC의 경우 HTTP2을 통해 통신한다고 가정하고 구현했으므로, protocol buffer를 통해 binary data로 컴파일하고, binary frame으로 통신해 오버헤드가 적다. (기존 RPC에서는 주로 XML같은 text 기반으로 통신했으므로, 비효율적이다)</li>\n</ul>\n</li>\n<li>text기반 통신이 binary기반 통신에 비해 비효율적인 이유는 무엇인가?\n<ul>\n<li>문자를 제외한 number, boolean을 표현할 때, 사용하는 데이터 공간이 더 크고, 이는 통신 속도에도 영향을 미친다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"keyword\" style=\"position:relative;\"><a href=\"#keyword\" aria-label=\"keyword permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>keyword</h2>\n<p>gRPC, Protocol Buffer, Multiflex, Data access object, Binary framing, Async</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://grpc.io/docs/what-is-grpc/introduction/\">https://grpc.io/docs/what-is-grpc/introduction/</a></p>\n<p><a href=\"https://web.dev/performance-http2/\">https://web.dev/performance-http2/</a> - (Refer:HTTP2 spec, binary framing, multiflexing)</p>\n<p><a href=\"https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0\">https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0</a> (refer: pros&#x26;cons of gRPC)</p>\n<p><a href=\"https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/\">https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/</a></p>\n<p><a href=\"https://codingffler.tistory.com/28\">https://codingffler.tistory.com/28</a></p>","id":"b1635c4c-bdab-51e6-94d5-c0de80c48403","fields":{"slug":"g-rpc의-동작원리와-기본-개념"},"frontmatter":{"date":"2023-01-23","title":"gRPC의 동작원리와 기본 개념","category":"tech","tags":["gRPC","gRPC 스터디"],"banner":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}