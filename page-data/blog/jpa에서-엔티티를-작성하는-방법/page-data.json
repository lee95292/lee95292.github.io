{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/jpa에서-엔티티를-작성하는-방법/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"jpa에서-엔티티를-작성하는-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa에서 엔티티를 작성하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서 엔티티를 작성하는 방법</h1>\n<p>JPA에서 **엔티티(Entity)**는 관계형 데이터베이스의 테이블과 대응하며, JPA가 관리하는 클래스를 말합니다.</p>\n<p>이는 Java 클래스로 선언하며, 보통 domain 패키지에 포함되고, 아래와 같이 구성됩니다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"기본-엔티티-매핑-방법-entity\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95-entity\" aria-label=\"기본 엔티티 매핑 방법 entity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 엔티티 매핑 방법 @Entity</h2>\n<p>JPA에서 테이블과 매핑할 클래스는 @Entity 애너테이션을 필수로 붙여야 합니다. @Entity 적용 시에는, 클래스가 아래 주의사항을 따라야 합니다</p>\n<ul>\n<li>기본생성자 필수</li>\n<li>final, enum, interface, inner 클래스에는 사용 불가</li>\n<li>테이블에 저장할 필드는 final 키워드 사용 불가</li>\n</ul>\n<blockquote>\n<p>JPA는 자바 리플렉션(Java Reflection API)을 통해 엔티티 정보를 받는데, 이 때 생성자 인자 정보를 가져올 수 없으므로 기본 생성자는 필수적으로 필요합니다. 몇몇 JPA구현체(하이버네이트같은)에서는 바이트코드 조작(Bytecode Manipulation)을 통해 이런 문제를 회피한다고 합니다.</p>\n</blockquote>\n<blockquote>\n<p>자바는 클래스를 생성하면 기본 생성자를 자동으로 만들지만, 만약 생성자가 추가된다면 기본 생성자가 사라지므로 주의해야 합니다. (대부분의 IDE에서 잡아주긴 하지만..)</p>\n</blockquote>\n<p><strong>속성</strong></p>\n<ul>\n<li>name: 엔티티 이름 지정, 기본값 - 클래스명</li>\n</ul>\n<h2 id=\"매핑할-테이블을-지정하는-table\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%ED%95%91%ED%95%A0-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-table\" aria-label=\"매핑할 테이블을 지정하는 table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매핑할 테이블을 지정하는 @Table</h2>\n<p>@Table은 엔티티와 매핑할 데이터베이스 테이블을 지정합니다. 생략 시, 엔티티 이름을 테이블 이름으로 사용합니다.</p>\n<ul>\n<li>name속성: 매핑할 테이블 이름, 기본값 - 엔티티 이름</li>\n<li>catalog: catalog 기능이 있는 데이터베이스에서 catalog 매핑</li>\n<li>schema - schema기능이 있는 데이터베이스에서 schema를 매핑한다</li>\n<li>uniqueConstraints - DDL 생성 시, 유니크 제약조건을 만듭니다.</li>\n</ul>\n<blockquote>\n<p>catalog 기능: 데이터베이스의 인덱스, 뷰테이블, 사용자정보 등 메타데이터를 저장하는 객체</p>\n</blockquote>\n<h2 id=\"엔티티-내-필드-매핑-방법\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%82%B4-%ED%95%84%EB%93%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"엔티티 내 필드 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 내 필드 매핑 방법</h2>\n<p>MySQL,MsSQL등 다양한 RDBMS에는 데이터 타입이 존재합니다. JPA역시 Java의 데이터타입을 RDBMS와 매핑하기 위한 방법들이 존재합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"가장-많이-사용되는-column\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%B4-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-column\" aria-label=\"가장 많이 사용되는 column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가장 많이 사용되는 @Column</h3>\n<p>데이터베이스 테이블과 필드를 매핑하기 위해 사용합니다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li><strong>name</strong>: 필드와 매핑할 테이블 컬럼 이름, 기본값 - 필드명</li>\n<li><strong>nullable</strong>(DDL) : false로 지정 시 NOT NULL 제약조건 추가. 기본값 true</li>\n<li><strong>unique</strong>(DDL) : true로 지정 시 하나의 칼럼에 대해 유니크 제약조건. 기본값 false</li>\n<li><strong>columnDefinition</strong>: 데이터베이스 컬럼정보를 직접 입력</li>\n<li><strong>length</strong>: String 타입의 필드의 경우, 최대 길이 제약조건. 기본값 255</li>\n<li><strong>precision</strong>, <strong>scale:</strong> precision의 경우 소수점 제외 전체자리수, scale은 소수 자리수</li>\n<li>i<strong>nsertable</strong>, <strong>updatable</strong>: 저장 / 수정하고싶지 않을 때 false로 지정, 기본값 true</li>\n<li><strong>table</strong>: 하나의 엔티티를 두 개의 테이블에서 사용하려고 할 때 사용</li>\n</ul>\n<blockquote>\n<p>필드에 @Column을 사용하지 않으면, 모든 속성이 기본값으로 들어가게 된다.</p>\n</blockquote>\n<blockquote>\n<p>Java Primitive type은 Null이 들어올 수 없으므로, DDL 생성 시 nullable=true로 설정됨</p>\n</blockquote>\n<blockquote>\n<p>Wrapper Type을 사용하거나  nullable을 false로 지정해야 한다.</p>\n</blockquote>\n<blockquote>\n<p>@Column(<strong>columnDefinition</strong>=”varchar(100)”) 과 같이, 방언정보를 활용해 선언한다</p>\n</blockquote>\n<h3 id=\"날짜-필드를-매핑하는-temporal\" style=\"position:relative;\"><a href=\"#%EB%82%A0%EC%A7%9C-%ED%95%84%EB%93%9C%EB%A5%BC-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-temporal\" aria-label=\"날짜 필드를 매핑하는 temporal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>날짜 필드를 매핑하는 @Temporal</h3>\n<p>java의 날짜 타입인 java.util.Date, java.util.Calendar를 매핑한다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 시간포맷 지정, 기본값 없음(필수지정)\n<ul>\n<li>TemporalType.DATE: “날짜(<strong>date</strong>)”에 매핑 - 2023-01-01</li>\n<li>TemporalType.TIME: “시간(<strong>time</strong>)”에 매핑 - 12:03:21</li>\n<li>TemporalType.TIMESTAMP: “날짜 및 시간(<strong>timestamp</strong>)에 매핑” - 2023-01-01 12:03:21</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Java의 Date에는 날짜,시간이 모두 있지만, RDBMS는 date, time, timestamp로 나누어져있는 경우가 많아 @Temporal을 명시한 경우 value 속성을 필수로 지정해야한다.</p>\n</blockquote>\n<blockquote>\n<p>@Temporal을 생략하면, DB의 timestamp 타입으로 매핑된다.</p>\n</blockquote>\n<h3 id=\"enum-타입을-매핑하는-enumerated\" style=\"position:relative;\"><a href=\"#enum-%ED%83%80%EC%9E%85%EC%9D%84-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-enumerated\" aria-label=\"enum 타입을 매핑하는 enumerated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>enum 타입을 매핑하는 @Enumerated</h3>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 저장할 값 지정\n<ul>\n<li>(기본)EnumType.ORDINAL: enum 순서를 데이터베이스에 저장</li>\n<li>EnumType.STRING: enum 이름을 데이터베이스에 저장</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>EnumType.ORDINAL로 지정할 경우, 저장되는 크기가 작다는 장점이 있지만, 순서가 바뀌거나 사이에 새로운 내용이 추가되었을 때, 데이터베이스의 기존 데이터와 일치하지 않는다는 문제가 있다. 따라서, EnumType.STRING을 권장한다.</p>\n</blockquote>\n<h3 id=\"길이제한-없는-문자타입-lob\" style=\"position:relative;\"><a href=\"#%EA%B8%B8%EC%9D%B4%EC%A0%9C%ED%95%9C-%EC%97%86%EB%8A%94-%EB%AC%B8%EC%9E%90%ED%83%80%EC%9E%85-lob\" aria-label=\"길이제한 없는 문자타입 lob permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>길이제한 없는 문자타입 @Lob</h3>\n<p>데이터베이스의 CLOB, BLOB 타입과 매핑됩니다. 필드 타입이 문자면 CLOB, 나머지는 BLOB로 매핑됩니다.</p>\n<p>Example)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자 필드이므로 CLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> lobString<span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자필드가 아니므로 BLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> lobByte<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<blockquote>\n<p>CLOB: Character Large Object (대형 문자 객체) , BLOB: Binary Large Object(대형 이진 객체)로, 최대 4GB의 대형 문자/이진 객체를  데이터베이스 시스템 밖의 파일로 저장하는 타입입니다.</p>\n</blockquote>\n<h3 id=\"무시하고-매핑하지-않는-transient\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EC%8B%9C%ED%95%98%EA%B3%A0-%EB%A7%A4%ED%95%91%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-transient\" aria-label=\"무시하고 매핑하지 않는 transient permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무시하고 매핑하지 않는 @Transient</h3>\n<p>@Transient가 지정된 필드는 데이터베이스에 저장하지 않고, 따라서 조회하지도 않습니다.</p>\n<h3 id=\"jpa의-접근방식을-지정하는-access\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%A0%91%EA%B7%BC%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-access\" aria-label=\"jpa의 접근방식을 지정하는 access permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 접근방식을 지정하는 @Access</h3>\n<p>JPA가 엔티티 데이터에 접근하는 방식을 지정합니다.</p>\n<ul>\n<li>필드접근: AccessType.FIELD - 필드에 직접 접근. private여도 가능합니다.</li>\n<li>프로퍼티접근: AccessType.Property - getter를 통해 접근합니다.</li>\n</ul>\n<blockquote>\n<p>@Id 의 위치에 따라, @id가 프로퍼티(getter)에 있으면, 자동으로 AccessType.PROPERTY에 지정, 필드에 있으면 AccessType.FIELD에 지정됩니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 필드통한 접근</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> <span class=\"token class-name\">Id</span>\n\n<span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 프로퍼티 통한 접근 </span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"아까-봤던-엔티티-다시보기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B9%8C-%EB%B4%A4%EB%8D%98-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0\" aria-label=\"아까 봤던 엔티티 다시보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아까 봤던 엔티티 다시보기</h3>\n<p>내용들을 공부하기 전에 확인했던 엔티티입니다. 아래 엔티티를 확인하면, 필드에 선언된 애너테이션의 의미와 역할, 제한사항, 컬럼 등에 대해 이해할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"데이터베이스-스키마-자동생성\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99%EC%83%9D%EC%84%B1\" aria-label=\"데이터베이스 스키마 자동생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 스키마 자동생성</h2>\n<p>JPA는 위처럼 엔티티를 통해 데이터베이스 테이블이 어떻게 구성되는지 알 수 있습니다. 이를 통해 데이터베이스 스키마를 DDL(Data Definition Language)로 자동 생성해주는 기능을 갖습니다.</p>\n<p>(show-sql은 실행되는 쿼리를 콘솔에 출력해줍니다.)</p>\n<p>application.properties</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">spring.jpa.hibernate.ddl-auto: create\nspring.jpa.show-sql: true</code></pre></div>\n<p>application.yaml</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">jpa</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">show-sql</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\t\t<span class=\"token key atrule\">hibernate</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token key atrule\">ddl-auto</span><span class=\"token punctuation\">:</span> create\n</code></pre></div>\n<h3 id=\"ddl-auto-옵션\" style=\"position:relative;\"><a href=\"#ddl-auto-%EC%98%B5%EC%85%98\" aria-label=\"ddl auto 옵션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ddl-auto 옵션</h3>\n<table>\n<thead>\n<tr>\n<th>옵션</th>\n<th>환경</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>개발 초기</td>\n<td>기존 테이블을 삭제 후, 새로 생성 (DROP + CREATE)</td>\n</tr>\n<tr>\n<td>create-drop</td>\n<td>개발 초기</td>\n<td>애플리케이션을 시작할 때 CREATE, 종료할 때 DROP (CREATE + DROP)</td>\n</tr>\n<tr>\n<td>update</td>\n<td>테스트서버</td>\n<td>데이터베이스 테이블과 엔티티의 변경사항을 비교해 변경사항만 수정</td>\n</tr>\n<tr>\n<td>validate</td>\n<td>테스트서버 or</td>\n<td></td>\n</tr>\n<tr>\n<td>스테이징/운영서버</td>\n<td>데이터베이스 테이블과 엔티티 매핑정보가 차이가 있을 경우, 경고를 남기고 애플리케이션을 실행하지 않음.</td>\n<td></td>\n</tr>\n<tr>\n<td>none</td>\n<td>스테이징/운영서버</td>\n<td>자동생성기능을 사용하지 않음. ddl-auto 옵션을 제거하거나 유효하지 않은 옵션을 준것과 같음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>ddl-auto 옵션은 운영환경에서 사용할만큼 완벽하지 않다고 한다. 그렇기에 학습이나 참고용으로만 사용하는것이 좋다.</p>\n</blockquote>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  데이터베이스에 2GB이상의 데이터를 저장하기 위해 JPA에서 어떤 애너테이션을 사용해야하는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  ddl-auto 옵션의 validate는 무슨 역할을 하는가?</li>\n</ul>\n<p><strong>정답</strong></p>\n<ol>\n<li>@Lob 애너테이션을 사용하면 문자열의 경우 CLOB, 이외는 BLOB으로 매핑해줍니다. 다만, Java String의 경우 최대 길이가 2GB이므로, 내용이 절삭되는것에 유의해야 한다.</li>\n<li>데이터베이스 테이블과 엔티티의 매핑이 일치하는지 확인하고, 일치하지 않으면 경고와 함께 애플리케이션을 실행하지 않음</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>","fields":{"slug":"jpa에서-엔티티를-작성하는-방법"},"frontmatter":{"title":"JPA에서 엔티티를 작성하는 방법","date":"08.01.2023","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":4}},"pageContext":{"slug":"jpa에서-엔티티를-작성하는-방법","prev":{"excerpt":"JPA의 엔티티매니저와 영속성 관리 JPA의 엔티티매니저가…","html":"<h1 id=\"jpa의-엔티티매니저와-영속성-관리\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%EB%8B%88%EC%A0%80%EC%99%80-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC\" aria-label=\"jpa의 엔티티매니저와 영속성 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 엔티티매니저와 영속성 관리</h1>\n<p>JPA의 엔티티매니저가 1차캐시, 쓰기지연, 영속성 관리 등의 역할을 하기 위해 어떻게 동작하는지 살펴보자</p>\n<h2 id=\"엔티티-매니저-팩토리-엔티티-매니저\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80\" aria-label=\"엔티티 매니저 팩토리 엔티티 매니저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 매니저 팩토리, 엔티티 매니저</h2>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 클래스입니다. 일반적으로 하나의 데이터베이스를 사용하는 애플리케이션은, 하나의 엔티티 매니저 팩토리를 생성하고 이를 통해 엔티티 매니저를 생성합니다.</p>\n<p>엔티티 매니저 팩토리는 생성시 매우 큰 비용을 지불해야 하므로, 애플리케이션당 하나를 사용하면 되고, <strong>Thread-safe</strong>하므로 다른 스레드와 공유해도 괜찮습니다.</p>\n<p>반면 엔티티매니저의 경우, 생성 비용이 거의 들지 않지만 여러 스레드가 동시에 접근할 경우, <strong>동시성 문제</strong>가 발생하므로, 스레드간 공유하면 안됩니다.</p>\n<img width=\"473\" alt=\"JPA_3_1\" src=\"https://user-images.githubusercontent.com/30853787/210956641-10027f43-7206-4d82-96d1-25c6d304035e.png\">\n<p>또한, 엔티티 매니저는 데이터베이스 연결이 필요한 시점까지 커넥션이 없는 상태로 유지하다가, 트랜잭션이 시작되는 등, 데이터베이스 연결이 필요한 시점이 되면 커넥션을 획득합니다.</p>\n<h2 id=\"엔티티의-생명주기\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"엔티티의 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티의 생명주기</h2>\n<p>엔티티는 영속성 컨텍스트라는 엔티티 저장소에 영속되어 관리됩니다.  엔티티는 영속 상태에 따라 4가지의 상태가 있고, 생명주기는 아래와 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956646-f95a5164-e574-4b35-a23b-988c0e0780da.png\" alt=\"JPA_4\"></p>\n<ul>\n<li>비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태\n<ul>\n<li>New를 통해 엔티티를 생성해, 엔티티와 영속성 컨텍스트가 아무 관련이 없는 상태이다.</li>\n</ul>\n</li>\n<li>영속: 엔티티가 영속성 컨텍스트에 의해 관리되는 상태\n<ul>\n<li><strong>em.persiste(member)</strong> 또는, <strong>em.find(Member.class, “memberId”);</strong> 로 SQL을 통해 데이터 조회 시, 영속상태가 된다</li>\n<li>영속된 엔티티는 식별자를 통해 관리된다.</li>\n</ul>\n</li>\n<li>준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태\n<ul>\n<li>em.close()로 영속성 컨텍스트를 닫거나 em.clear()를 호출해 영속성 컨텍스트를 초기화하는 경우, 엔티티들이 준영속 상태가 된다</li>\n<li>**em.detach(member)**같이 특정 엔티티를 준영속시킬수도 있다.</li>\n<li>개발자가 엔티티를 준영속 상태로 만드는 일은 흔치않은 일입니다.</li>\n</ul>\n</li>\n<li>삭제: 삭제된 상태\n<ul>\n<li>em.remove(member); 를 통해 영속성 컨텍스트 및 데이터베이스에서 삭제됩니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"영속성-컨텍스트란\" style=\"position:relative;\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80\" aria-label=\"영속성 컨텍스트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>영속성 컨텍스트란?</h2>\n<p><strong>엔티티를 영구 저장하는 환경</strong>으로, 엔티티 매니저를 통해 엔티티를 저장하거나 조회했을 때, 엔티티 매니저는 엔티니를 영속성 컨텍스트에 보관 및 관리합니다. 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제나 성능 개선을 위해 아래와 같은 특징을 갖습니다.</p>\n<h3 id=\"엔티티-조회-시-1차캐시-제공\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%A1%B0%ED%9A%8C-%EC%8B%9C-1%EC%B0%A8%EC%BA%90%EC%8B%9C-%EC%A0%9C%EA%B3%B5\" aria-label=\"엔티티 조회 시 1차캐시 제공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 조회 시 1차캐시 제공</h3>\n<p>영속성 컨텍스트 내부에는 Map 자료구조가 존재합니다. @Id로 매핑한 값을 Key로 사용하고, 엔티티 인스턴스를 Value로 합니다.</p>\n<p>만약 멤버 인스턴스가 생성되어 <strong>영속성 컨텍스트에 영속된 상태</strong>라면, 해당 엔티티에 대해 식별자로 조회했을 때 동일성이 보장되는 멤버 인스턴스를 <strong>데이터베이스 조회 없이</strong> 조회해주는 <strong>캐싱 기능</strong>을 제공합니다. 이를 <strong>1차캐시</strong>라고 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//동일성 보장, Insataces has same identity 출력</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>emMember <span class=\"token operator\">==</span> member<span class=\"token punctuation\">)</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Insataces has same identity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>1차캐시에 엔티티가 저장되어있는경우의 workflow입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956653-ad82cf2d-7e52-48f9-b3f0-785f73a587c5.png\" alt=\"JPABook_97 drawio\"></p>\n<p>위의 경우와 달리, 멤버 <strong>엔티티가 1차캐시에 등록되어있지 않다면</strong>, SQL문으로 데이터를 조회하고, 엔티티를 생성한 뒤 1차캐시에 저장해 이를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//데이터베이스에 존재하지만, 영속상태가 아닌 엔티티 조회 </span>\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"member2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956650-60b80152-5734-4d92-a11a-3028a9178bf8.png\" alt=\"JPABook_97 drawio_(1)\"></p>\n<p>따라서 영속성 컨텍스트는 1차캐시 기능을 통해 총 두 가지의 이점을 얻습니다.</p>\n<ul>\n<li>엔티티의 동일성 보장</li>\n<li>캐싱을 통한 성능 향상</li>\n</ul>\n<h3 id=\"트랜잭션을-지원하는-쓰기지연-transactional-write-behind\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%93%B0%EA%B8%B0%EC%A7%80%EC%97%B0-transactional-write-behind\" aria-label=\"트랜잭션을 지원하는 쓰기지연 transactional write behind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션을 지원하는 쓰기지연 (Transactional write-behind)</h3>\n<p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 전달하지 않고, 쓰기지연 저장소에 쌓아놓고, 트랜잭션이 커밋되는 순간 데이터베이스에 쿼리를 전달합니다. 이것을 트랜잭션을 지원하는 쓰기지연이라고 합니다.</p>\n<p>(1) Commit 전까지 영속성 컨텍스트에 쿼리 저장, 1차캐시에 엔티티 저장</p>\n<p>(2) 트랜잭션 커밋 시, DB에 flush.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956659-2e9b80db-b21d-4ed8-8694-3561dfbff315.png\" alt=\"JPABook-100 drawio\"></p>\n<h3 id=\"엔티티-수정\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%88%98%EC%A0%95\" aria-label=\"엔티티 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 수정</h3>\n<p>SQL을 사용한 엔티티 수정 작업은 많은 양의 쿼리 반복과 SQL의존성을 갖게됩니다.</p>\n<p>JPA는 역시 트랜잭션을 지원하는 쓰기지연을 이용해 객체지향적인 방법으로 해결합니다.</p>\n<p>이 때, 스냅샷이라는 새로운 개념이 등장하는데요, <strong>스냅샷</strong>은 엔티티가 영속성 컨텍스트에 <strong>처음 저장될 때의 값</strong>을 기억해놓은 것입니다.  영속성 컨텍스트는 이를 기반으로, 플러시가 호출되었을 때 엔티티와 스냅샷을 비교해 Update 쿼리를 생성하고, 데이터베이스에 전송, 커밋합니다.</p>\n<ul>\n<li>\n<ol>\n<li>flush 호출 시, Entity와 Snapshot 비교해 변경 감지</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>변경된부분이 있다면, 쓰기지연 저장소에 Update Query 추가</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>DB에 Update Query 전달 후 커밋</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956656-6dec4769-15cb-4516-a35b-debf65f1a6c9.png\" alt=\"JPABook-100 drawio_(1)\"></p>\n<p>JPA 변경감지의 특징 : <strong>JPA가 생성하는 Update Query는  기본적으로 엔티티의 모든 필드를 업데이트합니다.</strong></p>\n<p>왜 이렇게 하는걸까요? 책에서는 <strong>재사용 측면</strong>에서 두 가지 정도의 장점을 설명합니다.</p>\n<ul>\n<li>수정쿼리가 항상 같아, 이를 애플리케이션 로딩 시점에 미리 로드해서 재사용할 수 있음</li>\n<li>데이터베이스는 동일한 쿼리를 받았을 때, 이전에 파싱된 쿼리를 재사용할 수 있음</li>\n</ul>\n<p>수정된 필드만을 이용해 쿼리를 전송하고 싶다면, @DynamicUpdate어노테이션을 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Mklee\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\"># Name 필드만 변경할것으로 예상</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> NAME <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">WHERE</span> ID <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#모든 필드를 수정</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> \n\t\tNAME<span class=\"token operator\">=</span>?\n\t\tAGE<span class=\"token operator\">=</span>?\n\t\tADDRESS<span class=\"token operator\">=</span>?\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">WHERE</span> \n\t\tID<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"엔티티-삭제\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%82%AD%EC%A0%9C\" aria-label=\"엔티티 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 삭제</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> memberA <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"memberA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>memberA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>앞선 생성/수정과정과 마찬가지로, 삭제쿼리 역시 쓰기지연 저장소에 추가됩니다.</p>\n<p>영속성 컨텍스트에서 즉시 엔티티가 삭제되고, 삭제쿼리가 플러시되면 데이터베이스에서도 삭제됩니다.</p>\n<h3 id=\"플러시\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9F%AC%EC%8B%9C\" aria-label=\"플러시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플러시</h3>\n<p>플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영합니다.( 동기화 )</p>\n<p><strong>동작과정</strong></p>\n<ul>\n<li>변경감지 동작, 변경된 엔티티에 대해 수정쿼리를 만들어 쓰기지연 저장소에 저장</li>\n<li>쓰기지연 저장소에 쿼리를 데이터베이스에 전달( 여기는 삽입,수정,삭제 쿼리 포함입니다)</li>\n</ul>\n<p><strong>플러시를 일으키는 방법</strong></p>\n<ul>\n<li>직접호출: em.flush()를 통해 직접 플러시를 호출하는 방법 ( 실무에서 잘 쓰지 않습니다)</li>\n<li>트랜잭션 커밋: 플러시 없이 트랜잭션만 커밋하면, 데이터베이스에 변경한 데이터가 반영되지 않고, 서버가 종료되는 등의 상황에서 Durability가 보장되지 않는다.</li>\n<li>JPQL 사용: JPQL은, 뒤에서 다루지만 조회쿼리 시 1차캐시를 사용하지 않고 SQL문으로 변환합니다. 이 경우 1차캐시에 저장된 내용이 누락되므로, flush 이후 JPQL이 수행되어야 합니다.</li>\n</ul>\n<p><strong>플러시 모드 옵션</strong></p>\n<ul>\n<li>FlushModeType.AUTO: 커밋이나 쿼리 실행 시 플러시</li>\n<li>FlushModeType.COMMIT: 커밋 실행시 플러시, 최적화를 위한 옵션입니다.</li>\n</ul>\n<h2 id=\"준영속-상태\" style=\"position:relative;\"><a href=\"#%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C\" aria-label=\"준영속 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>준영속 상태</h2>\n<p>엔티티가 준영속”detached” 상태라는 것은, 영속성 컨텍스트에서 분리되어 관리대상에서 벗어남을 의미하며, 앞서 설명한 영속성 컨텍스트의 기능들을 활용할 수 없음을 의미합니다.</p>\n<p>영속성 컨텍스트에서 분리되는 방법: 준영속 엔티티를 만드는 방법</p>\n<ul>\n<li>em.detach(entity);  → 특정 엔티티만을 준영속상태로 만듦</li>\n<li>em.clear(); → 영속성 컨텍스트를 비워, 내부에 있던 엔티티를 준영속상태로 만듦.</li>\n<li>em.close(); → 엔티티매니저를 닫힘.</li>\n</ul>\n<p>준영속과 비영속은 매우 가까운 상태입니다. 하지만, 준영속 상태는 이미 영속된적이 있는 엔티티로, 식별자 값이 존재합니다.</p>\n<p>또한 준영속 → 영속상태로 가는 동작을 merge라고 합니다. 책에서는 길게 설명하지만, 짧게 요약하자면,</p>\n<p>“merge 와 persist는 매우 비슷하지만, merge는 식별자 값을 제외한 값을 영속성 컨텍스트에 복사 후 리턴한다” 입니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저와 엔티티 매니저 팩토리란? 각각의 역할, 특징은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2. 1차캐시의 장점은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  3. 쓰기지연은 무엇이고, 어떤 장점이 있는가?</li>\n</ul>\n<h3 id=\"챕터에-나오지-않지만-알아야하는-부분\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EB%82%98%EC%98%A4%EC%A7%80-%EC%95%8A%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84\" aria-label=\"챕터에 나오지 않지만 알아야하는 부분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 나오지 않지만 알아야하는 부분</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저가 커넥션을 맺는 시점과 끊는 시점</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2.준영속 상태가 되면, 데이터베이스에는 남아있는가?</li>\n</ul>\n<p><strong>복습질문 정답</strong></p>\n<ol>\n<li>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 객체, DB 커넥션 풀을 관리하고,<br>\nJPA의 <strong>엔티티메니저</strong>는 엔티티를 저장/수정/삭제/조회 하는 등, 엔티티와 관련된 많은 일을 처리하는 엔티티 관리자입니다(이름과 같은 역할).<br>\n또한 <strong>영속성 컨텍스트에 엔티티를 저장하면서 캐싱/변경감지/쓰기지연 등, CRUD의 성능을 개선합니다.</strong></p>\n</li>\n<li>\n<p>성능상의 이점과 엔티티 간 동일성을 보장해주는 장점이 있습니다.</p>\n</li>\n<li>\n<p>트랜잭션을 커밋할때까지 엔티티를 1차캐시에 저장해놓고, 쓰기지연 SQL저장소에 쓰기 SQL을 저장해놓는다. 이후 트랜잭션이 커밋되면 flush작업과 함께, 쓰기 SQL을 데이터베이스에 전달하는것을 쓰기지연이라고 하고,</p>\n</li>\n</ol>\n<p><strong>더 알아보기 정답</strong></p>\n<ol>\n<li>엔티티매니저는 데이터가 변경되는 시점에 트랜잭션을 시작합니다.  앤티티메니저의 메서드를 호출 할 때, 트랜잭션 상태가 아니면 <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/TransactionRequiredException.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TransactionRequiredException</a>을 발생시킵니다.</li>\n<li>데이터베이스에는 남아있지만, 1차캐시에는 존재하지 않는 상태가 됩니다.</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n<li><a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle Java Docs(javax.persistence)</a></li>\n</ul>","id":"776bb867-4d09-5c57-9ae5-d6b293e1271d","fields":{"slug":"jpa의-엔티티-매니저와-영속성-관리"},"frontmatter":{"date":"2023-01-03","title":"JPA의 엔티티 매니저와 영속성 관리 ","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":4},"next":{"excerpt":"JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다. 데이터베이스에는 유일성 최소성을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.…","html":"<p>JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다.</p>\n<p>데이터베이스에는 <strong>유일성</strong> <strong>최소성</strong>을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088482-446952cd-6dc2-42a8-b0dd-10e0a9e20137.png\" alt=\"1\"></p>\n<p><strong>유일성</strong>이란, 여러 레코드들 중, 하나의 레코드를 특정지을 수 있는 키의 특성입니다.</p>\n<p>예를들어 이름,생일과 같은 특성은 레코드를 하나로 특정지을 수 없지만, [**학교 , 학번]**의 조합이나 [**주민등록번호]**와 같은 특성은 레코드를 유일하게 특정지을 수 있으므로 유일성을 만적하는 특성입니다.</p>\n<p><strong>최소성</strong>이란, 레코드를 유일하게 식별하는데 꼭 필요한 최소한의 특성만 선택되어야한다는 키의 특성입니다.</p>\n<p>예를 들어, <strong>[이름, 나이, 주민등록번호]</strong> 의 속성 조합으로 유일성을 만족하지만, 이름과 나이 없이 주민등록번호만으로 레코드를 유일하게 식별할 수 있으므로, <strong>최소성을 만족하지 못하는 키</strong>이고, <strong>[주민등록번호]</strong> 로 구성된 키는 <strong>최소성을 만족한다</strong>고 할 수 있습니다.</p>\n<h2 id=\"jpa의-기본-키-매핑-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa의 기본 키 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 기본 키 매핑 방법</h2>\n<p>데이터베이스 시스템에서는 보통 레코드의 기본 키를 설정하기 위한 디폴트 설정이 있습니다. 앞서 소개한 주민등록번호나 학교+학번은 사실 <strong>비즈니스 상 변경</strong>될 수도 있는 값이고, <strong>인덱스를 통해</strong> <strong>효율적으로 탐색</strong>하기에는 부적절한 키입니다.</p>\n<p>그렇기때문에 데이터베이스 시스템에서는 비즈니스 로직과 관계 없는 고유한 값을 만들어 기본 키로 채택하는데요,   이번 글은 JPA에서 엔티티와 데이터베이스 테이블 간 “기본 키”를 어떻게 생성하고 매핑하는지 알아보겠습니다.</p>\n<p>참고로 좋은 데이터베이스 기본 키를 선택하는 기준은 아래와 같습니다.</p>\n<ul>\n<li>Null값을 허용하지 않음</li>\n<li>변하지 않음</li>\n<li>유일함</li>\n</ul>\n<p>JPA로 엔티티를 한번 이상 만들어봤다면, 기본적으로 아래 구조를 띄는것을 알 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 구성하면, Member테이블의 Key인 Id필드는 언제 지정될까요? 영속성 관리에서 배운것처럼, 엔티티는 바로 데이터베이스에 저장되지 않고 1차캐시에 저장됩니다.</p>\n<p><em><strong>고치기</strong></em></p>\n<p>만약 데이터베이스의 기본 키 생성 전략이 직접할당일 경우에는, 애플리케이션에서 엔티티의 키를 설정할 방법이 없을것입니다.</p>\n<p>JPA에서는 데이터베이스 벤더별로 각기 다른 키 생성 전략과 자바 엔티티를 매핑하기 위해, @Id 컬럼에 여러 옵션들을 제공합니다.</p>\n<h2 id=\"기본-키-생성-전략\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5\" aria-label=\"기본 키 생성 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 키 생성 전략</h2>\n<p>기본키를 어떤 방식으로 생성하느냐에 따라, <strong>개발자가 키를 직접 설정하는</strong> 직접할당 전략, <strong>자동으로 키를 생성하는</strong>  IDENTITY, SEQUENCE, TABLE, AUTO 전략을 살펴봅니다.</p>\n<p>아래의 Java 타입을 선언한 뒤, Id애너테이션을 통해 필드가 기본 키로 매핑되도록 합니다.</p>\n<p>@<strong>Id필드 타입</strong></p>\n<p>Id 애너테이션은 다음과 같은 자바 타입에서만 적용 가능합니다</p>\n<ul>\n<li>Primitive Types</li>\n<li>Wrapper Types</li>\n<li>String</li>\n<li>java.util.Date</li>\n<li>java.sql.Date</li>\n<li>java.math.[bigDecimal, bigInteger]</li>\n</ul>\n<h3 id=\"직접-할당-전략\" style=\"position:relative;\"><a href=\"#%EC%A7%81%EC%A0%91-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5\" aria-label=\"직접 할당 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>직접 할당 전략</h3>\n<p>기본 키 직접 할당 전략은 프로그래머가 <strong>엔티티매니저에 영속되기 전에</strong> 엔티티의 키를 직접 할당하는 방식입니다.</p>\n<p>이 방식에서 식별자 값 없이 영속시키면 PersistenceExeption이 발생합니다.</p>\n<p><strong>설정방법:  Id</strong> 필드에 @Id 애너테이션을 적용하면 기본키를 직접 할당방식으로 테이블이 생성됩니다.</p>\n<h3 id=\"identity-전략\" style=\"position:relative;\"><a href=\"#identity-%EC%A0%84%EB%9E%B5\" aria-label=\"identity 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IDENTITY 전략</h3>\n<p>IDENTITY전략은 기본 키 생성 전략을 데이터베이스에 위임하는 방식입니다.</p>\n<p>보통 AUTO_INCREMENT같은 자동 키 생성방법을 제공하는 MySQL, Postgresql, DB2등에서 사용합니다.</p>\n<p><strong>설정방법: 필드에</strong> GeneratedValue 애너테이션, strategy 옵션을 GenerationType.IDENTITY로 설정</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">IDENTITY</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>em.persist(member) → insert query 날리고 → select query(id 포함된 레코드) → 영속성 컨텍스트에 저장</strong></p>\n<p><strong>주의사항</strong></p>\n<p>영속성 컨텍스트에 저장될때는 필수로 식별자 값이 필요한데, IDENTITY 전략에서는 기본 키를 데이터베이스에서 지정하므로, <strong>식별자를 알 수없다</strong>.</p>\n<p>그러므로 IDENTITY전략을 사용하는 엔티티는 <strong>영속되는 시점에 INSERT쿼리를 데이터베이스에 전달</strong>한다.</p>\n<p>따라서 <strong>IDENTITY전략에서는 트랜잭션을 지원하는 쓰기지연이 동작하지 않는다.</strong></p>\n<p><strong>최적화 방법</strong></p>\n<p>IDENTITY전략에서는 영속 시 INSERT쿼리를 데이터베이스에 전달하고, 식별자를 얻기 위해 추가로 조회작업을 해야해서 총 <strong>2번의 통신이 이뤄진다.</strong></p>\n<p>JDBC3에서 추가된 Statement.getGeneratedKeys()를 사용하면, 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다.</p>\n<h3 id=\"sequence-전략\" style=\"position:relative;\"><a href=\"#sequence-%EC%A0%84%EB%9E%B5\" aria-label=\"sequence 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SEQUENCE 전략</h3>\n<p>데이터베이스에서 시퀀스는 유일한 값을 순서대로 생성하는 데이터베이스 오브젝트입니다. Sequence를 제공하는 Oracle,Postgresql, DB2,H2등에서 사용가능합니다.</p>\n<p>SEQUENCE방법은 이를 통해 기본 키를 생성합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>엔티티에 @SequenceGenerator 등록: 시퀀스 생성기 등록  옵션은 아래와 같습니다.\n<ul>\n<li>name : 엔티티에서 갖는 시퀀스생성기 이름(필수)</li>\n<li>sequenceName : 데이터베이스의 시퀀스 이름</li>\n<li>initialValue : DDL 생성시 처음 시작하는 숫자</li>\n<li>allocationSize:시퀀스 호출 시 증가하는 숫자, 기본값 50 (최적화에 사용)</li>\n<li>catalog, schema: 데이터베이스의  catalog, schema</li>\n</ul>\n</li>\n<li>@GeneratedValue의 strategy 속성을 GenerationType.SEQUENCE로 설정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@SequenceGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>  \n\tsequenceName<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ\"</span><span class=\"token punctuation\">,</span> \n\tinitialValue<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> \n\tallocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span>  \n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy<span class=\"token operator\">=</span><span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SEQUENCE</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>@SequenceGenerator의 옵션이 다양하게 존재하는것을 확인할 수 있다.</p>\n<p><strong>참고사항1. 시퀀스 동작구조</strong></p>\n<p>IDENTITY전략과 마찬가지로 ,데이터베이스에서 식별자 값을 가져와야 하지만 IDENTITY전략이 영속성 컨텍스트에서 Insert 쿼리를 날린 뒤 조회를 한것과는 달리, SEQUENCE 전략에서는 데이터베이스 시퀀스만 조회해 식별자값만 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> emp_seq<span class=\"token punctuation\">.</span>NEXTVAL\n     <span class=\"token punctuation\">,</span> emp_seq<span class=\"token punctuation\">.</span>CURRVAL\n  <span class=\"token keyword\">FROM</span> dual</code></pre></div>\n<p>따라서 <strong>SEQUENCE전략은 트랜잭션을 사용하는 쓰기지연 방식을 지원하지만, 시퀀스를 추가적으로 조회한다</strong>.</p>\n<p><strong>참고사항 2. allocationSize의 기본값이 50이다.</strong></p>\n<p><strong>hibernate.id.new_generator_mappings 설정이 true인 경우, allocationSize</strong>는 <strong>기본적으로 50으로 설정됩니다. 이는 JPA의 시퀀스 접근횟수를 줄이기 위함이고, 아래와 같이 동작합니다.</strong></p>\n<ul>\n<li>JPA에서 데이터베이스 시퀀스에 접근</li>\n<li>시퀀스는 <strong>allocationSize값인 50만큼 시퀀스를 생성</strong></li>\n<li>JPA는 메모리에 1 ~ 50까지의 시퀀스를 메모리에 할당.</li>\n<li>50개까지 엔티티가 생성되어도, 시퀀스를 생성하기 위해 DB에 접근하지 않아도 됨.</li>\n</ul>\n<p>멀티서버 환경에서는 엔티티가 생성된 순서대로 ID가 증가하지는 않지만, Insert성능 측면에서 가장 훌륭함.</p>\n<h3 id=\"table-전략\" style=\"position:relative;\"><a href=\"#table-%EC%A0%84%EB%9E%B5\" aria-label=\"table 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TABLE 전략</h3>\n<p>TABLE전략은 키 생성용 테이블을 만들고, 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략입니다. 또한, 테이블을 사용하므로 모든 데이터베이스에서 적용가능합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>필드에 @GeneratedValue 등록, 아래의 속성 추가\n<ul>\n<li>strategy = GenerationType.Table,</li>\n<li>generator = 시퀀스 생성테이블 이름(TableGenerator의 name속성 값) 등록</li>\n</ul>\n</li>\n<li>엔티티에 @TableGenerator 등록 : 속성들이 많은데, 시퀀스 테이블을 구성하기 위한 이름과 관련된것들이 많습니다. 아래에서 설명합니다.\n<ul>\n<li>name: 식별자 생성기 이름 (필수)</li>\n<li>table:  키 생성 테이블명 (기본값 - hibernate_sequence)</li>\n<li>pkColumnValue:  키로 사용할 이름 [ Default - 엔티티명 ]</li>\n<li>pkColumnName: 시퀀스 컬럼명 [ Default - sequence_name]</li>\n<li>valueColumnName: 시퀀스 값 컬럼명 [ Default - next_val ]</li>\n<li>initalValue: 초기 값 [ Default - 0 ]</li>\n<li>allocationSize; 시퀀스 한번 호출에 증가하는 숫자(최적화용), [ Default  1 or 50: 최적화 설정 적용여부에 따라 ]</li>\n<li>catalog, schema: 데이터베이스 catalog, schema 이름</li>\n<li>uniqueConstraints: 유니크 제약조건</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@TableGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>\n\ttable<span class=\"token operator\">=</span><span class=\"token string\">\"MY_SEQUENCE\"</span><span class=\"token punctuation\">,</span>\n\tpkColumnValue<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ\"</span><span class=\"token punctuation\">,</span> allocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Board</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TABLE</span><span class=\"token punctuation\">,</span>\n\t\tgenerator <span class=\"token operator\">=</span> <span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 등록 하게 되면, 아래와 같이 시퀀스 이름과 시퀀스 값을 컬럼으로 갖는 테이블을 만들어 시퀀스를 관리합니다</p>\n<p>앞서 @TableGenerator의 속성들 중 <del>Column</del> 같은 이름에 사용되는 속성들이 많이 보이는데요, 시퀀스테이블을 구성할 때 사용하는 이름입니다.</p>\n<table>\n<thead>\n<tr>\n<th>sequence_name</th>\n<th>next_val</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BOARD_SEQ</td>\n<td>102</td>\n</tr>\n<tr>\n<td>MEMBER_SEQ</td>\n<td>50</td>\n</tr>\n</tbody>\n</table>\n<p><strong>참고사항: 테이블전략 동작구조</strong></p>\n<p>(시퀀스)테이블의 값을 조회하고, 이 값을 기반으로 Update쿼리를 한번 더 날리기때문에, 시퀀스 전략보다 네트워크 통신을 1회 더 한다는 단점이 있습니다.</p>\n<p>이는 SEQUENCE방법과 같이 allocationSize를 통해 최적화할 수 있습니다.</p>\n<h3 id=\"auto-전략\" style=\"position:relative;\"><a href=\"#auto-%EC%A0%84%EB%9E%B5\" aria-label=\"auto 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AUTO 전략</h3>\n<p>@GeneratedValue.strategy의 기본 설정값인 AUTO전략입니다.</p>\n<p>AUTO 전략은 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE중 하나를 자동으로 선택합니다.</p>\n<ul>\n<li><strong>데이터베이스가 변경되어도 코드를 수정할 필요가 없습니다.</strong></li>\n<li>MySQL은 IDENTITY, Oracle은 SEQUENCE방법 선택합니다.</li>\n</ul>\n<h2 id=\"매우매우-중요한-뽀인트\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%EC%9A%B0%EB%A7%A4%EC%9A%B0-%EC%A4%91%EC%9A%94%ED%95%9C-%EB%BD%80%EC%9D%B8%ED%8A%B8\" aria-label=\"매우매우 중요한 뽀인트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매우매우 중요한 뽀인트</h2>\n<p>JPA에서 <strong>키 생성 전략은 INSERT성능에 중요한 영향을 미친다!!!</strong></p>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  자동 키 생성전략: IDENTITY, SEQUENCE, TABLE 방법에서 영속성 컨텍스트에 식별자를 동기화하기 위해 각각은 어떻게 동작하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  allocationSize 속성은 어떻게 키 생성 전략에서 최적화를 수행하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  AUTO 생성전략은 무엇이고, 어떤 장점이 있나요?</li>\n</ul>\n<h2 id=\"챕터에-없지만-알아볼-내용\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EC%97%86%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EB%B3%BC-%EB%82%B4%EC%9A%A9\" aria-label=\"챕터에 없지만 알아볼 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 없지만 알아볼 내용</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  Table 방식과 Sequence 방식은 근본적으로 어떤 차이점이 있나요? (시퀸스는 테이블과 어떻게 다른가요?)</p>\n</li>\n</ul>\n<h3 id=\"정답\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%8B%B5\" aria-label=\"정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정답</h3>\n<ul>\n<li>각 방법에 대한 답변\n<ul>\n<li>IDENTITY의 경우, 데이터베이스에 키 생성전략을 위임한다. AUTO_INCREMENT같이 자동으로 기본 키를 설정해주는 MYSQL등에서 사용한다. (MySQL AUTO_INCREMENT가 적용되었을 때, id없이 insert 쿼리가 가능하다!). [ 삽입/조회 쿼리 발생, 쓰기지연 불가 ]</li>\n<li>SEQUENCE는 증가하는 값을 생성해내는 객체로, 조회만을 통해 증가하는 값을 할당받아 엔티티의 키로 지정한다. [ 조회쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n<li>TABLE은 키 할당 정보를 관리하는 테이블을 생성해 키를 매핑한다. Sequence와 유사하게 동작합니다. [ 조회/수정쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n</ul>\n</li>\n<li>Table, Sequence방법에서 사용하는 최적화 전략으로, 키를 allocationSize만큼 할당받아 사용. 식별자를 생성하기 위해 N회 쿼리를 날리는것에서 N/allocationSize 만큼만 쿼리를 날리게 됨.</li>\n<li>AUTO방식은 데이터베이스 방언에 맞는 자동 키 생성방식을 설정합니다. 데이터베이스 벤더가 변경되어도 코드가 변경될 필요가 없다는 장점이 있습니다.</li>\n</ul>\n<hr>\n<ul>\n<li>시퀀스는 select 시퀀스네임.nextval from dual 을 통해 다음 값을 조회하고 자동으로 증가합니다. 따라서 테이블 방식과 달리, Update 쿼리를 사용할 필요가 없어 효율적입니다.</li>\n</ul>","id":"b78f1971-39d1-5252-8584-8372d1a2ca74","fields":{"slug":"jpa에서-기본-키-매핑-방법-종류"},"frontmatter":{"date":"2023-01-13","title":"JPA에서 기본 키 매핑 방법 종류","category":"tech","tags":["JPA","JPA study"],"banner":null},"timeToRead":4}}},"staticQueryHashes":[],"slicesMap":{}}