{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/페이지-교체와-정책-swap/","result":{"data":{"markdownRemark":{"html":"<p>물리메모리를 필요로 하는 프로세스가 N개 있다고 가정합시다.\nN개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 프로세스들이 필요한 가상공간의 크기 총 합이 물리메모리의 크기보다 커지면 우리는 N개의 프로그램을 동시에 실행하지 못할 것입니다.</p>\n<h3 id=\"swap-space\" style=\"position:relative;\"><a href=\"#swap-space\" aria-label=\"swap space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap Space</h3>\n<p>이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space에는 자주 사용되지 않는 페이지가 위치합니다.</p>\n<p>물리메모리에서 자주 사용되지 않는 페이지가 Swap Space로 옮기는것을 Swap-out,</p>\n<p>반대로 Swap Space에 존재하는 페이지를 사용하기 위해 물리 메모리에 옮기는것을 Swap-in</p>\n<p>이라고 합니다.</p>\n<h3 id=\"가상-메모리-지원을-위한-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A7%80%EC%9B%90%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"가상 메모리 지원을 위한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 지원을 위한 방법</h3>\n<p>이렇듯 스왑 공간까지 사용해 메모리를 더 큰것처럼 사용할 수 있도록 하는 방법을 가상 메모리(VIrtual Memory)라고 합니다.</p>\n<p>가상 메모리를 사용을 지원하기 위해서는 Swap-in 또는 Swap-out 시 참조할 <strong>디스크상 페이지 주소</strong>를 알고있어야 합니다. 두번째로는 <strong>Present Bit</strong>를 알고있어야 합니다. Present Bit는 페이지 테이블 상의 페이지가 실제 물리메모리에 적재되어있는지 여부를 나타내는 데이터입니다.</p>\n<p><strong>Present Bit가 1인 경우</strong></p>\n<p>물리메모리에 데이터가 존재합니다. 이 경우 일반적인 페이징 방법처럼 PFN을 MMU로 전달해 CPU가 메모리에 접근 할 수 있습니다.</p>\n<p><strong>Present Bit가 0인 경우</strong></p>\n<p>해당 페이지 엔트리는 물리메모리에 없고 Swap Space에 존재함을 의미합니다. 이를 <strong>Page Fault</strong>라고 합니다.</p>\n<p>이 때 MMU는 인터럽트(Page Fault Trap)을 발생시켜 Page Fault Handler를 동작하고 여기서 페이지 교체 작업이 발생합니다.</p>\n<p>Page Fault Handler는 Page Table Entry의 Present Bit를 1로 변경하고, 디스크 데이터를 물리메모리로 적재하는 I/O작업을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093270-5092c56f-513e-4842-8bd9-320ed0dc6557.png\" alt=\"1\"></p>\n<p>앞서 Page Fault Handler를 통해 디스크에서 물리 메모리에 페이지를 적재한다고 했습니다. 그렇다면 위 그림을 보고 의문점이 생겨야 합니다.</p>\n<p><strong>Swap out을 언제 실행해야 하는가?</strong></p>\n<p>프로그램이 언제든 새로 시작될 수 있을 뿐만 아니라 운영체제는 특성상 항상 어느정도의 여유공간을 확보하고 있어야합니다. 이러한 운영체제 특성상 물리메모리가 가득 찼을 때만 Swap out을 하게되면 많은 문제점들이 발생합니다.</p>\n<p>이때문에 운영체제는 메모리 여유공간의 **최댓값(High watermark), 최솟값(Low watermark)**을 가지고있습니다. <strong>여유공간이 최솟값보다 적어지면 여유공간의 크기가 최댓값보다 작을때까지 여유공간을 확보</strong>합니다.  해당 스레드는 페이지 데몬(page daemon), 스왑 데몬(swap daemon)이라고 불리며, 충분한 여유공간이 확보될때까지 동작하다가 확보되면 백그라운드 스레드로 돌아갑니다.</p>\n<p><strong>Swap-out을 수행하는데, 어떤 페이지를 Swap Out 해야하는가</strong></p>\n<p>뒤이어 페이지 교체 정책에서 설명합니다.</p>\n<h2 id=\"페이지-교체-정책\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 정책</h2>\n<p>페이지 교체 정책에 대해 이야기하기 전에 교체 정책의 성능을 측정하는 방법에 대해 알아보아야 합니다.</p>\n<p><strong>AMAT(Average Memory Access Time): 평균 메모리 접근시간 = P(Hit) * T(M) + P(Miss) * T(D)</strong></p>\n<p>설명하자면, 스왑공간을 사용하는 가상 메모리 시스템의 평균 메모리 접근시간은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">P(Hit): 캐시 히트 확률 * T(M): 메모리 접근 시간을 곱해준 값 +\nP(Miss):페이지 폴트 확률과 T(D): 디스크 접근 시간</code></pre></div>\n<h3 id=\"최적-교체-방식-optimal-replacement-policy\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EA%B5%90%EC%B2%B4-%EB%B0%A9%EC%8B%9D-optimal-replacement-policy\" aria-label=\"최적 교체 방식 optimal replacement policy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 교체 방식 (Optimal Replacement Policy)</h3>\n<p>최적 교체방식의 원리는 간단합니다. <strong>“가장 나중에 참조할 페이지를 축출한다”</strong> 입니다.</p>\n<p>최적 교체방식은 이상적인 방법이지만, 가장 나중에 참조할 페이지 찾기라는 <strong>미래를 예측하는 불가능한 과정을 포함</strong>합니다.</p>\n<p>최적의 방법은 비교 기준으로만 사용되며, 비교하고자 하는 알고리즘이 정답에 얼마나 가까운지 알 수 있습니다.</p>\n<h3 id=\"lruleast-recently-used\" style=\"position:relative;\"><a href=\"#lruleast-recently-used\" aria-label=\"lruleast recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU(Least Recently Used)</h3>\n<p>LRU방식은 과거 메모리 접근에 대한 정보를 사용합니다. 이름 그대로 <strong>가장 먼 시점에 사용된 페이지를 교체합니다.</strong></p>\n<p>메모리 접근 정보 중에서 **최근성(recency)**를 사용한 방법입니다. 얼마나 최근에 접근했는지에 대한 정보를 가지고있습니다. 더 최근에 접근한 페이지일수록 가까운 시점에 다시 접근할 확률 이 높다는 특성인 **캐시 지역성의 원칙(Principle of locality)**이라는 특성에 기반을 둡니다.</p>\n<p>이처럼 메모리 접근 정보에는 빈도(frequency)도 있지만, MFU(Most Frequently Used)알고리즘은 캐시의 지역성 특징과 맞지 않으므로 효율적으로 동작하지 않습니다.</p>\n<p>예를들어 100번째 페이지를 5000회 접근한 이후 한번도 접근하지 않는다면 빈도수는 높아서 계속 물리메모리에 남아있지만 사용되지는 않습니다.</p>\n<p>LRU는 메모리 교체 방식중 효율이 가장 좋은 방법으로, 주로 사용되는 페이지 교체 알고리즘입니다.</p>\n<h3 id=\"간단한-방식들-fifo-random-select\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B0%A9%EC%8B%9D%EB%93%A4-fifo-random-select\" aria-label=\"간단한 방식들 fifo random select permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 방식들( FIFO, Random Select)</h3>\n<p><strong>First In First Out : 선입선출</strong></p>\n<p>먼저 들어온것이 먼저 나갑니다. 매우 간단한 알고리즘이지만 성능이 떨어집니다.</p>\n<p><strong>Ramdom Select: 무작위 선택</strong></p>\n<p>무작위로 Swap out될 페이지를 선택합니다. 해당 방법은 그때마다 수행 결과가 달라집니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","fields":{"slug":"페이지-교체와-정책-swap"},"frontmatter":{"title":"페이지 교체와 정책 (Swap)","date":"09.03.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"페이지-교체와-정책-swap","prev":{"excerpt":"페이징 기법의 문제점 앞선 글에서 소개한 페이징 기법에서는 페이지의 크기를 4KB로 가정했습니다. 그러나 현대에는 메모리의 크기가 4GB를 넘어 64GB까지도 사용됩니다. 이런 컴퓨터에서 4KB의 페이지를 사용한다면 페이지 개수가 10^6 ~ 10^…","html":"<h3 id=\"페이징-기법의-문제점\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"페이징 기법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법의 문제점</h3>\n<p>앞선 글에서 소개한 페이징 기법에서는 페이지의 크기를 4KB로 가정했습니다. 그러나 현대에는 메모리의 크기가 4GB를 넘어 64GB까지도 사용됩니다.</p>\n<p>이런 컴퓨터에서 4KB의 페이지를 사용한다면 페이지 개수가 10^6 ~ 10^7까지도 커지게 됩니다.</p>\n<p>페이지 테이블은 각 프로세스마다 가지는 자료구조이고, <strong>“커널메모리”에 저장</strong>되는 자료이다 보니, <strong>페이지 테이블이 커지면 커질수록</strong> <strong>메모리 가용역역이 작아집니다.</strong></p>\n<p>또한, Segmentation에서는 해결된 메모리의 보호와 공유가 어렵다는 문제가 남아있습니다.</p>\n<h3 id=\"페이지-테이블-크기-문제-해결방법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95\" aria-label=\"페이지 테이블 크기 문제 해결방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 크기 문제 해결방법</h3>\n<p><strong>(1) 더 큰 페이지 크기</strong></p>\n<p>단순하게 생각하면 페이지 크기를 더 키우면 페이지 테이블 사이즈는 작아집니다.</p>\n<p>이를 통해 <strong>(1)디스크 접근횟수를 줄이고 (2)페이지 테이블크기를 줄이는</strong> 효과를 얻을 수 있습니다.</p>\n<p>메모리 크기가 커짐에 따라 페이지 사이즈를 키울수록 이 방법은 몇 가지 <strong>단점</strong>이 있습니다</p>\n<ol>\n<li>내부 단편화가 더 크게 발생합니다.</li>\n<li>큰 페이지를 로드했지만, 사용되는 비율이 적어 <strong>메모리 사용률이 줄어듭니다</strong>.</li>\n</ol>\n<p><strong>(2) Multi Level Paging 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093248-29394fe1-480b-41af-8c30-ed6745922558.png\" alt=\"1\"></p>\n<p>Multi Level Paging기법에서는 페이지 디렉터리를 통해 하나의 레벨을 추가합니다.</p>\n<p>또한 페이지 디렉터리 테이블(PDT)에는 valid bit가 존재합니다. 앞선 페이징 방법에서는 Heap공간에서 사용중인 페이지를 valid bit로 판별했던 반면, <strong>PDT에서의 valid bit는 PDE가 가르키는 페이지 테이블의 엔트리들 중 하나라도 유효한지에 대한 여부입니다(중요) → Heap 또는 Stack의 빈공간으로 인해 사용되는 메모리 낭비를 없애줌.</strong></p>\n<p><strong>장단점</strong></p>\n<p>페이징에서는 페이지 번호를 통해 페이지 테이블에 접근했으므로, 해당 페이지가 스왑 스페이스에 있어도 하나의 페이지  테이블을 가지고있어야 했습니다.</p>\n<p><strong>Multi Level Paging방법에서는 PDT의 valid bit가 1인 PMT에 대해서만 메모리 공간을 할당하므로 메모리 공간 효율성이 뛰어납니다.</strong></p>\n<p>그러나 Multi Level로 페이지 테이블이 존재하는 경우 가상주소 변환에 있어 메모리 접근을 N회 해야한다는 단점이 있습니다. (TLB로 완화할 수 있습니다)</p>\n<p>이처럼 MultiLevel Paging에는 시간-공간 등가교환이 존재합니다.</p>\n<p><strong>(번외) Segmentation/Paging Hybrid 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093250-bb5c0f90-8f66-4cc1-8b47-ab1a13a3f84b.png\" alt=\"2\"></p>\n<p>Hybrid기법은 Segmentattion과 Paging기법을 혼합한 방법입니다.</p>\n<p>가상 메모리를 논리 단위의 세그먼트로 분할한 뒤, 이를 또 다시 페이지로 나눕니다.</p>\n<p>그렇기에 (그림 우측 상단의)가상 메모리 주소는 세그먼트 비트, 가상 페이지 번호인 Virtual Page Number,와 페이지 내에서의 Offset으로 이루어져 있습니다.</p>\n<p>즉, (S,P,D)값을 통해 물리 메모리 주소를 얻는것인데요, 방법은 아래와 같습니다.</p>\n<p><strong>1) 세그먼트 매핑 테이블 접근</strong></p>\n<p>세그먼트별로 존재하는 SMT에서 S번째 엔트리를 찾아갑니다. 여기서는 <strong>세그먼트 길이 검증, Protection Bit를 통해 자원의 공유와 보호를 수행</strong>합니다.</p>\n<p>또한 세그먼트에 대한 페이징 정보를 가지고있는 페이지 테이블 주소를 MMU에 전달합니다.</p>\n<p>물리메모리에는 Page 단위로 올라가므로 Residence bit는 존재하지 않습니다.</p>\n<p><strong>2) 페이지 매핑 테이블 접근</strong></p>\n<p>SMT에서 얻은 S(j)의 PMT 주소와 가상 페이지 번호인 VPN을 통해 물리 메모리에서 페이지의 주소를 획득합니다.</p>\n<p>이 때 Residence bit를 확인해 페이지가 존재하는지 확인하고 존재하지 않는다면 Page Fault Trap을 발생시켜 페이지 교체 알고리즘을 수행합니다.</p>\n<p><strong>3) PFN 획득 및 메모리 접근</strong></p>\n<p>PMT에서는 PFN을 얻었고, 여기에 페이지 크기를 곱하면 물리 메모리상 주소를 알 수 있습니다.</p>\n<p>Hybrid 기법은 페이징을 통해 메모리 사용률을 높혀준다는 장점과 세그멘테이션을 통해 보호와 공유를 용이하게 해준다는 장점이 있습니다.</p>\n<p>그러나 Hybrid방법에도 한계점은 존재합니다.</p>\n<ol>\n<li>여전히 페이지 테이블 크기가 많은 메모리 공간을 차지한다는 단점과</li>\n<li>Direct Mapping의 경우 가상 메모리 변환 시, 3회의 메모리 접근이 필요하다는 점입니다.\n<ol>\n<li>이는 TLB 활용으로 극복 가능합니다.</li>\n</ol>\n</li>\n</ol>\n<p>Fact Check</p>\n<ul>\n<li>\n<p>Protection Bit가 세그먼트에서 더 효율적인 이유</p>\n<p>→ 횟수에따른 용이성일것으로 생각, paging에서는 다음주소 참조시에도 또 확인해야해서</p>\n</li>\n<li>\n<p>Page Directory Table에서 또는 Page Table에서 Valid bit가 0인경우 swap공간에 있기는 한지?</p>\n<ul>\n<li>Multi Level Paging에서는 valid 가 0인 경우에 대해서 Page를 할당하지도 않는다! 따라서 swap공간에 있는게 아니라 사용하게되면 페이지를 다시 할당함.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"dfda67c2-6b6f-5a74-9ce7-bd696f306d49","fields":{"slug":"다양한-페이징-기법-hybrid-multi-level-paging"},"frontmatter":{"date":"2023-03-08","title":"다양한 페이징 기법 [ Hybrid, Multi Level Paging]","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},"next":null}},"staticQueryHashes":[],"slicesMap":{}}