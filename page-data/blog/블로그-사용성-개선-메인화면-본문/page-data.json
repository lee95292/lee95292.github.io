{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/블로그-사용성-개선-메인화면-본문/","result":{"data":{"markdownRemark":{"html":"<p>블로그를 통해 기록을 한다는건 내가 공부한것들을 글로 정리하며 체계화하거나, 느낀점을 남기는것. 또는 간단한 버그에 대해 해결방법을 기록하는 등, 다양한 목적이 있습니다. 중요한건 나의 생각을 잊지 않고 다시 확인할 수 있다는 것입니다.</p>\n<p>기억은 휘발성입니다. 개발자로서 성장하기 위해 노력하며, <strong>기록의 중요성</strong>에 대해 다시한번 체감하고 있습니다.</p>\n<p><strong>그런 면에서 제 블로그는 다소 카테고리, 태그에 대한 체계가 없고, 내 글을 다시 확인하고싶거나 저번에 기록해둔것을 찾아보고자 할 때 적합한 블로그는 아닙니다.</strong></p>\n<p>지금은 글이 50개정도로 많지는 않지만, 버그리포트부터 간단한 howto까지, <strong>다양한 주제에 대해 글을 쓰게 된다면, 시간이 조금만 지나도 글들이 파묻힐 것 같았습니다.</strong></p>\n<img width=\"1406\" alt=\"1,3\" src=\"https://user-images.githubusercontent.com/30853787/226534592-c87b8092-0281-415f-b039-5708636adf96.png\">\n<p>크게 아래 세 부분에 대한 개선을 장기적인 관점에서 중점적으로 해볼 예정입니다.</p>\n<ol>\n<li>메인페이지에서 카테고리와 태그를 통한 글 필터링 ( 이번 글에서 다룰 부분 )</li>\n<li>Heatmap 또는 다른 도구를 통한 글 작성일자별 필터링</li>\n<li>Text-match 기반으로 블로그 글 검색</li>\n</ol>\n<h1 id=\"블로그를-뜯어-고쳐보자\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EB%9C%AF%EC%96%B4-%EA%B3%A0%EC%B3%90%EB%B3%B4%EC%9E%90\" aria-label=\"블로그를 뜯어 고쳐보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블로그를 뜯어 고쳐보자!</h1>\n<p>현재 블로그는 Majid Hajian님의 Gatsby 커스텀 템플릿(<a href=\"https://github.com/mhadaily/gatsby-starter-typescript-power-blog\">https://github.com/mhadaily/gatsby-starter-typescript-power-blog</a>)으로 구현되어있습니다. 따라서 블로그 소스코드는 Typescript로 작성되었고, 이를 자유자재로 수정해 빌드할 수 있습니다.</p>\n<p>tistory나 velog등 좋은 블로그 플랫폼이 있지만, 정적블로그를 선택한 이유죠!</p>\n<h2 id=\"유저-인터페이스\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%A0%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"유저 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유저 인터페이스</h2>\n<p>앞서 언급한 태그/카테고리별 글 필터링(+ 내용으로 필터링), 작성일자별 필터링,  검색과 본인 소개 영역까지 총 4개의 서브 영역과 글 목록이 보일 메인 영역까지, 총 5개의 영역이 구성되어야 합니다.</p>\n<p>작성일자별 필터링은 급하지 않으니, 제외한 4개 영역으로 구성해보았습니다.</p>\n<ol>\n<li>\n<p><strong>카테고리</strong>는 크케 아래와 같이 구성해보았습니다.</p>\n<ul>\n<li>Tech: 무언가의 개념이나 기술적인 고민들</li>\n<li>Bugfix: 버그를 해결하는 방법(들)을 정리.</li>\n<li>Howto: 간단한 설정이나 문제를 해결한 방법 공유</li>\n<li>Etc: 회고, 일기, 기타 정보. ( 내용이 많아지는 카테고리는 따로 분류)</li>\n</ul>\n</li>\n<li>\n<p><strong>태그</strong>는 아래와 같이 구성해 세부주제별 글의 종류를 확인할 수 있도록 할 예정입니다.</p>\n<ul>\n<li>특정 기술/라이브러리/프레임워크의 종류 (Spring, React, CSRF, CORS 등..)</li>\n<li>시리즈의 경우 시리즈 태그 ( jpa-study  등)</li>\n</ul>\n<p>이외에 추가적으로 손본 부분</p>\n<ul>\n<li>태그/필드 선택 시 안내정보</li>\n</ul>\n</li>\n<li>\n<p><strong>메인영역인 글 목록 부분</strong>은 크게 건드리지 않되, 글 상단부 내용 일부를 미리보기 할 수 있도록 했습니다.</p>\n</li>\n<li>\n<p><strong>본인 소개 영역</strong>은 기존에 1/2를 차지할정도로 큰 영역을 차지했는데, 상단부에 짧은 띠 형태로 배치해 공간 차지를 줄였습니다.</p>\n</li>\n</ol>\n<h3 id=\"메인페이지-개선-결과\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%9D%B8%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B0%9C%EC%84%A0-%EA%B2%B0%EA%B3%BC\" aria-label=\"메인페이지 개선 결과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메인페이지 개선 결과</h3>\n<p><strong>[Before] 메인 페이지</strong></p>\n<hr>\n<img width=\"1406\" alt=\"1,3\" src=\"https://user-images.githubusercontent.com/30853787/226534592-c87b8092-0281-415f-b039-5708636adf96.png\">\n<p><strong>[After] 메인 페이지</strong></p>\n<hr>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226534583-29bd0329-216e-4a1b-9b11-d3703427fd42.png\" alt=\"2\"></p>\n<h2 id=\"고치다보니-더-신경써야할것같은-부분들\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%B9%98%EB%8B%A4%EB%B3%B4%EB%8B%88-%EB%8D%94-%EC%8B%A0%EA%B2%BD%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B2%83%EA%B0%99%EC%9D%80-%EB%B6%80%EB%B6%84%EB%93%A4\" aria-label=\"고치다보니 더 신경써야할것같은 부분들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고치다보니 더 신경써야할것같은 부분들</h2>\n<p>블로그를 한번 손대고 나니, 여러모로 더 손봐야 할 부분이 많이 보였습니다.</p>\n<p>특히 본문 가독성 측면에서 어딘가 모를 불편함이 왔고, 이것을 목록화 해보았습니다.</p>\n<p><strong>[Before] 본문 영역</strong></p>\n<img width=\"1417\" alt=\"4\" src=\"https://user-images.githubusercontent.com/30853787/226534589-e5932559-61f9-40ac-b3ad-62004f680158.png\">\n**고쳐야할 부분들**\n<ul>\n<li>폰트</li>\n<li>본문 폭 : 가독성 측면에서 상당한 차이가 있음을 알아냈습니다(..!)</li>\n<li>모바일 반응형</li>\n<li>ul, li 및 h태그 사이 간격</li>\n<li>…등등</li>\n</ul>\n<p><strong>[After] 본문 영역</strong></p>\n<img width=\"1393\" alt=\"5\" src=\"https://user-images.githubusercontent.com/30853787/226534595-8934c69b-4d4e-4d69-9f7e-53abd2928fcf.png\">\n<h3 id=\"가까운-시일-내에-추가적으로-해볼-부분\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EA%B9%8C%EC%9A%B4-%EC%8B%9C%EC%9D%BC-%EB%82%B4%EC%97%90-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%B4%EB%B3%BC-%EB%B6%80%EB%B6%84\" aria-label=\"가까운 시일 내에 추가적으로 해볼 부분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가까운 시일 내에 추가적으로 해볼 부분</h3>\n<ol>\n<li>UI상 카테고리 부분을 선택 후 태그를 선택해 보는게 일반적인데, 카테고리를 선택했을 때, 그 안에있는 태그와 태그상 글 개수가 매핑되지 않습니다. (버그는 아니지만, 직관력이 떨어지는 느낌)</li>\n<li>마찬가지로 “태그 선택” 부분에서 너무 많은 태그가 분류없이 존재해, 일반 블로그에서 Tree형식으로 카테고리를 제공하듯 수정하고 싶습니다.</li>\n<li>블로그 레포지토리의 Readme.md에는 장기적으로 블로그에 적용해보고싶은 내용에 대해 정리해놓았습니다.</li>\n</ol>\n<p><a href=\"https://github.com/lee95292/blog_mglee\">https://github.com/lee95292/blog_mglee</a></p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며..</h2>\n<p>공부하며 글을 쓸때는, 눈으로 글을 읽을때보다 더 천천히 글자 하나하나를 톺아보며 읽게됩니다.  읽기만 할 때는 정신없이 소화하기 바빴던 내용들이지만, 천천히 읽다보면 의미있는 궁금증들이 하나, 둘 생겨나고 그 질문들을 해결해나가며 완성도있는 지식을 머릿속에 담아냅니다.</p>\n<p>아직 기술적인 부분에서는 갈길이 멀지만, 꾸준히 배움에 재미를 느끼고 계속 성장하고싶습니다.</p>","fields":{"slug":"블로그-사용성-개선-메인화면-본문"},"frontmatter":{"title":"블로그 사용성 개선[메인화면, 본문]","date":"03.21.2023","category":"etc","tags":["블로그"],"banner":null,"description":null},"timeToRead":2}},"pageContext":{"slug":"블로그-사용성-개선-메인화면-본문","prev":{"excerpt":"물리메모리를 필요로 하는 프로세스가 N개 있다고 가정합시다.\nN개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 프로세스들이 필요한 가상공간의 크기 총 합이 물리메모리의 크기보다 커지면 우리는 N개의 프로그램을 동시에 실행하지 못할 것입니다. Swap Space 이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space…","html":"<p>물리메모리를 필요로 하는 프로세스가 N개 있다고 가정합시다.\nN개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 프로세스들이 필요한 가상공간의 크기 총 합이 물리메모리의 크기보다 커지면 우리는 N개의 프로그램을 동시에 실행하지 못할 것입니다.</p>\n<h3 id=\"swap-space\" style=\"position:relative;\"><a href=\"#swap-space\" aria-label=\"swap space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap Space</h3>\n<p>이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space에는 자주 사용되지 않는 페이지가 위치합니다.</p>\n<p>물리메모리에서 자주 사용되지 않는 페이지가 Swap Space로 옮기는것을 Swap-out,</p>\n<p>반대로 Swap Space에 존재하는 페이지를 사용하기 위해 물리 메모리에 옮기는것을 Swap-in</p>\n<p>이라고 합니다.</p>\n<h3 id=\"가상-메모리-지원을-위한-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A7%80%EC%9B%90%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"가상 메모리 지원을 위한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 지원을 위한 방법</h3>\n<p>이렇듯 스왑 공간까지 사용해 메모리를 더 큰것처럼 사용할 수 있도록 하는 방법을 가상 메모리(VIrtual Memory)라고 합니다.</p>\n<p>가상 메모리를 사용을 지원하기 위해서는 Swap-in 또는 Swap-out 시 참조할 <strong>디스크상 페이지 주소</strong>를 알고있어야 합니다. 두번째로는 <strong>Present Bit</strong>를 알고있어야 합니다. Present Bit는 페이지 테이블 상의 페이지가 실제 물리메모리에 적재되어있는지 여부를 나타내는 데이터입니다.</p>\n<p><strong>Present Bit가 1인 경우</strong></p>\n<p>물리메모리에 데이터가 존재합니다. 이 경우 일반적인 페이징 방법처럼 PFN을 MMU로 전달해 CPU가 메모리에 접근 할 수 있습니다.</p>\n<p><strong>Present Bit가 0인 경우</strong></p>\n<p>해당 페이지 엔트리는 물리메모리에 없고 Swap Space에 존재함을 의미합니다. 이를 <strong>Page Fault</strong>라고 합니다.</p>\n<p>이 때 MMU는 인터럽트(Page Fault Trap)을 발생시켜 Page Fault Handler를 동작하고 여기서 페이지 교체 작업이 발생합니다.</p>\n<p>Page Fault Handler는 Page Table Entry의 Present Bit를 1로 변경하고, 디스크 데이터를 물리메모리로 적재하는 I/O작업을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093270-5092c56f-513e-4842-8bd9-320ed0dc6557.png\" alt=\"1\"></p>\n<p>앞서 Page Fault Handler를 통해 디스크에서 물리 메모리에 페이지를 적재한다고 했습니다. 그렇다면 위 그림을 보고 의문점이 생겨야 합니다.</p>\n<p><strong>Swap out을 언제 실행해야 하는가?</strong></p>\n<p>프로그램이 언제든 새로 시작될 수 있을 뿐만 아니라 운영체제는 특성상 항상 어느정도의 여유공간을 확보하고 있어야합니다. 이러한 운영체제 특성상 물리메모리가 가득 찼을 때만 Swap out을 하게되면 많은 문제점들이 발생합니다.</p>\n<p>이때문에 운영체제는 메모리 여유공간의 **최댓값(High watermark), 최솟값(Low watermark)**을 가지고있습니다. <strong>여유공간이 최솟값보다 적어지면 여유공간의 크기가 최댓값보다 작을때까지 여유공간을 확보</strong>합니다.  해당 스레드는 페이지 데몬(page daemon), 스왑 데몬(swap daemon)이라고 불리며, 충분한 여유공간이 확보될때까지 동작하다가 확보되면 백그라운드 스레드로 돌아갑니다.</p>\n<p><strong>Swap-out을 수행하는데, 어떤 페이지를 Swap Out 해야하는가</strong></p>\n<p>뒤이어 페이지 교체 정책에서 설명합니다.</p>\n<h2 id=\"페이지-교체-정책\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 정책</h2>\n<p>페이지 교체 정책에 대해 이야기하기 전에 교체 정책의 성능을 측정하는 방법에 대해 알아보아야 합니다.</p>\n<p><strong>AMAT(Average Memory Access Time): 평균 메모리 접근시간 = P(Hit) * T(M) + P(Miss) * T(D)</strong></p>\n<p>설명하자면, 스왑공간을 사용하는 가상 메모리 시스템의 평균 메모리 접근시간은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">P(Hit): 캐시 히트 확률 * T(M): 메모리 접근 시간을 곱해준 값 +\nP(Miss):페이지 폴트 확률과 T(D): 디스크 접근 시간</code></pre></div>\n<h3 id=\"최적-교체-방식-optimal-replacement-policy\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EA%B5%90%EC%B2%B4-%EB%B0%A9%EC%8B%9D-optimal-replacement-policy\" aria-label=\"최적 교체 방식 optimal replacement policy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 교체 방식 (Optimal Replacement Policy)</h3>\n<p>최적 교체방식의 원리는 간단합니다. <strong>“가장 나중에 참조할 페이지를 축출한다”</strong> 입니다.</p>\n<p>최적 교체방식은 이상적인 방법이지만, 가장 나중에 참조할 페이지 찾기라는 <strong>미래를 예측하는 불가능한 과정을 포함</strong>합니다.</p>\n<p>최적의 방법은 비교 기준으로만 사용되며, 비교하고자 하는 알고리즘이 정답에 얼마나 가까운지 알 수 있습니다.</p>\n<h3 id=\"lruleast-recently-used\" style=\"position:relative;\"><a href=\"#lruleast-recently-used\" aria-label=\"lruleast recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU(Least Recently Used)</h3>\n<p>LRU방식은 과거 메모리 접근에 대한 정보를 사용합니다. 이름 그대로 <strong>가장 먼 시점에 사용된 페이지를 교체합니다.</strong></p>\n<p>메모리 접근 정보 중에서 **최근성(recency)**를 사용한 방법입니다. 얼마나 최근에 접근했는지에 대한 정보를 가지고있습니다. 더 최근에 접근한 페이지일수록 가까운 시점에 다시 접근할 확률 이 높다는 특성인 **캐시 지역성의 원칙(Principle of locality)**이라는 특성에 기반을 둡니다.</p>\n<p>이처럼 메모리 접근 정보에는 빈도(frequency)도 있지만, MFU(Most Frequently Used)알고리즘은 캐시의 지역성 특징과 맞지 않으므로 효율적으로 동작하지 않습니다.</p>\n<p>예를들어 100번째 페이지를 5000회 접근한 이후 한번도 접근하지 않는다면 빈도수는 높아서 계속 물리메모리에 남아있지만 사용되지는 않습니다.</p>\n<p>LRU는 메모리 교체 방식중 효율이 가장 좋은 방법으로, 주로 사용되는 페이지 교체 알고리즘입니다.</p>\n<h3 id=\"간단한-방식들-fifo-random-select\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B0%A9%EC%8B%9D%EB%93%A4-fifo-random-select\" aria-label=\"간단한 방식들 fifo random select permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 방식들( FIFO, Random Select)</h3>\n<p><strong>First In First Out : 선입선출</strong></p>\n<p>먼저 들어온것이 먼저 나갑니다. 매우 간단한 알고리즘이지만 성능이 떨어집니다.</p>\n<p><strong>Ramdom Select: 무작위 선택</strong></p>\n<p>무작위로 Swap out될 페이지를 선택합니다. 해당 방법은 그때마다 수행 결과가 달라집니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"17750e88-7178-50d4-b121-377268c8ac01","fields":{"slug":"페이지-교체와-정책-swap"},"frontmatter":{"date":"2023-03-09","title":"페이지 교체와 정책 (Swap)","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null,"description":null},"timeToRead":2},"next":{"excerpt":"Thread와 동작원리 <이미지 출처 https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean > Thread는 Process 내에서 분기하는 또 다른 실행 흐름입니다. 주소공간 멀티스레드 환경에서 프로세스의 주소공간은, 스레드의 개수만큼 스택 공간이 필요합니다. 이를 Thread-local, 또는 Thread-stack…","html":"<h1 id=\"thread와-동작원리\" style=\"position:relative;\"><a href=\"#thread%EC%99%80-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"thread와 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread와 동작원리</h1>\n<img width=\"768\" alt=\"멀티스레드/프로세스 메모리 구조\" src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/72ccb320-559b-4d78-8c05-766cbd01904c\">\n<p>&#x3C;이미지 출처 <a href=\"https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean\">https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/korean</a> ></p>\n<p>Thread는 Process 내에서 분기하는 또 다른 실행 흐름입니다.</p>\n<p><strong>주소공간</strong></p>\n<p>멀티스레드 환경에서 프로세스의 주소공간은, 스레드의 개수만큼 스택 공간이 필요합니다. 이를 <strong>Thread-local</strong>, 또는 <strong>Thread-stack</strong>이라고 합니다.</p>\n<p>멀티스레드 모델에서 주소공간 배치의 안정성이 떨어졌지만, 일반적으로 Thread-local공간은 크기가 매우 작으므로, 주소 침범으로 인한 문제가 발생하는 경우는 거의 없습니다. (Recursion을 과도하게 많이 사용할 경우를 대비해 Recursion Limit을 설정합니다. )</p>\n<p><strong>문맥교환(Context Switch)</strong></p>\n<p>PC(Program Counter)가 프로세스별로 한 개였던 단일 스레드 기반 동작과 달리, 멀티스레드 방식에서는 각 스레드마다 PC를 가지고있습니다. PC레지스터 뿐만 아니라 실행시 스레드의 정보를 담고있는 다양한 레지스터를 TCB(Thread Control Block)에 저장합니다. 이는 PCB와 마찬가지로 커널 메모리영역에 저장됩니다.</p>\n<p>스레드간의 문맥 교환은 TCB 에 있는 데이터를 CPU 레지스터로 로드하면서 시작됩니다. TCB를 독자적으로 가졌던것과 달리, 주소공간은 공유하므로 Page Table은 그대로 사용합니다.</p>\n<p><strong>멀티스레드의</strong> <strong>장점</strong></p>\n<hr>\n<p><strong>응답성</strong> 측면에서는 병렬실행을 통한 장점을 가져올 수 있습니다. 일부 스레드가 I/O작업을 처리할때 다른 스레드가 사용자 요청을 처리합니다.</p>\n<p><strong>캐시친화적</strong> 측면에서는 가장 큰 공간을 차지하는 힙 영역을 공유하므로, 캐시 히트 확률이 올라갑니다.</p>\n<p><strong>자원 활용율</strong> 측면에서, 멀티프로세서(CPU)로 구동 시 프로세서 활용률이 높아집니다.</p>\n<h2 id=\"멀티스레드의-동시성-관리\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B4%80%EB%A6%AC\" aria-label=\"멀티스레드의 동시성 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티스레드의 동시성 관리</h2>\n<p>앞서 살펴본것처럼 멀티 스레드는 성능측면에서 많은 장점이 있습니다. 높은 성능을 가져오는 주된 이유는 “자원 공유”이지만, 자원을 공유해 사용할때는 <strong>동시성 문제</strong>에 대한 관리를 적절히 해주어야 합니다.</p>\n<p><strong>동시성 문제란?</strong></p>\n<p>스레드는 <strong>비동기적</strong>으로 동작합니다. 이들은 다른 스레드의 동작과 무관하게 동작하고, 다른 스레드가 어떤 자원을 변경하는지 모릅니다.</p>\n<p>그렇기에 경쟁상태(race condition)에 있는 스레드들의 실행 결과는 <strong>비결정적</strong>입니다. Timer Interrupt로 인해 프로그램 입장에서 랜덤한 시간에 발생하는 스케쥴링 때문입니다.</p>\n<p><strong>경쟁상태의 스레드들이 비결정적으로 동작하는 예시</strong></p>\n<p>간단하게 설명하자면, A,B 스레드가 money값(100)을 읽어(Read) 200을 더하고(Add) 저장하는(Save) 과정을 수행한다고 합시다. 여기에서 동작하는 Read, Add, Save과정은 일괄적으로 처리되지 않습니다.</p>\n<p>앞서 설명했듯, 스레드의 동작과는 상관없이 동작하는 Scheduling으로 인해 Atomic하지 않습니다. 아래와 같이 동작할 수도 있습니다.</p>\n<p>→ A스레드의 Read(100), Add(300),</p>\n<p><strong>→ A에서 B스레드로 Context Switch(Scheduled)</strong></p>\n<p>→ B스레드의 Read(100), Add(300), Save(400)</p>\n<p><strong>→ B에서 A스레드로 Context Switch(Scheduled)</strong></p>\n<p>→ A 스레드의 Save(400)</p>\n<p>위 과정에서 A,B 두 스레드가 100인 money값을 각각 300씩 더해주었지만, 저장된 값은 400으로, <strong>스케줄링 타이밍에 따라 공유자원인 money를 수정하는 스레드의 동작을 예측할 수 없습니다.</strong></p>\n<p>이를 동시성이 보장되지 않은 상태라고 합니다.</p>\n<p><strong>동시성을 보장하는 방법</strong></p>\n<p>아래 조건을 만족하면 동시성이 보장되었다고 합니다.</p>\n<ol>\n<li>\n<p><strong>상호배제(Mutual Exclusion): 임계구역에는 단 하나의 실행흐름만이 동작할 수 있다.</strong></p>\n<p>임계구역이란, 공유자원을 수정하는 코드 영역을 일컫습니다. 상호배제는 동시성 프로그래밍의 가장 기본조건으로, 임계구역에서 공유자원을 수정하는 스레드는 하나여야함을 말합니다.</p>\n</li>\n<li>\n<p><strong>진행(Progress): 임계구역에 존재하는 실행흐름만이 임계구역으로의 접근을 막을 수 있다.</strong></p>\n<p>에를 들어, 임계구역에 아무 프로세스도 존재하지 않는데 진입하지 못하는 경우가 있을 수 있습니다.</p>\n</li>\n<li>\n<p><strong>한정대기(Bounded Waiting, for Fairness) : 임계구역에 접근하기 위해 대기하는 시간은 한정적이어야 한다.</strong></p>\n<p>다른 스레드의 임계구역 접근때문에 무한히 대기하는 스레드가 생길 수 있습니다.</p>\n</li>\n</ol>\n<p>동시성 프로그래밍의 구체적인 에시를 살펴보겠습니다.</p>\n<h3 id=\"변수를-통한-동시성-보장-방법\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EB%B2%95\" aria-label=\"변수를 통한 동시성 보장 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수를 통한 동시성 보장 방법</h3>\n<p>Thread-safe하게 동작하는것은 굉장히 복잡합니다. 아래 예시들을 통해 동시성이 보장된것같지만 그렇지 않은 예시들을 살펴보겠습니다.</p>\n<ol>\n<li>turn을 통한 할당</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> turn <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nturn <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> turn <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nturn <span class=\"token operator\">=</span> <span class=\"token number\">0</span></code></pre></div>\n<p><strong>Progress조건을 위배합니다</strong>. 하나의 스레드가 두 번 임계영역에 접근하고자 할 때, 임계구역에 어떤 스레드도 없지만 진입할 수 없습니다.</p>\n<ol>\n<li>flag를 통한 할당</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repeat\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False</code></pre></div>\n<p>(여기부터 스케쥴링이 등장)</p>\n<p><strong>한정대기 조건을 위배</strong>합니다. flag[x] = True 이후 <strong>preemption</strong>된다면, 두 스레드 모두 flag를 할당받기 때문에, 무한대기 상태에 빠집니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"># <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repaet\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False\n\n# <span class=\"token punctuation\">[</span>Thread <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">while</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token operator\">:</span> repaet\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n<span class=\"token comment\">//critical section //</span>\nflag<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False</code></pre></div>\n<p>이를 방지하기 위해 flag[x]=True구문을 while구문 아래에 넣게 된다면, while구문 이후에 preemption되었을 때,  두 스레드 모두 임계구역에 들어올 수 있어 <strong>상호배제 조건을 위배합니다.</strong></p>\n<h1 id=\"동시성-문제의-해결방법-hw-support\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C%EC%9D%98-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-hw-support\" aria-label=\"동시성 문제의 해결방법 hw support permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제의 해결방법: HW support</h1>\n<ol>\n<li>Dekker’s, Dijkstra’s 알고리즘 등 앞선 SW 해결 방식에서는 preemption으로 인해 동시성 보장이 확실시되지 않으며,</li>\n<li>Spin Lock(Busy Waitting)기반으로 자원 점유를 기다리기때문에 효율성 측면에서 오버헤드가 발생합니다.</li>\n<li>구현이 복잡합니다.</li>\n</ol>\n<p>이에 HW또는 OS측면에서 동시성 보장을 보장하기도 합니다.</p>\n<h3 id=\"tas--testandset-instruction-\" style=\"position:relative;\"><a href=\"#tas--testandset-instruction-\" aria-label=\"tas  testandset instruction  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TAS ( TestAndSet Instruction )</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">boolean <span class=\"token function\">TestAndSet</span><span class=\"token punctuation\">(</span>boolean<span class=\"token operator\">*</span> lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tboolean old <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>lock<span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">*</span>lock <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TAS(Test And Set Instruction) CPU level에서 구현되어, 기계적으로 Atomic하게 수행하는것을 보장하는 명령집합입니다. 불특정 시간에 Preemption되는 상황에서도 상호배제가 지켜집니다!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">TAS</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">break</span>\nend <span class=\"token keyword\">while</span>\n<span class=\"token char\">''</span>'\nCRITICAL SECTION\n<span class=\"token char\">''</span>'\nlock <span class=\"token operator\">=</span> false</code></pre></div>\n<p><strong>TAS를 통해 상호배제를 보장하는 방법</strong></p>\n<p>TAS는 현재 값을 출력함과 동시에 Flag값을 True로 변경합니다.</p>\n<p>lock 전역변수에는 False,True가 들어있으며, <strong>False의경우 대기, True의 경우 점유</strong>라는 의미를 갖습니다.</p>\n<p>스레드들 중, TAS가 수행되는 동안 lock변수가 True여서 점유할 수 있게 되면, TAS명령어는 Atomic하게 True를 리턴함과 동시에 전역 Lock변수를 False로 바꿔줍니다.</p>\n<p>TAS명령은 Interrupt를 받지 않아 선정당하지 않고 Atomic하게 동작하고, 앞선 SW를 통한 해결방법보다 간단합니다.</p>\n<p><strong>TAS를 통한 동시성 제어의 제한점</strong></p>\n<p>이 방법은 상호배제와 진행을 충족하지만, 여러 스레드에서 동작할 때 <strong>공정성 측면의 한정대기는 지켜지지 않습니다.</strong></p>\n<p>Lock을 요청한 순서가 고려되어있지 않기 때문에 특정 스레드가 Lock을 계속 획득하지 못해 응답시간이 지연되는 starvation이 발생하기 때문입니다.</p>\n<p>또한 여러 개 스레드의 동시성을 제어하기 위해서는 추가적인 제어가 필요하며, Spin Lock기반이라는 점은 SW방법과 크게 다르지 않습니다.</p>\n<p>(++)</p>\n<hr>\n<p>세마포어 방식에서 사용하는 Sleep Wakeup:\nSleep 상태에서 락에 블로킹당하면 Wait큐로 들어갔다가 Ready Queue로 가기때문에, 실행순서 보장 안됨</p>\n<p>Yield의 경우, Ready Queue로 돌아가기때문에, 스케줄링 순서 보장 (공정한 스케줄링 보장)</p>\n<p>스케줄링 효율성과 공정성에 대한 등가교환 존재</p>\n<hr>\n<p>Thread throttling vs Thread pool</p>\n<p>Thread throttling과 thread pool은 모두 다중 스레드 환경에서 효율적인 자원 관리를 위해 사용되는 기술입니다.</p>\n<p>Thread throttling은 작업 수행에 필요한 리소스(보통은 CPU)를 효율적으로 활용하기 위해 작업의 실행을 지연시키는 것입니다. 예를 들어, 일정 시간 동안 특정 수의 작업만 허용하는 방식으로 스레드를 제어할 수 있습니다. 이렇게 하면 실행 중인 작업의 수가 일정하게 유지되므로 CPU 사용률이 향상되고 전체 시스템 성능이 향상될 수 있습니다.</p>\n<p>Thread pool은 스레드를 사전에 생성하고 작업을 처리할 때마다 사용 가능한 스레드 중 하나를 선택하여 할당하는 것입니다. 이렇게 하면 작업 수행에 필요한 스레드 생성 및 삭제의 오버헤드를 줄일 수 있습니다. Thread pool은 일반적으로 대규모 애플리케이션에서 사용되며, 많은 양의 요청을 처리할 때 유용합니다.</p>\n<p>따라서, Thread throttling은 실행중인 작업의 수를 제어하여 CPU 사용률을 조절하고 전체 시스템 성능을 향상시키는 반면, Thread pool은 스레드 생성 및 삭제 오버헤드를 줄이고 작업 처리를 더 효율적으로 처리할 수 있도록 돕습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><strong>OSTEP: Operating Systems: Three Easy Pieces</strong> - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><strong>HPC Lab. KOREATECH, OS Lecture-</strong> <a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></p>","id":"a63297cb-e2dd-5ad9-bd01-3b96e82a52d5","fields":{"slug":"운영체제-멀티스레드와-동시성-문제"},"frontmatter":{"date":"2023-03-22","title":"운영체제 멀티스레드와 동시성 문제","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null,"description":null},"timeToRead":4}}},"staticQueryHashes":[],"slicesMap":{}}