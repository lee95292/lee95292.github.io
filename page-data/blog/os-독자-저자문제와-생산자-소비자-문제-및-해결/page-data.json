{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/os-독자-저자문제와-생산자-소비자-문제-및-해결/","result":{"data":{"markdownRemark":{"html":"<p>이번 글에서는 앞서 공부한 세마포어를 바탕으로, 대표적으로 알려진 동시성 문제를 다룹니다. 세마포어에 대해서는 이전 글을 참고해주세요.</p>\n<ul>\n<li>Producer-Consumer Problem</li>\n<li>Reader-Writer Problem</li>\n<li>//Dinning Philosopher’s Problem</li>\n</ul>\n<h2 id=\"producer-consumer-문제\" style=\"position:relative;\"><a href=\"#producer-consumer-%EB%AC%B8%EC%A0%9C\" aria-label=\"producer consumer 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Producer-Consumer 문제</h2>\n<p><strong>배경지식: Ring Buffer</strong></p>\n<p>생산자 소비자 구조에서 자주 사용되는 Ring Buffer구조는 Circular Queue자료구조입니다. 이는 배열과 head, tail에 대한 포인터를 갖고, size변수를 통해 Ring buffer의 크기를 판별합니다.</p>\n<p>Modular연산을 통해 head, tail 포인터를 정의해 삽입/삭제 시 head/tail 포인터가 배열 범위 안에서 정의되도록 합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/05f2b93f-4e6b-48bf-aebe-123595689104\" alt=\"Producer-Consumer drawio\"></p>\n<p>생상자-소비자 문제라고도 불립니다. 이는 컴퓨터와 프린터 관계로 보면 됩니다.</p>\n<p>문서를 등록하는 컴퓨터와 프린터는 여러개입니다.</p>\n<p>컴퓨터는 프린트해야하는 문서들을 작업 큐에 등록합니다(Produce)</p>\n<p>프린터는 작업 큐에 올라온 문서를 차례로 프린트합니다. (Consume)</p>\n<p>생산자-소비자 문제는 일반적인 공유변수에서의 동기화 문제와는 달리, 데이터의 삽입/인출부분이 정해져있다는 차이점이 있습니다.</p>\n<ul>\n<li>그렇기에, Producer가 데이터를 삽입할 때 Consumer가 데이터를 인출하는 작업은 경쟁상태가 발생하지 않습니다.(다른 위치이므로)</li>\n<li>하지만 데이터가 가득 찼거나, 텅 비었을 때는 head/tail 포인터의 위치가 같습니다. 이를 고려해야 합니다.</li>\n<li>여전히 Producer끼리, Consumer끼리는 상호배제가 지켜저야 합니다.</li>\n</ul>\n<p>이를 바탕으로 Consumer와 Producer 코드를 작성해보겠습니다.</p>\n<p><strong>세마포어 변수</strong></p>\n<p>MutexP [0,1]: Binary Semaphore로, 프로듀서간 공유자원 상호배제를 달성합니다.</p>\n<p>MutexC [0,1]: 마찬가지로, 컨슈머간 상호배제를 달성합니다.</p>\n<p>NEmpty  [0 ~ N] : 링버퍼가 비어있는지에 대한 세마포어입니다.  // P(NEmpty)비어있으면 Blocking</p>\n<p>NFull [N ~ 0]: 링버퍼가 가득 차있는지에 대한 세마포어입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Producer's Code</span>\n<span class=\"token comment\">// repeat this code</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>MutexP<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2개 이상의 Producer 접근 금지, Producer간 상호배제 달성</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>NFull<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 데이터가 가득 찬 경우, NFull==0이므로, Blocking</span>\n<span class=\"token punctuation\">[</span>Data Produce<span class=\"token punctuation\">]</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>NEmpty<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>MutexP<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Consumer's Code</span>\n<span class=\"token comment\">// repeat this code</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>MutexC<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2개 이상의 Consumer 접근금지, Consumer간 상호배제 달성</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>NEmpty<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 데이터가 없는 경우, NEmpty ==0이르모, Blocking</span>\n<span class=\"token punctuation\">[</span>Data Consume<span class=\"token punctuation\">]</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>NFull<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>MutexC<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 예시를 살펴보면, head,tail이 겹치는 부분에서 Producer와 Consumer의 실행이 동시에 일어나지 않습니다.</p>\n<ul>\n<li>링버퍼에 데이터가 가득 찬 경우 : Consumer만 접근 가능</li>\n<li>링버퍼가 텅 빈 경우: Producer만 접근 가능</li>\n</ul>\n<p>이는 underflow, overflow를 막기 위함도 있지만, 단순히 if문을 사용하지 않고 세마포어 변수를 통해 동시 실행을 제어했으므로, 경쟁상태가 발생하지 않습니다.</p>\n<p>(만약, 공유변수인 데이터 개수를 세마포어로 통제하지 않고, 데이터개수가 0일 때 발생하는 문제점을 생각해보면 좋습니다.)</p>\n<h2 id=\"reader-writer문제\" style=\"position:relative;\"><a href=\"#reader-writer%EB%AC%B8%EC%A0%9C\" aria-label=\"reader writer문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reader-Writer문제</h2>\n<p>Reader-Writer문제는 읽기만 담당하는 스레드와 쓰기만 담당하는 스레드가 나뉜 상황입니다. (이하 Reader, Writer)</p>\n<p>Reader-Reader관계에는 상호배제가 필요하지 않지만,  Writer-Writer또는 Reader-Writer간에는 상호배제가 필요합니다.</p>\n<p><strong>우선권 문제</strong></p>\n<p>만약, Reader가 끊임없이 생성되어 Writer 스레드가 작업할 수 없다면 어떻게될까요? 또는, Writer가 계속 생성되어 Reader가 생성되는 경우도 마찬가지입니다.  이에 Reader,Writer에 대해 우선순위를 주도록 구현할 수 있습니다.</p>\n<p><strong>Reader Preference Solution</strong></p>\n<p>Reader 스레드 수가 0일때만 Writer가 세마포어를 획득할 수 있음, Writer는 1개의 스레드만 실행할 수 있다.</p>\n<p>일반변수:</p>\n<ul>\n<li>readCount: 읽기스레드의 개수입니다. 만약 1→0이 되면 쓰기 스레드가 접근할 수 있도록 바꿔주고, 0→1이되면 쓰기 스레드를 사용할 수 없도록 잠궈줍니다.</li>\n</ul>\n<p>세마포어:</p>\n<ul>\n<li>wMutex [1, 0] : 쓰기 스레드가 1개까지 동작할 수 있습니다.</li>\n<li>rsync [1, 0]: 읽기 스레드가 readCount를 수정합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token expression\">Reader's Code</span></span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>        # 읽기 스레드 카운트를 증가하고<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>이라면 wMutex <span class=\"token operator\">-></span> <span class=\"token number\">0</span>\nreadCount<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">if</span> readCount <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span>Read Data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>    # Reader는 별도의 Mutex 필요없이 여러 스레드가 실행되어도 된다<span class=\"token punctuation\">.</span>\n\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>        # 읽기 스레드 카운트를 줄이고<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>이라면 wMutex<span class=\"token operator\">-></span> <span class=\"token number\">1</span>\nreadCount<span class=\"token operator\">-=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">if</span> readCount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token expression\">Writer's Code</span></span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span>Write Data<span class=\"token punctuation\">]</span>\n\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위같이 세마포어를 활용해 독자-저자 문제를 해결할 수 있습니다. readCount와 wMutex를 수정하는 작업만 배타적으로 실행되면 됩니다.</p>\n<p>하지만 Reader가 계속해 추가된다면 Writer가 Starvation에 빠져, 실행될 수 없다는 문제점이 있습니다.</p>\n<p>이외에도 Writer를 우선하는 방법과 공평하게 분배하는 알고리즘이 있습니다.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">EN wiki 참고: wiki/Readers–writers_problem</a></p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">EN wiki 참고: wiki/Readers–writers_problem</a></p>\n<p>OSTEP: Operating Systems: Three Easy Pieces - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=CitsUz-Dx7A&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=16\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=CitsUz-Dx7A&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=16</a></p>","fields":{"slug":"os-독자-저자문제와-생산자-소비자-문제-및-해결"},"frontmatter":{"title":"OS 독자/저자문제와 생산자/소비자 문제 및 해결","date":"04.16.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}},"pageContext":{"slug":"os-독자-저자문제와-생산자-소비자-문제-및-해결","prev":{"excerpt":"앞서 TAS를 통한 Atomic한 락 설정 방법을 공부했습니다. Atomic한 락 설정을 통해 Preemption으로 인한 이상현상 없이 임계구역을 보호하기 위해 운영체제는 몇가지 방법들을 사용합니다. 세마포어 세마포어란, 다익스트라가 제안한 알고리즘으로, Busy Waiting으로 인한 성능저하 문제를 해결합니다. 기본적인 동작방법 세마포어는 세마포어변수 S와 P,V연산으로 이뤄집니다. 세마포어 변수인 S…","html":"<p>앞서 TAS를 통한 Atomic한 락 설정 방법을 공부했습니다. Atomic한 락 설정을 통해 Preemption으로 인한 이상현상 없이 임계구역을 보호하기 위해 운영체제는 몇가지 방법들을 사용합니다.</p>\n<h1 id=\"세마포어\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\" aria-label=\"세마포어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어</h1>\n<p>세마포어란, 다익스트라가 제안한 알고리즘으로, Busy Waiting으로 인한 성능저하 문제를 해결합니다.</p>\n<p><strong>기본적인 동작방법</strong></p>\n<ol>\n<li>세마포어는 세마포어변수 S와 P,V연산으로 이뤄집니다.\n<ol>\n<li>세마포어 변수인 S변수는 공유자원에 접근할 수 있는 자원의 개수를 의미합니다.</li>\n<li>P연산은 임계구역에 접근하기 전 진입가능한지를 검사하며, 가능하지 않다면 Wait Queue에 들어갑니다.</li>\n<li>V연산은 임계구역에서 나올 때 사용합니다. S변수를 원복하고, Wait Queue에서 임계구역으로 진입하려는 프로세스를 깨웁니다.</li>\n</ol>\n</li>\n<li>각 P,V연산은 하나의 instruction cycle에서 수행되어 Interrupt로 인해 끊기지 않습니다. (이를 Indivisable, 또는 Atomic하다고 합니다.)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">Init</span><span class=\"token punctuation\">(</span>initS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tS <span class=\"token operator\">=</span> initS\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> S <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n\tS<span class=\"token operator\">-=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">else</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> Waiting Process in Queue<span class=\"token operator\">:</span>\n\t\t<span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> # 다른 프로세스가 임계구역으로 접근하므로<span class=\"token punctuation\">,</span> S변수는 그대로<span class=\"token operator\">!</span>\n\t<span class=\"token keyword\">else</span><span class=\"token operator\">:</span>\n\t\tS<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">P</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\">//Critical Section</span>\n\t<span class=\"token function\">V</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>세마포어의 특징: 임계구역 제한방식의 차이</strong></p>\n<p>Busy Waiting와과 Sleep-Wakeup을 통한 임계구역 제한에는 분명한 차이가 있습니다.</p>\n<p>프로세스와 상태변화(<a href=\"https://blog.mglee.dev/blog/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.mglee.dev/blog/프로세스의-개념과-상태-변화/</a> 참고)에 대해 이해하고 있어야합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/65ab6312-f58f-4a4b-b8ed-7d49180d44d0\" alt=\"1\"></p>\n<p>Semaphore의 <strong>Sleep-Wakeup에서는 블로킹된 프로세스는 CPU를 잡아먹지 않습니다.</strong></p>\n<ul>\n<li>Sleep을 하면 프로세스의 상태가 Running → Asleep(이하 Waiting)상태가 됩니다.</li>\n<li>Wakeup동작은 프로세스 상태를 Waiting → Ready로 바꿔줍니다. (But, 이 과정은 순서를 보장하지 않아, 공정성 문제가 발생합니다)</li>\n</ul>\n<p><strong>Spin Lock 방식은 블로킹된 프로세스가 CPU를 점유하며 아무동작도 하지 않습니다.</strong></p>\n<ul>\n<li>블로킹된 프로세스는 Ready ↔ Running상태를 오가며 락을 획득할때까지 기다립니다.</li>\n</ul>\n<p><strong>Busy Waiting Vs Sleep Wakeup ?</strong></p>\n<p>Sleep Wakeup 방법에서는 락을 획득하지 못해 대기하는 스레드가 Running state로 들어가는 일이 없으므로, Blocking으로 인한 CPU IDLE상태가 되지 않습니다. 따라서 <strong>일반적으로 성능이 더 좋은 Sleep-Wakeup방식을 사용합니다.</strong></p>\n<p><strong>이진 세마포어와 카운팅 세마포어</strong></p>\n<p>세마포어에는 이진 세마포어, 카운팅 세마포어로 나뉩니다.</p>\n<p><strong>이진 세마포어는</strong> 세마포어변수가 1이므로, 하나의 스레드만 임계구역에 접근할 수 있어 임계구역에 대한 상호배제를 지켜주기 때문에, Mutex라고도 불립니다. (Mutual Exclusion의 약자)</p>\n<p><strong>카운팅 세마포어는</strong> S(>1)개의 스레드가 임계구역에 접근할 수 있습니다. 카운팅 세마포어는 그 자체만으로 상호배제를 달성하지는 못합니다. 그러나 카운팅 세마포어를 적절히 사용하면 운영체제에서 발생하는 여러 동시성 문제를 해결할 수 있습니다. (Producer/Consumer 문제, 식사하는 철학자 문제 등)</p>\n<h3 id=\"세마포어-summay\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-summay\" aria-label=\"세마포어 summay permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어: Summay</h3>\n<ul>\n<li>세마포어는 Busy Waiting으로 인한 성능 저하를 해결한 동시성 제어 방법입니다.</li>\n<li>P를 통해 세마포어변수 S(S>0)를 줄여 락을 획득,임계구역으로 접근하고</li>\n<li>V를 통해 S를 증가, 락을 반납하고 Wait상태의 스레드를 깨워주고 임계구역에서 나갑니다.</li>\n<li>S==0일 때, 임계구역에 진입할 수 없어  Blocking된 스레드는 Wait상태에 접어들고, 다른 스레드의 V연산을 통해 Wakeup 합니다.</li>\n<li>Counting Semapore는 세마포어변수가 1보다 커, 많은 스레드가 접근할 수 있고, S를 접근가능한 스레드 수로 정의했을 때, 상호배제가 지켜지지 않습니다. 하지만 아래와 같이 다양한 용도로 사용할 수 있습니다.\n<ul>\n<li>이는 실행하는 스레드 수를 제한하는 Thread Throttling에 사용됩니다.  세마포어 변수를 통해 S개를 초과하는 스레드에 대해 Blocking해주면, 자주 사용되는 페이지 집합이 메모리 크기를 초과해 발생하는 Thrashing을 방지할수도 있고, 과도한 Context Switch로 인한 캐시 미스도 방지할 수 있습니다.</li>\n<li>다음 글에서 소개할 Producer/Consumer 문제에서 Buffer의 사용량을 체크하는 용도로 사용되기도 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><strong>OSTEP: Operating Systems: Three Easy Pieces</strong> - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><strong>HPC Lab. KOREATECH, OS Lecture-</strong> <a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></p>","id":"9d4c2b85-54e2-5814-917e-23580010455f","fields":{"slug":"운영체제-세마포어-원리"},"frontmatter":{"date":"2023-04-02","title":"운영체제 세마포어 원리","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},"next":{"excerpt":"데드락이란? 할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태 프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다. DeadLock drawio 운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래…","html":"<p><strong>데드락이란?</strong></p>\n<p>할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태</p>\n<p>프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/c99a815a-150e-4ba7-b500-9f8be5e5c88d\" alt=\"DeadLock drawio\"></p>\n<p>운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래 <strong>4가지 조건이 모두 충족</strong>되어야만 데드락이 발생함을 보였습니다.</p>\n<ol>\n<li>상호배제. Mutual Exclusion: 두 개의 프로세스가 필요로 하는 자원을 배타적으로 점유해야 한다.</li>\n<li>비선점. Non Preemption: 프로세스의 실행중, 다른 프로세스가 자원의 점유를 빼앗을 수 없다.</li>\n<li>점유 대기. Hold and Wait: 할당된 자원을 가진 상태로 다른 자원을 기다린다.</li>\n<li>환형 대기. Circular Wait: 여러 프로세스가 순환적으로 자원 할당을 기다린다.</li>\n</ol>\n<p><strong>데드락 예방 방법</strong></p>\n<p>그러므로, 데드락을 <strong>예방</strong>하는 방법은 위 네 가지중 한가지를 부정해주면 됩니다.</p>\n<ol>\n<li>상호배제조건 제거: 자원을 배타적으로 점유하는 조건을 제거, 자원 공유\n<ol>\n<li>락을 사용하지 않았을 때의 문제점이 그대로 발생한다.</li>\n</ol>\n</li>\n<li>비선점 조건 제거: 자원의 할당을 선점해올 수 있도록 방법 제공\n<ol>\n<li>구현이 매우 복잡해지며, 성능 오버헤드가 발생한다.</li>\n</ol>\n</li>\n<li>점유대기 제거: 프로세스의 시작시점에 필요한 모든 자원을 요청한다\n<ol>\n<li>사용하지 않는 자원을 점유하고있는 비용과, 기아상태로 인한 무한대기가 발생한다.</li>\n</ol>\n</li>\n<li>환형대기 제거: 자원을 선형으로 분류해 순서를 매기고, 증가하는 순서로만 자원을 요청.  (TODO Check 필요)\n<ol>\n<li>가장 현실적인 방법. 이것마저도 꽤 큰 성능 오버헤드 발생</li>\n</ol>\n</li>\n</ol>\n<p><strong>데드락 회피 방법</strong></p>\n<p>또, 데드락은 <strong>회피방법이</strong> 존재합니다. 예방방법과 달리, 운영체제가 실행중에 동작하는 방법이기에 회피방법이라 부릅니다.</p>\n<p>교착상태가 발생할 수 있는 자원 할당을 피하고, 안전한 상태에서만 자원 할당을 하는 방법입니다.</p>\n<p>앞선 예방방법에서도 비용 및 성능 오버헤드로 인한 한계점을 보았듯, 회복 방법 역시 태생적 한계점이 존재합니다.</p>\n<ol>\n<li>운영체제가 프로세스의 최대 자원 할당 수를 알고있어야 하고,</li>\n<li>프로세스의 수가 고정되어야 합니다 ( Process Create X )</li>\n<li>자원의 종류와 숫자가 고정되어야 합니다.</li>\n</ol>\n<p><strong>Banker’s Algorithm</strong></p>\n<p>TODO<strong>안전하지 않은 순서에 대한 예제 체크, 예시 고치기</strong></p>\n<p>다익스트라가 제안한것으로 유명한 은행원 알고리즘은, 대표적인 데드락 회피 방법입니다.</p>\n<p>프로세스와 프로세스의 최대 할당 자원, 현재 할당 자원을 알고있을 때, 최대 할당자원을 넘어가지 않는 안전순서열을 만들어 자원을 할당하는 방법입니다.</p>\n<p>운영체제는 총 14개의 자원을 갖고있다고 가정하겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Process</th>\n<th>최대 할당 자원 수</th>\n<th>현재 할당 자원 수</th>\n<th>필요한 자원 수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>12</td>\n<td>5</td>\n<td>7</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>C</td>\n<td>5</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>현재 할당된 자원 수는 12개입니다. 가용 자원 수는 4개입니다.</li>\n<li>C에 1개의 자원을 할당해 실핼시키고, C가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 8개입니다. (4 -1 + 5)</li>\n<li>B에 자원 4개를 할당해 실행시키고, B가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 9개입니다 ( 8 - 4 + 5)</li>\n<li>A에 7개의 자원을 할당하고, 모든 프로그램을 종료합니다.</li>\n</ol>\n<p>자원을 안전하게 분배할 수 있는 순서는 C → B → A가 유일합니다. (Safe Sequence)</p>\n<p>안전순서열로 보장된 실행순서로 프로세스를 실행하면 데드락을 회피할 수 있으며, 안전하지 않은 상태에서의 실행은 데드락이 발생할 수 있는 확률이 있음을 의미합니다.</p>\n<p>은행원 알고리즘은 하나의 종류의 자원이 여러개 필요하다고 가정하고 시작한다는 한계가 있습니다. 사용된다고 하더라도, 프로세스 스케줄링 루틴은 자주 일어나는 작업인데, 낮은 빈도로 발생하는 데드락을 위해 스케줄링 과정에 프로세스를 감시해야 하므로 높은 오버헤드가 존재합니다.</p>\n<p><strong>데드락 탐지 및 복구방법</strong></p>\n<p>데드락 탐지 및 복구방법은 운영체제가 실행중에 동작하는 방법인것은 회피방법과 같지만, 이 방법은 데드락이 발생 후 처리하는 방식이라는 차이점이 있습니다.</p>\n<p>먼저, 어떤 프로세스가 데드락 상태인지 판별하기 위해 Resourse Allocation Graph를 탐색해 데드락 상태인 프로세스를 탐지합니다. 이는 RAG의 자원 대기를 나타내는 그래프의 사이클을 판별하면 됩니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/9c9597e1-5c08-4225-a435-27f3e797cad0\" alt=\"2\"></p>\n<p><em>이미지 출처: <a href=\"https://velog.io/@jerry92/OS-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9Cdeadlock%EC%9D%98-%EC%A1%B0%EA%B1%B4%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@jerry92/OS-교착상태deadlock의-조건과-해결-방법</a></em></p>\n<p>사이클 내에 존재하는 프로세스는 아래 두 가지 방법중 하나로 데드락에서 탈출해야 합니다.</p>\n<ol>\n<li>\n<p>프로세스 중단: 사이클에 속하는 하나 이상 또는 전체 프로세스를 중단합니다. 전체 프로세스를 중단하는것은 대규모 작업이 될 수도 있고, 연관된 다른 프로세스까지 종료하게 된다면, 작업 손실이 발생할 수도 있습니다.</p>\n<p>이에 프로세스 age나 우선순위 등을 고려해 한개씩 삭제하는게 좋습니다.</p>\n</li>\n<li>\n<p>자원 선점: 교착상테에 놓인 자원을 선점할 때까지 프로세스의 자원을 다른 프로세스가 선점하도록 하므로써 데드락을 탈출합니다.</p>\n</li>\n</ol>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>OSTEP: Operating Systems: Three Easy Pieces - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C%5D(https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)\">Wikipedia, Deadlock</a></p>\n<p><a href=\"%5Bhttps://en.wikipedia.org/wiki/Deadlock%5D(https://en.wikipedia.org/wiki/Deadlock)\">Eng Wikipedia, Deadlock</a></p>","id":"d025e9b6-ba19-5963-9469-e8cf4cca48a4","fields":{"slug":"운영체제-데드락과-예방-회피-복구"},"frontmatter":{"date":"2023-04-16","title":"운영체제 데드락과 예방,회피,복구","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2}}},"staticQueryHashes":[],"slicesMap":{}}