{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/기본-cpu-스케쥴링-fcfs-sjf-srtf-rr/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h3>\n<p>스케쥴링이란, CPU 자원을 계획에 따라 여러 프로세스에게 나누어주는 방법입니다. 여러가지 스케쥴링 항목에 대해 공부하기 전에, 왜 스케쥴러를 사용하는지에 대해 생각하면 더 편하게 이해할 수 있습니다.</p>\n<p>앞서 공부한 프로세스의 상태 중, CPU를 할당받기 위해 <strong>Ready → Running</strong> 상태의 전이를 담당하는것이 스케쥴링입니다. 그래서 기본적으로 Ready Queue에 여러 프로세스가 대기중이고, 스케쥴링 정책은 이 큐에 있는 프로세스를 어떻게 실행할지에 대한 이야기라고 생각하면 됩니다.</p>\n<p>운영체제는 목적에 따라 여러 종류가 있습니다. 대화형 시스템, 배치 시스템 등..</p>\n<p>대화형 시스템에서는 CPU의 활용성이 조금 떨어지더라도 유저의 요청에 <strong>반응하는 시간</strong>이 빨라야하고,</p>\n<p>대규모 데이터를 처리하는 배치 시스템에서는 응답시간보다는 <strong>처리량</strong>이 우선일 것입니다.</p>\n<p>응답시간, 처리량같이 운영체제별로 스케쥴링의 목적이 있고, 이외에도 공평성, 무한대기 방지, 활용률 등 다양한 평가항목이 있어, 스케쥴링 알고리즘을 선택할 때 고려해야 합니다.</p>\n<h3 id=\"스케쥴링-성능평가-용어-정리\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%84%B1%EB%8A%A5%ED%8F%89%EA%B0%80-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC\" aria-label=\"스케쥴링 성능평가 용어 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 성능평가 용어 정리</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093035-ef33201e-3ca0-4f2b-b94a-d3414eb4bc3c.png\" alt=\"1\"></p>\n<ul>\n<li><strong>Response Time, 응답시간 / T(response) - T(arrival) :</strong> 레디큐에 도착해 처음으로 스케쥴될때까지 걸린 시간</li>\n<li><strong>Waiting Time, 대기시간 / T(sum of waiting) :</strong> 레디큐에 도착해 running이 되기까지 걸린 시간의 합\n<ul>\n<li><strong>응답시간은 Ready Queue도착에서 첫 스케쥴까지 걸린시간, 대기시간은 프로세스가 종료되기까지 Ready Queue에 있는 시간의 총 합을 의미합니다.</strong></li>\n</ul>\n</li>\n<li><strong>Burst Time, 실행시간 / T(completion) - T(start)</strong> : CPU를 할당받아 실행한 시간</li>\n<li><strong>Turnaround Time, 반환시간 / T(completion)- T(arrival) :</strong> 레디큐에 도착해 작업을 완료하기까지 걸린 시간</li>\n</ul>\n<p>위와 같은 기준들로 <strong>“성능”</strong> 을 평가할 수 있으며, 여러 프로세스가 번갈아가며 실행하므로, 일반적으로는 반환시간 또는 대기시간의 <strong>평균</strong>을통해 스케쥴링의 적합성을 판단합니다.</p>\n<p>또한, <strong>공정성</strong>도 중요한 평가요소 중 하나입니다. 스케쥴링 방법을 공부하다보면 알겠지만, 일반적인 경우 처리량과 공정성은 등가교환 관계이기 때문에 주의해야 합니다.</p>\n<h2 id=\"스케쥴링-방법들\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EB%B0%A9%EB%B2%95%EB%93%A4\" aria-label=\"스케쥴링 방법들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 방법들</h2>\n<p><strong>먼저 알고가야 할것. 선점형 vs 비선점형</strong></p>\n<p>유저 이벤트로 인한 프로세스 시작이나 I/O 종료 인터럽트로 인해 Ready Queue에 다양한 프로세스들이 들어옵니다.</p>\n<p>이 때, 새로운 프로세스가 즉시 CPU 할당을 받아서(뺏어와서) 실행할 수 있는 스케쥴링 종류를 선점형(Preemitive), 그렇지 않고 해당 프로세스의 Burst Time이 끝나는것을 기다려하는 스케쥴링 종류를 비선점형(Non-Preemitive)라고 합니다</p>\n<h3 id=\"fcfs-또는-fifo-알고리즘\" style=\"position:relative;\"><a href=\"#fcfs-%EB%98%90%EB%8A%94-fifo-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"fcfs 또는 fifo 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FCFS (또는 FIFO) 알고리즘</h3>\n<p>First Come First Service (First In First Out) 즉, 선착순/선입선출 알고리즘입니다. Ready Queue에 들어온 순서대로 CPU를 할당해줍니다. 비선점형 스케쥴링 알고리즘입니다</p>\n<p>일상생활에서는 공평하게 처리하기 위해 자주 사용되는 알고리즘입니다. 매우 간단하고 얼핏보면 공평해보이지만, 아래의 경우를 확인해보면 비효율적인 알고리즘인걸 알 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>70</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>만약 A,B,C가 거의 동시에 도착해 A,B,C순으로 처리한다고 할 때, 평균 반환시간을 체크해보면</p>\n<p><strong>Average Turnaround Time : (60 + 70 + 80) /3  = 70</strong>  으로, 굉장히 비효율적입니다.</p>\n<p>라면 하나를 사려고 계산대에 줄을 섰는데, 앞에서 엄청 많은 물건을 계산하고있는 상황을 생각해보면 편할겁니다.</p>\n<p>이처럼 짧은 시간동안 자원을 사용하는 프로세스가 오랜 시간동안 할당을 기다려야 하는 현상을 <strong>Convoy Effect</strong>라고 합니다.</p>\n<h3 id=\"sjf-알고리즘--non-preemitive\" style=\"position:relative;\"><a href=\"#sjf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98--non-preemitive\" aria-label=\"sjf 알고리즘  non preemitive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF 알고리즘 / Non Preemitive</h3>\n<p>Shortest Job First 즉, 짧은 작업을 우선해서 처리하는 알고리즘입니다.</p>\n<p>비선점형으로 동작하는 경우부터 살펴보겠습니다.</p>\n<p>FCFS에서는 실행시간이 짧은 프로세스가 앞서 실행되는 긴 프로세스의 실행을 기다려하는 Convoy Effect가 문제였습니다.</p>\n<p>SJF에서는 레디큐에 있는 Job들 중, <strong>짧은것을 우선적으로 실행</strong>합니다.</p>\n<p>마트에서 줄이 짧은 사람을 먼저 계산하게 해줍니다!</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>B</th>\n<th>C</th>\n<th>A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>10</td>\n<td>10</td>\n<td>60</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>10</td>\n<td>20</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>앞선 FIFO의 예시입니다. A,B,C가 동시에 도착하면  B,C가 먼저 스케쥴되어 반환시간을 계산하면</p>\n<p><strong>Average Turnaround Time :(10+20+80) / 3  = 36.6</strong> , 반환시간이 절반정도로 줄어든걸 확인할 수 있습니다.</p>\n<p><strong>SJF 문제점</strong></p>\n<p>비선점형이라는 것을 고려하면 아래와 같이 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093037-73ffbddf-8875-4583-81d7-03c9aaf5c377.png\" alt=\"2\"></p>\n<p>B,C는 time:10에 도착했으므로 이미 실행중인 A를 종료시키지 못하고, time:60까지 기다립니다. 이 경우 반환시간은</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>60</td>\n<td>70</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (60+60+70)/3 = 63.3으로, 앞선 FSFS와 큰 차이가 없습니다.</strong></p>\n<h3 id=\"srtf또는-sctf-알고리즘\" style=\"position:relative;\"><a href=\"#srtf%EB%98%90%EB%8A%94-sctf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"srtf또는 sctf 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRTF(또는 SCTF) 알고리즘</h3>\n<p>SRTF: Shortes Remaining Time First (= SCTF: Shortest Time to Completion First)는 <strong>최소 잔여시간이 적은 프로세스를 선점형으로 실행</strong>하는 알고리즘입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093039-804b66a5-2dee-48b4-985d-ad66c1171e54.png\" alt=\"3\"></p>\n<p>앞선 SJF와 비교해보면 B,C가 도착한 time: 10시점에 <strong>더 짧게 남은 잡을 계산해 CPU를 선점한다는걸 확인할 수 있습니다</strong>.</p>\n<p>이 경우 반환시간을 계산해보겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>80</td>\n<td>20</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (80+20+30)/3 = 43.3으로, B,C가 늦게 도착한 경우에 평균 반환시간을 개선할 수 있었습니다.</strong></p>\n<p><strong>SRTF 문제점</strong></p>\n<p><strong>SRTF에도 공정성, 응답시간 측면에서 문제점이 있습니다.</strong></p>\n<p>만약 실행시간이 10인 프로세스가 레디 큐에 계속 들어온다면, 남은 실행시간이 20인 프로세스는 CPU를 할당받지 못하는 상태가 되고(Starvation), 응답시간이 계속 늘어납니다.</p>\n<p>또한 <strong>운영체제는 Ready Queue에 있는 프로세스의 실행시간을 알지 못합니다.</strong></p>\n<h3 id=\"round-robin-알고리즘\" style=\"position:relative;\"><a href=\"#round-robin-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"round robin 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Round Robin 알고리즘</h3>\n<p>Round Robin알고리즘은 일정 Time Quantum을 기점으로 Ready Queue에 있는 모든 프로세스들에게 공정하게 실행시간을 배분해주는 알고리즘을 말합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093040-38af8a4a-e01d-4f0b-a85e-62aa5b91541e.png\" alt=\"4\"></p>\n<p><strong>문제점 해결</strong></p>\n<p>해당 방식으로 실행하면 SRTF에서 실행시간이 많이 남은 프로세스가 CPU를 계속 할당받지 못하는 공평성 문제가 해결되고, 응답시간이 대폭 개선됩니다.</p>\n<p><strong>특징</strong></p>\n<p>대화형 시스템에 적합합니다.</p>\n<p>새로 Ready상태가 되거나 실행시간을 마친 Job은  Ready Queue의 <strong>맨 뒤로</strong> 갑니다.</p>\n<ul>\n<li>A가 실행되고 나서 C가 Ready상태가 되었다면,  …. → A → C 순으로 실행됩니다.</li>\n<li>반대로 C가 Ready Queue에 도착하고 A의 실행이 끝난다면, …→ C → A 순으로 실행됩니다.</li>\n</ul>\n<p><strong>새로운 문제점</strong></p>\n<p>평균 반환시간 관점으로 보았을 때, 최악의 알고리즘입니다.</p>\n<p>또한 적절한 Time Quantum을 설정해야합니다. 잦은 Context Switch는 성능 저하를 불러옵니다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>반환시간, 응답시간, 공평성은 등가교환 관계입니다.</p>\n<p>SJF, SRTF는 반환시간이 개선되지만 응답시간, 공정성 측면에서는 비효율적이고</p>\n<p>RR의 경우 응답시간과 공평성은 해결했지만 반환시간이 비효율적입니다.</p>\n<p>뒤이어 배울 MLFQ등을 통해 각각의 장점을 절충하는 스케쥴러의 동작을 공부해보겠습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\"></a></strong>)**</p>","fields":{"slug":"기본-cpu-스케쥴링-fcfs-sjf-srtf-rr"},"frontmatter":{"title":"기본 CPU 스케쥴링 [ FCFS, SJF, SRTF, RR]","date":"02.14.2023","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3}},"pageContext":{"slug":"기본-cpu-스케쥴링-fcfs-sjf-srtf-rr","prev":{"excerpt":"프로세스의 개념 프로세스는 프로그램이 실행중인 상태 라고 정의합니다. 프로그램 자체는 디스크에 적재되어있는 상태로, 아무런 동작을 하지 않습니다. 프로그램이 메모리에 적재되고, CPU를 점유해 사용하는 주체를 “프로세스”라고 합니다. 조금 더 구체적으로는 아래와 같이 정의할 수 있습니다. 커널에 등록되고 커널의 관리 하에 있는 작업 → 프로세스 관리 블록(PCB)을 할당받은 프로그램 각종 자원을 요청하고 할당받을 수 있는 개체 CPU…","html":"<h3 id=\"프로세스의-개념\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\"프로세스의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 개념</h3>\n<p>프로세스는 <strong>프로그램이 실행중인 상태 라고 정의합니다.</strong></p>\n<p>프로그램 자체는 디스크에 적재되어있는 상태로, 아무런 동작을 하지 않습니다. 프로그램이 메모리에 적재되고, CPU를 점유해 사용하는 주체를 “프로세스”라고 합니다.</p>\n<p>조금 더 구체적으로는 아래와 같이 정의할 수 있습니다.</p>\n<ul>\n<li>커널에 등록되고 커널의 관리 하에 있는 작업\n<ul>\n<li>→ <strong>프로세스 관리 블록(PCB)을 할당받은 프로그램</strong></li>\n</ul>\n</li>\n<li>각종 자원을 요청하고 할당받을 수 있는 개체</li>\n</ul>\n<h3 id=\"cpu-가상화와-프로세스--이건-cpu-가상화에-대한-설명\" style=\"position:relative;\"><a href=\"#cpu-%EA%B0%80%EC%83%81%ED%99%94%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4--%EC%9D%B4%EA%B1%B4-cpu-%EA%B0%80%EC%83%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85\" aria-label=\"cpu 가상화와 프로세스  이건 cpu 가상화에 대한 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 가상화와 프로세스 → 이건 CPU 가상화에 대한 설명..</h3>\n<p>이런 “프로세스”는 실제 맥이나 윈도우같은 운영체제를 사용하면서 확인할 수 있는데, 한눈에 봐도 우리는 수십개의 프로그램을 동시에 사용할 수 있다는것을 알 수 있습니다. 마치 <strong>프로그램 하나가 CPU하나를 점유하듯</strong>, 노래를 들으며 워드를 사용하고, 백신 프로그램을 돌리는 등, 여러가지 작업을 한번에 수행 할 수 있죠.</p>\n<p>이것은 모두 “<strong>CPU 가상화</strong>”에 기초합니다. 운영체제는 “<strong>시분할</strong>”을 통해 여러 프로세스가 하나의 CPU를 나눠 사용할 수 있도록 합니다.</p>\n<p>또한 운영체제는 **과거 정보( 자주 실행된 프로그램, 실행된 프로그램의 유형)**과 **목적(처리량, 응답시간)**을 바탕으로 어떤 프로세스가 언제 CPU를 사용할지에 대한 “<strong>스케쥴링 정책</strong>”을 가지고있습니다.</p>\n<p>위같은 정책이나 시분할 기법은 프로세스가 온전히 하나의 CPU를 사용하는것”처럼” 하게 해주며, 이를 가상화 라고 부릅니다.</p>\n<h3 id=\"컴퓨터-구조와-프로세스\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"컴퓨터 구조와 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴퓨터 구조와 프로세스</h3>\n<p>프로세스의 실행을 조금 더 가까이에서 살펴보겠습니다. 메모리와 CPU사이에 캐시, MMU, 레지스터 등 다양한 주변기기가 있지만, 설명에서는 생략합니다.</p>\n<p>앞서 프로세스의 “실행”은 시분할과 이를 제어하는 스케쥴링 기법을 통한 CPU 가상화를 통해 이뤄진다고 말씀드렸습니다. 우리가 program.c로 작성해 program.exe파일로  컴파일된 <strong>“파일” 이 어떻게 실행중인 “프로세스”로 변경</strong>되는지 이해하기 위해서는 아래 그림에 대한 설명이 필요합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226092562-a562242a-d948-46cd-8b5e-d68edcd3d0c0.png\" alt=\"1\"></p>\n<p>프로그래머가 작성한 소스코드는 파일로 저장되며, 언어에 따라 컴파일을 통해 실행 프로그램으로 변경됩니다.</p>\n<p>변경된 프로그램은 실행 시 메인 메모리에 적재되고, 프로그램 코드와 정적 데이터를 저장하며 <strong>실행중 사용할 수 있는 공간인 스택과 힙을 할당</strong>받아 명령어에 필요한 데이터를 사용하거나 명령어를 수행한 결과를 저장합니다.</p>\n<p>사실. 밑에서 공부할 프로세스의 상태에서는 CPU,Memory등을 할당받지 못한(Swap된) 상태도 있기때문에, 메모리에 적재된 프로그램만 프로세스라고 부르기에는 애매합니다. PCB도 조금 이따 볼거지만, “<strong>커널에 PCB가 저장된 프로그램</strong>”을 프로세스로 보시는게 더 정확합니다.</p>\n<p>여기서 중요한 개념 중 하나인 <strong>메모리 가상화</strong>가 등장합니다.</p>\n<p>메모리 가상화는 많은 역시 “<strong>많은프로세스가 자신의 독립된 주소 공간을 갖는것처럼 행동</strong>\"할 수 있도록 해주며, MMU가 실제 주소와 가상 주소를 저장한 테이블을 통해 변환해 각각의 프로세스가 주소공간을 서로 침범하지 않고 독립적으로 실행됩니다.</p>\n<p>(컴퓨터구조 여담)</p>\n<p>위 그림에서 왼쪽이 CPU와 고속처리장치(메모리컨트롤러, GPU, PCI 16x)들을 담당하는 노스브릿지(North Bridge), 오른쪽에서 메모리 아랫쪽이 저속처리장치(디스크, PCI 1x, USB, SATA 등)를 담당하는 사우스브릿지(South Bridge)인데, 주변장치와 데이터 버스를 통해 처리되던 노스브릿지 장치들이 CPU로 통합되면서 최신 CPU에는 노스브릿지 영역이 없는 형태의 CPU가 대부분이라고 합니다.</p>\n<h2 id=\"프로세스-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C\" aria-label=\"프로세스 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 상태</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226092567-88d743d6-7d8e-483b-b183-c352a67b440b.png\" alt=\"2\"></p>\n<p>프로세스는 “스케쥴링 정책”을 통해 CPU와 메모리를 할당받는지 여부에 따라 아래와 같은 상태를 갖습니다.</p>\n<ul>\n<li><strong>Created:</strong> 커널에 PCB가 할당되고, <strong>가용 메모리공간을 체크해 Ready상태 또는 Suspend-Ready상태로 전이</strong>합니다.</li>\n<li><strong>Ready</strong>: 프로세서(CPU) 할당을 대기하는 상태로, 즉시 실행 가능한 상태입니다.\n<ul>\n<li><strong>Schedule(또는 dispatch)</strong>: 스케쥴링 정책에 의해 Running상태로 전이합니다.</li>\n</ul>\n</li>\n<li><strong>Running</strong>:  프로세서를 포함해 필요한 자원을 모두 할당받아 동작하는 상태입니다.\n<ul>\n<li>timer run-out: Running상태의 프로세스가 스케쥴 계획에 있던 시간을 모두 버스트해 종료합니다.</li>\n<li><strong>Block/sleep:</strong> I/O자원할당을 위해 잠시 대기합니다.</li>\n</ul>\n</li>\n<li><strong>Asleep(Block)</strong>: I/O가 끝나기를 기다리는 상태입니다. 자원별로 Block-Queue를 가지며, 할당이 끝나기를 기다리는 프로세스가 큐에 있습니다.\n<ul>\n<li><strong>Wake up</strong>: 자원할당을 마치고 ready queue로 들어갑니다.</li>\n</ul>\n</li>\n<li><strong>Suspended State: 메모리를 할당받지 못하고, 디스크(Swap device)에 메모리 이미지를 저장한 상태</strong>\n<ul>\n<li>Swap in: 스왑 이미지를 메모리에 적재해 Ready 또는 Asleep 상태로 변경</li>\n<li>Swap out: 적재된 메모리  영역을 스왑 디바이스에 이미지로 저장</li>\n</ul>\n</li>\n<li><strong>Terminate:</strong> 프로세스 수행이 끝나 모든 자원 반납 후 PCB만 커널 내에 남아있는 상태입니다.\n<ul>\n<li>커널이 이후 비슷한 프로세스를 실행할 때, PCB정보를 참고한다고 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pcb를-통한-프로세스의-관리\" style=\"position:relative;\"><a href=\"#pcb%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B4%80%EB%A6%AC\" aria-label=\"pcb를 통한 프로세스의 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB를 통한 프로세스의 관리</h3>\n<p>PCB: Process Control Block - <strong>실행중인 프로그램(프로세스)들을 제어하는데 필요한 정보</strong>를 가지고있는 자료구조 입니다.</p>\n<p>시작/종료가 많은 프로세스의 특성 상 PCB 리스트 역시 삽입/삭제가 많은 데이터이므로,  <strong>커널 영역에서 LinkedList를 통해 관리됩니다.</strong></p>\n<ul>\n<li>PCB의 구성요소: 운영체제별로 다릅니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>구성요소</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PID: Process Identification Number</td>\n<td>프로세스를 고유하게 식별하는 번호</td>\n</tr>\n<tr>\n<td>스케쥴링 정보</td>\n<td>우선순위 등 스케쥴링을 위해 필요한 정보</td>\n</tr>\n<tr>\n<td>메모리 관리 정보</td>\n<td>할당된 페이지, 세그먼트에 대한 정보</td>\n</tr>\n<tr>\n<td>입출력상태 정보</td>\n<td>할당받은 입출력 장치</td>\n</tr>\n<tr>\n<td>문맥 저장 영역</td>\n<td>CPU 레지스터 저장, 문맥 교환 시 load/store하는 부분</td>\n</tr>\n<tr>\n<td>계정정보</td>\n<td>프로세스의 소유자</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>멀티프로세스보다 멀티스레드가 빠른 “실질적인” 이유</p>\n</blockquote>\n<p>프로세스 A의 실행정보라고 불리는 <strong>스택과 힙</strong>에 대해 이야기해봅시다. <strong>컴파일타임에 메모리를 할당받는 스택</strong>의 경우, 일반적으로 1MB를 사용하고 최대 10MB정도인 반면, <strong>힙영역은 런타임에 할당되고 최대 256MB</strong>또는 설정에 따라 메모리의 최대크기에 따라 더 커질수도 있습니다.</p>\n<p>프로세스 A의 PCB에는 A가 실행될 때의 레지스터 정보들을 가지고있습니다. 또한, CPU와 근접해있는 L1, L2캐시에도 프로세스 A의 실행정보들이 <strong>캐싱</strong>되어있습니다. 만약 프로세스 A가 B로 Context Switch할때는 레지스터 정보를 교체하겠지만, <strong>이후에는 L1,L2뿐만아니라 다른 캐시, 심지에 페이지 교체까지 일어납니다.</strong></p>\n<p>스레드의 경우는 어떨까요~? 스레드는 프로세스 내에서 독립적인 스택포인터(스택)을 갖지만, <strong>실행정보에 대부분을 차지하는 힙,코드,데이터영역을 공유합니다</strong>. 스레드의 정보를 저장한 TCB의 정보를 레지스터에 옮기는 시간은 있겠지만, 캐시,페이지 미스가 많이 일어나지 않기때문에, 훨씬 더 빠릅니다.</p>\n<p>+) 멀티스레드는 공유자원인 힙, 데이터에 대해 동시성 문제가 발생하므로, 동기화 문제를 꼭 핸들링해주어야 합니다!</p>\n<h3 id=\"키워드--질문-목록\" style=\"position:relative;\"><a href=\"#%ED%82%A4%EC%9B%8C%EB%93%9C--%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"키워드  질문 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>키워드 &#x26; 질문 목록</h3>\n<p>PCB어떤 자료구조로 관리되며, 왜 해당 자료구조를 사용하는지 설명해주세요</p>\n<p>프로세스의 상태와 각 상태별로 사용하고있는 자원의 종류에 대해 설명해주세요</p>\n<p>멀티프로세스보다 멀티스레드가 빠른 이유를 설명해주세요</p>\n<p>문맥교환영역에 저장되는 CPU 레지스터 종류?</p>\n<p>PC (Program Counter) : 다음 인출(Fetch) 될 명령어의 주소를 가지고 있는 레지스터</p>\n<p>AC (Accumulator) : 연산 결과 데이터를 일시적으로 저장하는 레지스터</p>\n<p>IR (Instruction Register) : 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터</p>\n<p>SR (Status Register) : 현재 CPU 의 상태를 가지고 있는 레지스터</p>\n<p>MAR (Memory Address Register) : PC 에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터</p>\n<p>MBR (Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.3 Process](</strong><a href=\"https://www.youtube.com/watch?v=jZuTw2tRT7w\">https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <strong>)</strong></p>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>이글은 꼭 이해하면 좋을것같다. 까먹으면 다시보자! → <a href=\"https://quasarzone.com/bbs/qn_hardware/views/818208\">https://quasarzone.com/bbs/qn_hardware/views/818208</a></p>","id":"96b52839-d38a-577a-a1f1-5a12ac062586","fields":{"slug":"프로세스의-개념과-상태-변화"},"frontmatter":{"date":"2023-02-06","title":"프로세스의 개념과 상태 변화","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},"next":{"excerpt":"OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다. 책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다. 제한된 직접실행 개요 먼저 Limited가 없는 직접 실행이라는 부분에 대해 알아보자면 , 운영체제가 프로그램의 실행에 관여하지 않고 CPU…","html":"<p>OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다.</p>\n<p>책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다.</p>\n<h2 id=\"제한된-직접실행-개요\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%ED%95%9C%EB%90%9C-%EC%A7%81%EC%A0%91%EC%8B%A4%ED%96%89-%EA%B0%9C%EC%9A%94\" aria-label=\"제한된 직접실행 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제한된 직접실행 개요</h2>\n<p>먼저 Limited가 없는 직접 실행이라는 부분에 대해 알아보자면 , 운영체제가 프로그램의 실행에 관여하지 않고 CPU는 사용자 코드에서 진입점을 찾아 직접 실행함을 의미합니다. 이 경우 몇가지 문제가 발생합니다.</p>\n<p>프로세서(CPU)가 프로세스로 자원을 나눠줄 때 고려해야할 부분으로 크게 세 가지 중요한 요소가 있습니다.</p>\n<ol>\n<li><strong>제어권</strong>: 운영체제가 <strong>CPU 및 자원에 대한 제어권을 가진 상태로 프로세스를 실행</strong>해야 합니다. 제어권을 상실할 경우 프로세스가 자원을 무기한 점유하는 상황이 발생할 수도 있기 때문이죠.</li>\n<li><strong>성능:</strong> CPU앞서 말했듯 CPU는 초당 처리속도가 다른 하드웨어 기기에 비해 월등히 빠릅니다. 메모리 또는 하드디스크에서 데이터를 가져오는동안 CPU는 정말 많은 시간을 기다려야하겠죠. <strong>운영체제가 이런 I/O작업을 하는 프로세스의 제어권을 뺏고 다른 프로세스를 실행해 CPU활용률을 극대화</strong>합니다.</li>\n<li><strong>자원 보호:</strong> 제한없이 실행되는 프로세스는 전체 디스크,메모리를 읽고 쓸 수 있으므로, 이 부분에 대한 제어가 꼭 필요하다 <strong>( System Call Interface를 통한 User/Kernal Mode 분기)</strong></li>\n</ol>\n<p>요약하자면, 다른 장치에 비해 빠른 CPU의 <strong>성능</strong>을 최대한 <strong>안전하게</strong> 활용하기 위해 운영체제가 CPU의 제어권을 갖는 개념을 Limited Directed Execution: 제한된 직접 실행이라고 합니다.</p>\n<p><strong>쉽게 말하자면</strong></p>\n<p>운영체제가 인터럽트를 통해 하드웨어 리소스에 대한 제어권을 가져올 수 있어야 “성능, 자원보호, 제어권 주도” 등의 이점을 가져올 수 있다는 이야기입니다.</p>\n<p>다른 장치에 비해 빠른 CPU의 <strong>성능</strong>을 최대한 <strong>안전하게</strong> 활용하기 위해 운영체제가 CPU의 제어권을 갖는 개념을 Limited Directed Execution: 제한된 직접 실행이라고 합니다.</p>\n<h3 id=\"인터럽트의-종류\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인터럽트의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 종류</h3>\n<p><strong>Hardware Inturrupt : 외부 기기 또는 사용자, 입/출력에 의한 불특정 시간에 발생해 Asynchronous Interrupt라고도 불립니다.</strong></p>\n<ul>\n<li>Clock Interrupt: 한 스레드가 프로세스를 과도하게 점유하는것을 막기 위해 지정된 시간마다 발생하는 인터럽트</li>\n<li>I/O Interrupt: 사용자의 입/출력(또는 예상치못한 외부 이벤트)에 의한 인터럽트</li>\n<li>Machine Check Interrupt: 기기 결함이 발견되었을 때 발생하는 인터럽트</li>\n</ul>\n<p><strong>Software Interrupt (or Trap, Synchronous Interrupt): SW의 예외 핸들링 또는 제어권을 얻기 위해 발생시키는 인터럽트입니다.</strong></p>\n<ul>\n<li>Supervisor Call(System Call Interrupt): 사용자 프로그램이 하드웨어 자원을 사용하기 위해 유저모드에서 커널모드로 들어갈 때 발생시키는 인터럽트.</li>\n<li>Program Check Interrupt: 0으로 나누기, 스택오버플로/언더플로같은 S.W Exception처리하는 인터럽트.</li>\n</ul>\n<h3 id=\"인터럽트의-실행과정\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95\" aria-label=\"인터럽트의 실행과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 실행과정</h3>\n<p>프로세스가 CPU의 제어권을 갖고있는 상태에서 제어권을 얻기 위해선 인터럽트를 통해 제어권을 뺏어와야 합니다.</p>\n<p>인터럽트 발생: MCU(또는 PIC)라는 장비에 IDT(인터럽트 종류, ISR위치, 우선순위)를 전달하면서 시작됩니다.</p>\n<p>→ <strong>(하드웨어)프로세스 중단</strong></p>\n<ul>\n<li>Context Saving 발생: CPU register를 <strong>커널 스택</strong>에 대피시킨다.</li>\n<li>커널모드로 이동.</li>\n</ul>\n<p>→ <strong>(운영체제)인터럽트 처리(Interrupt Handling)</strong></p>\n<ul>\n<li>인터럽트를 요청한 장치 또는 메모리 주소, 인터럽트의 원인을 확인하고 ISR 주소로 이동해 ISR을 실행한다.</li>\n</ul>\n<p><strong>인터럽트 서비스 루틴 실행</strong> : 예를들어 마우스로 음악 프로그램을 더블클릭 해 인터럽트가 발생했다면, 해당 프로그램을 프로세스 레디 큐에 등록하는 작업을 한다.</p>\n<p>→ <strong>(하드웨어)상태 복구: 커널 스택에 저장된 CPU레지스터들을 불러오고</strong>, 복구한 PC레지스터로 이동해 원래 프로세스 실행</p>\n<p>→ (프로그램): 복구한 PC레지스터부터 다시 실행하므로, 기존 실행시점에서 다시 동작합니다.</p>\n<h3 id=\"interrupt로-context-switch가일어나는-경우\" style=\"position:relative;\"><a href=\"#interrupt%EB%A1%9C-context-switch%EA%B0%80%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"interrupt로 context switch가일어나는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt로 Context Switch가일어나는 경우</h3>\n<p>만약 Timer Interrupt가 발생하고 그로인해 ISR에서 스케쥴러로 분기 →  Process A의 버스트 시간이 끝나 Ready상태로 바꾸는 상황을 가정해보겠습니다.</p>\n<p>(아직 스케줄러에 대해 배우지 않았지만 참고로, 스케쥴러 알고리즘은 매 타임 퀀텀마다, I/O로 인한 블록마다 동작하도록 ISR에 정의되어있습니다.  새로운 프로세스가 등록될때에도 비교를 위해 동작합니다. )</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093145-c874af7d-2608-4373-97ec-94798ef0ea46.png\" alt=\"Interrupt_And_ContextSwitch drawio\"></p>\n<p>인터럽트가 동작하는 구조는 같지만, 내부에서 동작하는 스케쥴링 처리로 인해 ISR이후 Process(j)로 실행됩니다.</p>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(i)를 중단하고 Process(i)실행시점의 <strong>레지스터를 커널 스택으로 대피</strong>합니다.</li>\n<li>커널모드로 변경합니다.</li>\n</ul>\n<p><strong>(운영체제의 Timer Interrupt에 대한 ISR 동작)</strong></p>\n<ul>\n<li>커널 스택에 있는 Process(i)의 레지스터를 Process(i)의 PCB에 저장해줍니다.</li>\n<li>j의 PCB에 저장된 Process(j)의 레지스터를 커널스택으로 옮깁니다.</li>\n<li>j프로세스의 실행주소(PC)로 return from trap합니다.</li>\n</ul>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(j)의 커널스택에 있는 레지스터를 CPU로 복구합니다.</li>\n<li>유저모드로 변경합니다.</li>\n</ul>\n<p><strong>(프로그램)</strong></p>\n<p>Process(j)를 실행</p>\n<h3 id=\"인터럽트의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"인터럽트의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 우선순위</h3>\n<p><strong>전원 이상(Power fail) > 기계 착오(Machine Check) > 외부 신호(External) > 입출력(I/O) > 명령어 잘못 > 프로그램 검사(Program Check) > SVC(SuperVisor Call)</strong></p>\n<p>만약 우선순위가 낮은 인터럽트를 수행하는 중에 우선순위가 높은 인터럽트가 발생하면 우선적으로 처리한 뒤 다시 낮은 순위의 ISR로 돌아가 처리합니다. (재귀적 우선순위 처리)</p>\n<h3 id=\"질문목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D\" aria-label=\"질문목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문목록</h3>\n<p>Interrupt, Trap, Exception의 차이를 시스템 관점에서</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.4 Process Management](</strong><a href=\"https://www.youtube.com/watch?v=jZuTw2tRT7w\">https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <strong>)</strong></p>\n<p>(sub reference)</p>\n<p><a href=\"https://raisonde.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8Interrupt%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98\">https://raisonde.tistory.com/entry/인터럽트Interrupt의-개념과-종류</a></p>\n<p><a href=\"https://justzino.tistory.com/4\">https://justzino.tistory.com/4</a></p>\n<p><a href=\"https://wiki.osdev.org/Interrupt_Service_Routine\">https://wiki.osdev.org/Interrupt_Service_Routine</a></p>\n<p>커널의 메모리구조 - <a href=\"https://kariskan.tistory.com/52\">https://kariskan.tistory.com/52</a></p>","id":"d18acb80-a184-5ffd-a668-8349d3729d5f","fields":{"slug":"인터럽트와-제한된-직접-실행"},"frontmatter":{"date":"2023-02-14","title":"인터럽트와 제한된 직접 실행","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3}}},"staticQueryHashes":[],"slicesMap":{}}