{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/운영체제-디스크와-raid/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"디스크와-raid\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%8A%A4%ED%81%AC%EC%99%80-raid\" aria-label=\"디스크와 raid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디스크와 RAID</h1>\n<p><strong>디스크(HDD)와 구성요소</strong></p>\n<p>Sector - 트랙 내에서 데이터 판독의 물리적 단위 (512 Byte)</p>\n<p>Track -  Platter에서 같은 거리만큼 떨어진 섹터 집합</p>\n<p>Cylinder - 같은 반지름을 갖는 트랙의 집합</p>\n<p>Platter - 데이터를 기록할 수 있는 자성물질로 이뤄진 원형 금속판</p>\n<p>Surface - Platter의 윗면,아랫면</p>\n<p>디스크 드라이브는, 디스크 축을 회전시키며 <strong>Positioner</strong>  <strong>암</strong>을 위치시켜,  <strong>Head</strong>가 데이터를 기록하고 읽는다.</p>\n<h3 id=\"raid-redundant-arrays-of-inexpensice-disks\" style=\"position:relative;\"><a href=\"#raid-redundant-arrays-of-inexpensice-disks\" aria-label=\"raid redundant arrays of inexpensice disks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RAID: <strong>Redundant Arrays of Inexpensice Disks</strong></h3>\n<p>직역하면 저성능 디스크의 중복 배열입니다. 여러 개의 디스크를 묶어 대용량으로 사용한다는 의미이며,운영체제와 RAID Controller의 제어를 받습니다.  RAID버전에 따라 안정성과 성능(Access Speed)을 고려해 설계되었습니다.</p>\n<p>운영체제제가 제어하는 개념이므로, Block 단위로 데이터를 다룹니다.  또한, 디스크의 입/출력에 대한 부하가 균등하게 분배되어야 하고, 이를 통해 성능을 향상시킬 수 있습니다.\n일부 버전에서는 데이터를 중복 저장하거나 Parity로 손실을 체크하는 등, 신뢰성을 보장하기 위한 기능도 가지고 있습니다.</p>\n<p><strong>RAID 0</strong></p>\n<p><strong>Disk Striping</strong>: 데이터를 블록 단위로 분할해 각 디스크에 저장합니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td>M</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n<td>R</td>\n</tr>\n</tbody>\n</table>\n<p><strong>성능 측면에서</strong>, 하나의 Stripe( X, Y ,Z, I)를 한번에 접근 할 수 있으므로(병렬 접근), 매우 좋다고 할 수 있습니다.</p>\n<ul>\n<li>그러나 (X, J, O )접근같이 최악의 경우에는 병렬성이 보장되지 아예 않습니다. ( 일반적인 경우는 아님 )</li>\n</ul>\n<p><strong>안정성 측면에서는,</strong> 데이터를 중복해 저장하지 않기 때문에, 안정성이 떨어집니다. 하나의 디스크에서 장애가 발생할 경우, 데이터 손실이 발생합니다.</p>\n<p><strong>RAID1</strong></p>\n<p><strong>Mirroring</strong>:  동일한 데이터를 미러링 디스크에 동시 저장!</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>X</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>Z</td>\n<td>I</td>\n<td>I</td>\n</tr>\n<tr>\n<td>J</td>\n<td>J</td>\n<td>K</td>\n<td>K</td>\n</tr>\n</tbody>\n</table>\n<p>RAID1은 하나의 데이터를 두 개 이상의 디스크에 중복으로 저장해 안정성을 향상시킨 방법입니다.</p>\n<p><strong>안정성 측면</strong>에서 하나(또는 이상)의 디스크에 장애가 생겨도, 다른 디스크에서 데이터를 가져올 수 있습니다.\n그러나 디스크 저장 가능 용량이 줄어든다는 단점이 있습니다.</p>\n<p><strong>성능 측면</strong>에서 단일 ****읽기/쓰기 작업은 RAID0과 큰 차이를 보이지 않습니다. 그러나 연속 읽기/쓰기 작업에서는 데이터 버스의 대역폭 관점에서 병목이 발생해, RAID0과 비교해 성능 저하가 발생합니다. 최대 대역폭의 (1 /N )만큼 제공</p>\n<p><strong>RAID3</strong></p>\n<p><strong>RAID 0 + Parity Bit:</strong> Striping에 대한 Parity를 저장.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Parity Disk</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td>M</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n<td>R</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<p>RAID1에서는 안정성을 위해 디스크 용량을 너무 많이 차지한다는 단점이 있었습니다.\n이에 Parity Bit를 통한 복구 알고리즘을 적용해, 데이터 복구에 필요한 저장공간을 줄였습니다.</p>\n<p>또한 성능 측면에서도 RAID0과 같은 Striping 방법을 사용하므로, 병렬 처리가 가능해 우수한 성능을 보입니다.</p>\n<p>그러나 대량의 쓰기 작업 시 Parity 계산으로 인한 병목이 발생할 수 있습니다.</p>\n<p><strong>RAID3은 Byte 단위,  RAID4에서는 Block 단위로 데이터 및 패리티를 저장한다는 차이가 있습니다.</strong></p>\n<p>RAID4에서는 읽기 작업 수행 시 더 적은 I/O횟수로 데이터를 읽어올 수 있지만, 필요하지 않은 데이터를 가져올 수 도 있다는 단점이 있습니다.</p>\n<p><strong>RAID 5 (현재 자주 사용되는 버전)</strong></p>\n<p>RAID3,4에서는 Parity Disk하나가 고장나면, 손실 측정을 할 수 없는 <strong>가용성 문제</strong>가 있었습니다.\nRAID5에서는 데이터를 저장하는 디스크에 <strong>Parity정보를 분산 저장</strong>해, 안정성을 높혔습니다.</p>\n<p><strong>부하 분산측면</strong>에서도, Write가 많은 시스템의 경우, RAID3,4같이 Parity Disk를 따로 두게되면, 해당 디스크에 부하가 집중되는 문제점이 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Disk E</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n<td><strong>P1</strong></td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td><strong>P2</strong></td>\n<td>M</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td><strong>P3</strong></td>\n<td>Q</td>\n<td>R</td>\n</tr>\n<tr>\n<td>S</td>\n<td><strong>P4</strong></td>\n<td>T</td>\n<td>U</td>\n<td>V</td>\n</tr>\n<tr>\n<td><strong>P5</strong></td>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>D</td>\n</tr>\n</tbody>\n</table>\n<p><strong>RAID6</strong></p>\n<p>RAID6는 RAID5와 같지만, 패리티 정보를 이중으로 저장합니다.</p>\n<p>이를 통해 RAID5보다 데이터 안정적으로 데이터를 보존할 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Disk E</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td><strong>P1</strong></td>\n<td><strong>P1</strong></td>\n</tr>\n<tr>\n<td>I</td>\n<td>J</td>\n<td><strong>P2</strong></td>\n<td><strong>P2</strong></td>\n<td>K</td>\n</tr>\n<tr>\n<td>L</td>\n<td><strong>P3</strong></td>\n<td><strong>P3</strong></td>\n<td>M</td>\n<td>N</td>\n</tr>\n<tr>\n<td><strong>P4</strong></td>\n<td><strong>P4</strong></td>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Parity disk가 “실질적으로” 어떻게 데이터를 복구할까…??</p>\n</blockquote>\n<p><strong>XOR Parity 의 경우…</strong></p>\n<ul>\n<li>만약,  디스크가 각각 0 , 1, 1 ,0데이터를 가지고있다고 하자</li>\n<li>패리티 비트는 이 모든 값에 XOR을 취한 값 (((0^1)^1)^0) = 0</li>\n<li>마지막 디스크가 파손되어, 0 값이 사라졌다!</li>\n<li>파손된 디스크를 제외하고 패리티 비트까지 XOR을 수행하면 원래의 값이 복구된다.\n<ul>\n<li>((0^1)^1)^0 = 0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nested-raid\" style=\"position:relative;\"><a href=\"#nested-raid\" aria-label=\"nested raid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nested RAID</h2>\n<p>RAID는 중첩해서 사용할 수 있습니다.\n주로 안정성을 지원하는 RAID와 Striping을 지원하는 RAID( 보통은 RAID 0)를 통해 중첩합니다.</p>\n<p>아래에서는 RAID 0+1, RAID 1+0에 대해 다루지만, 5+0, 6+0, 심지어 1+0+0 등, 안정성과 성능 요구사항에 따라 다양하게 구성할 수 있습니다.</p>\n<p><img src=\"%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20RAID%20c738ef37d2b74244957a62749b73b1e3/360px-RAID_01.svg.png\" alt=\"./360px-RAID_01.svg.png\"></p>\n<p><img src=\"%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20RAID%20c738ef37d2b74244957a62749b73b1e3/440px-RAID_10_01.svg.png\" alt=\"440px-RAID_10_01.svg.png\"></p>\n<p>이미지 출처: <a href=\"https://en.wikipedia.org/wiki/Nested_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Nested_RAID_levels</a></p>\n<p>RAID 0+1, 1+0 두 가지 방법 모두 안정성과 병렬접근 성능을 기반으로 설계된 중복 RAID 방법입니다.</p>\n<p>RAID0+1은 이름에서 알 수 있듯, [ Striping + Mirroring ], 1+0은 [ Mirroring + Striping ] 입니다.</p>\n<p>간단히 보기에는 두 방법이 차이가 없는것 같지만, 성능이나 안정성 측면에서 차이가 존재합니다.</p>\n<p>그 전에, 그림에서 오해할 수 있는 부분이 있어 설명합니다.\nNested RAID에서는 디스크 데이터가 많아질수록 RAID 0이 다중화됩니다.\n이를 참고해, Striping대상이 2개 이상일 경우를 상상해야 둘의 차이를 이해할 수 있습니다.</p>\n<p>RAID 0+1 에서는 Striping 해야하는 데이터가 많아질수록, 가용성 측면에서 단점을 보입니다.</p>\n<p>2개의 미러링 디스크 그룹이 있다고 할 때, 각각의 디스크 그룹에서 하나씩의 손실만 발생해도 Striping을 통해 데이터를 가져오지 못하는 장애가 발생합니다.</p>\n<p>반면 RAID 1 + 0에서는 , 하나의 Mirroring 디스크 그룹에서 모두 손실이 발생하지 않는 한, 여러 Striping 그룹에서 손실이 발생하더라도, 각각의 Mirror 디스크에서 데이터를 가져올 수 있으므로, 안정성이 더 뛰어납니다.</p>\n<p>이런 이유로, 얼핏 비슷해보이는 RAID 0+1과 1+0이지만, 1+0이 실제로 더 자주 사용되는 RAID 구성 방법입니다. RAID 5+0, 6+0 등 다른 RAID를 설계할 때도, 성능/안정성/복구 측면에서 고려해 다양하게 설계할 수 있습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Standard_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Standard_RAID_levels</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Nested_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Nested_RAID_levels</a></p>","fields":{"slug":"운영체제-디스크와-raid"},"frontmatter":{"title":"[운영체제] 디스크와 RAID","date":"10.14.2024","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":4}},"pageContext":{"slug":"운영체제-디스크와-raid","prev":{"excerpt":"데드락이란? 할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태 프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다. DeadLock drawio 운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래…","html":"<p><strong>데드락이란?</strong></p>\n<p>할당받을 수 없는 자원을 요청해 더이상 실행할 수 없는 상태</p>\n<p>프로세스 A,B는 리스소 X,Y를 가지고있어야 진행이 가능합니다. 하지만 A,B가 각각 Y,X를 점유하고 X,Y를 요청한다면, 영원히 X,Y를 동시에 획득하지 못하는 상황이 발생합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/c99a815a-150e-4ba7-b500-9f8be5e5c88d\" alt=\"DeadLock drawio\"></p>\n<p>운영체제에는 다양한 자원을 복잡한 방법으로 할당받아 사용하기에, 위와 같은 경우라고 해서 무조건 데드락이 발생하지는 않고, E.G 코프만 교수가 아래 <strong>4가지 조건이 모두 충족</strong>되어야만 데드락이 발생함을 보였습니다.</p>\n<ol>\n<li>상호배제. Mutual Exclusion: 두 개의 프로세스가 필요로 하는 자원을 배타적으로 점유해야 한다.</li>\n<li>비선점. Non Preemption: 프로세스의 실행중, 다른 프로세스가 자원의 점유를 빼앗을 수 없다.</li>\n<li>점유 대기. Hold and Wait: 할당된 자원을 가진 상태로 다른 자원을 기다린다.</li>\n<li>환형 대기. Circular Wait: 여러 프로세스가 순환적으로 자원 할당을 기다린다.</li>\n</ol>\n<p><strong>데드락 예방 방법</strong></p>\n<p>그러므로, 데드락을 <strong>예방</strong>하는 방법은 위 네 가지중 한가지를 부정해주면 됩니다.</p>\n<ol>\n<li>상호배제조건 제거: 자원을 배타적으로 점유하는 조건을 제거, 자원 공유\n<ol>\n<li>락을 사용하지 않았을 때의 문제점이 그대로 발생한다.</li>\n</ol>\n</li>\n<li>비선점 조건 제거: 자원의 할당을 선점해올 수 있도록 방법 제공\n<ol>\n<li>구현이 매우 복잡해지며, 성능 오버헤드가 발생한다.</li>\n</ol>\n</li>\n<li>점유대기 제거: 프로세스의 시작시점에 필요한 모든 자원을 요청한다\n<ol>\n<li>사용하지 않는 자원을 점유하고있는 비용과, 기아상태로 인한 무한대기가 발생한다.</li>\n</ol>\n</li>\n<li>환형대기 제거: 자원을 선형으로 분류해 순서를 매기고, 증가하는 순서로만 자원을 요청.  (TODO Check 필요)\n<ol>\n<li>가장 현실적인 방법. 이것마저도 꽤 큰 성능 오버헤드 발생</li>\n</ol>\n</li>\n</ol>\n<p><strong>데드락 회피 방법</strong></p>\n<p>또, 데드락은 <strong>회피방법이</strong> 존재합니다. 예방방법과 달리, 운영체제가 실행중에 동작하는 방법이기에 회피방법이라 부릅니다.</p>\n<p>교착상태가 발생할 수 있는 자원 할당을 피하고, 안전한 상태에서만 자원 할당을 하는 방법입니다.</p>\n<p>앞선 예방방법에서도 비용 및 성능 오버헤드로 인한 한계점을 보았듯, 회복 방법 역시 태생적 한계점이 존재합니다.</p>\n<ol>\n<li>운영체제가 프로세스의 최대 자원 할당 수를 알고있어야 하고,</li>\n<li>프로세스의 수가 고정되어야 합니다 ( Process Create X )</li>\n<li>자원의 종류와 숫자가 고정되어야 합니다.</li>\n</ol>\n<p><strong>Banker’s Algorithm</strong></p>\n<p>TODO<strong>안전하지 않은 순서에 대한 예제 체크, 예시 고치기</strong></p>\n<p>다익스트라가 제안한것으로 유명한 은행원 알고리즘은, 대표적인 데드락 회피 방법입니다.</p>\n<p>프로세스와 프로세스의 최대 할당 자원, 현재 할당 자원을 알고있을 때, 최대 할당자원을 넘어가지 않는 안전순서열을 만들어 자원을 할당하는 방법입니다.</p>\n<p>운영체제는 총 14개의 자원을 갖고있다고 가정하겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Process</th>\n<th>최대 할당 자원 수</th>\n<th>현재 할당 자원 수</th>\n<th>필요한 자원 수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>12</td>\n<td>5</td>\n<td>7</td>\n</tr>\n<tr>\n<td>B</td>\n<td>5</td>\n<td>1</td>\n<td>4</td>\n</tr>\n<tr>\n<td>C</td>\n<td>5</td>\n<td>4</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>현재 할당된 자원 수는 12개입니다. 가용 자원 수는 4개입니다.</li>\n<li>C에 1개의 자원을 할당해 실핼시키고, C가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 8개입니다. (4 -1 + 5)</li>\n<li>B에 자원 4개를 할당해 실행시키고, B가 종료되어 5의 자원을 반환받습니다.</li>\n<li>현재 가용 자원 수는 9개입니다 ( 8 - 4 + 5)</li>\n<li>A에 7개의 자원을 할당하고, 모든 프로그램을 종료합니다.</li>\n</ol>\n<p>자원을 안전하게 분배할 수 있는 순서는 C → B → A가 유일합니다. (Safe Sequence)</p>\n<p>안전순서열로 보장된 실행순서로 프로세스를 실행하면 데드락을 회피할 수 있으며, 안전하지 않은 상태에서의 실행은 데드락이 발생할 수 있는 확률이 있음을 의미합니다.</p>\n<p>은행원 알고리즘은 하나의 종류의 자원이 여러개 필요하다고 가정하고 시작한다는 한계가 있습니다. 사용된다고 하더라도, 프로세스 스케줄링 루틴은 자주 일어나는 작업인데, 낮은 빈도로 발생하는 데드락을 위해 스케줄링 과정에 프로세스를 감시해야 하므로 높은 오버헤드가 존재합니다.</p>\n<p><strong>데드락 탐지 및 복구방법</strong></p>\n<p>데드락 탐지 및 복구방법은 운영체제가 실행중에 동작하는 방법인것은 회피방법과 같지만, 이 방법은 데드락이 발생 후 처리하는 방식이라는 차이점이 있습니다.</p>\n<p>먼저, 어떤 프로세스가 데드락 상태인지 판별하기 위해 Resourse Allocation Graph를 탐색해 데드락 상태인 프로세스를 탐지합니다. 이는 RAG의 자원 대기를 나타내는 그래프의 사이클을 판별하면 됩니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/9c9597e1-5c08-4225-a435-27f3e797cad0\" alt=\"2\"></p>\n<p><em>이미지 출처: <a href=\"https://velog.io/@jerry92/OS-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9Cdeadlock%EC%9D%98-%EC%A1%B0%EA%B1%B4%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@jerry92/OS-교착상태deadlock의-조건과-해결-방법</a></em></p>\n<p>사이클 내에 존재하는 프로세스는 아래 두 가지 방법중 하나로 데드락에서 탈출해야 합니다.</p>\n<ol>\n<li>\n<p>프로세스 중단: 사이클에 속하는 하나 이상 또는 전체 프로세스를 중단합니다. 전체 프로세스를 중단하는것은 대규모 작업이 될 수도 있고, 연관된 다른 프로세스까지 종료하게 된다면, 작업 손실이 발생할 수도 있습니다.</p>\n<p>이에 프로세스 age나 우선순위 등을 고려해 한개씩 삭제하는게 좋습니다.</p>\n</li>\n<li>\n<p>자원 선점: 교착상테에 놓인 자원을 선점할 때까지 프로세스의 자원을 다른 프로세스가 선점하도록 하므로써 데드락을 탈출합니다.</p>\n</li>\n</ol>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>OSTEP: Operating Systems: Three Easy Pieces - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C%5D(https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)\">Wikipedia, Deadlock</a></p>\n<p><a href=\"%5Bhttps://en.wikipedia.org/wiki/Deadlock%5D(https://en.wikipedia.org/wiki/Deadlock)\">Eng Wikipedia, Deadlock</a></p>","id":"d025e9b6-ba19-5963-9469-e8cf4cca48a4","fields":{"slug":"운영체제-데드락과-예방-회피-복구"},"frontmatter":{"date":"2023-04-16","title":"운영체제 데드락과 예방,회피,복구","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},"next":null}},"staticQueryHashes":[],"slicesMap":{}}