{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/운영체제-디스크와-raid/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"디스크와-raid\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%8A%A4%ED%81%AC%EC%99%80-raid\" aria-label=\"디스크와 raid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디스크와 RAID</h1>\n<p><strong>디스크(HDD)와 구성요소</strong></p>\n<p>Sector - 트랙 내에서 데이터 판독의 물리적 단위 (512 Byte)</p>\n<p>Track -  Platter에서 같은 거리만큼 떨어진 섹터 집합</p>\n<p>Cylinder - 같은 반지름을 갖는 트랙의 집합</p>\n<p>Platter - 데이터를 기록할 수 있는 자성물질로 이뤄진 원형 금속판</p>\n<p>Surface - Platter의 윗면,아랫면</p>\n<p>디스크 드라이브는, 디스크 축을 회전시키며 <strong>Positioner</strong>  <strong>암</strong>을 위치시켜,  <strong>Head</strong>가 데이터를 기록하고 읽는다.</p>\n<h3 id=\"raid-redundant-arrays-of-inexpensice-disks\" style=\"position:relative;\"><a href=\"#raid-redundant-arrays-of-inexpensice-disks\" aria-label=\"raid redundant arrays of inexpensice disks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RAID: <strong>Redundant Arrays of Inexpensice Disks</strong></h3>\n<p>직역하면 저성능 디스크의 중복 배열입니다. 여러 개의 디스크를 묶어 대용량으로 사용한다는 의미이며,운영체제와 RAID Controller의 제어를 받습니다.  RAID버전에 따라 안정성과 성능(Access Speed)을 고려해 설계되었습니다.</p>\n<p>운영체제제가 제어하는 개념이므로, Block 단위로 데이터를 다룹니다.  또한, 디스크의 입/출력에 대한 부하가 균등하게 분배되어야 하고, 이를 통해 성능을 향상시킬 수 있습니다.\n일부 버전에서는 데이터를 중복 저장하거나 Parity로 손실을 체크하는 등, 신뢰성을 보장하기 위한 기능도 가지고 있습니다.</p>\n<p><strong>RAID 0</strong></p>\n<p><strong>Disk Striping</strong>: 데이터를 블록 단위로 분할해 각 디스크에 저장합니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td>M</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n<td>R</td>\n</tr>\n</tbody>\n</table>\n<p><strong>성능 측면에서</strong>, 하나의 Stripe( X, Y ,Z, I)를 한번에 접근 할 수 있으므로(병렬 접근), 매우 좋다고 할 수 있습니다.</p>\n<ul>\n<li>그러나 (X, J, O )접근같이 최악의 경우에는 병렬성이 보장되지 아예 않습니다. ( 일반적인 경우는 아님 )</li>\n</ul>\n<p><strong>안정성 측면에서는,</strong> 데이터를 중복해 저장하지 않기 때문에, 안정성이 떨어집니다. 하나의 디스크에서 장애가 발생할 경우, 데이터 손실이 발생합니다.</p>\n<p><strong>RAID1</strong></p>\n<p><strong>Mirroring</strong>:  동일한 데이터를 미러링 디스크에 동시 저장!</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>X</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>Z</td>\n<td>I</td>\n<td>I</td>\n</tr>\n<tr>\n<td>J</td>\n<td>J</td>\n<td>K</td>\n<td>K</td>\n</tr>\n</tbody>\n</table>\n<p>RAID1은 하나의 데이터를 두 개 이상의 디스크에 중복으로 저장해 안정성을 향상시킨 방법입니다.</p>\n<p><strong>안정성 측면</strong>에서 하나(또는 이상)의 디스크에 장애가 생겨도, 다른 디스크에서 데이터를 가져올 수 있습니다.\n그러나 디스크 저장 가능 용량이 줄어든다는 단점이 있습니다.</p>\n<p><strong>성능 측면</strong>에서 단일 ****읽기/쓰기 작업은 RAID0과 큰 차이를 보이지 않습니다. 그러나 연속 읽기/쓰기 작업에서는 데이터 버스의 대역폭 관점에서 병목이 발생해, RAID0과 비교해 성능 저하가 발생합니다. 최대 대역폭의 (1 /N )만큼 제공</p>\n<p><strong>RAID3</strong></p>\n<p><strong>RAID 0 + Parity Bit:</strong> Striping에 대한 Parity를 저장.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Parity Disk</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td>M</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n<td>R</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<p>RAID1에서는 안정성을 위해 디스크 용량을 너무 많이 차지한다는 단점이 있었습니다.\n이에 Parity Bit를 통한 복구 알고리즘을 적용해, 데이터 복구에 필요한 저장공간을 줄였습니다.</p>\n<p>또한 성능 측면에서도 RAID0과 같은 Striping 방법을 사용하므로, 병렬 처리가 가능해 우수한 성능을 보입니다.</p>\n<p>그러나 대량의 쓰기 작업 시 Parity 계산으로 인한 병목이 발생할 수 있습니다.</p>\n<p><strong>RAID3은 Byte 단위,  RAID4에서는 Block 단위로 데이터 및 패리티를 저장한다는 차이가 있습니다.</strong></p>\n<p>RAID4에서는 읽기 작업 수행 시 더 적은 I/O횟수로 데이터를 읽어올 수 있지만, 필요하지 않은 데이터를 가져올 수 도 있다는 단점이 있습니다.</p>\n<p><strong>RAID 5 (현재 자주 사용되는 버전)</strong></p>\n<p>RAID3,4에서는 Parity Disk하나가 고장나면, 손실 측정을 할 수 없는 <strong>가용성 문제</strong>가 있었습니다.\nRAID5에서는 데이터를 저장하는 디스크에 <strong>Parity정보를 분산 저장</strong>해, 안정성을 높혔습니다.</p>\n<p><strong>부하 분산측면</strong>에서도, Write가 많은 시스템의 경우, RAID3,4같이 Parity Disk를 따로 두게되면, 해당 디스크에 부하가 집중되는 문제점이 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Disk E</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td>I</td>\n<td><strong>P1</strong></td>\n</tr>\n<tr>\n<td>J</td>\n<td>K</td>\n<td>L</td>\n<td><strong>P2</strong></td>\n<td>M</td>\n</tr>\n<tr>\n<td>O</td>\n<td>P</td>\n<td><strong>P3</strong></td>\n<td>Q</td>\n<td>R</td>\n</tr>\n<tr>\n<td>S</td>\n<td><strong>P4</strong></td>\n<td>T</td>\n<td>U</td>\n<td>V</td>\n</tr>\n<tr>\n<td><strong>P5</strong></td>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>D</td>\n</tr>\n</tbody>\n</table>\n<p><strong>RAID6</strong></p>\n<p>RAID6는 RAID5와 같지만, 패리티 정보를 이중으로 저장합니다.</p>\n<p>이를 통해 RAID5보다 데이터 안정적으로 데이터를 보존할 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>Disk A</th>\n<th>Disk B</th>\n<th>Disk C</th>\n<th>Disk D</th>\n<th>Disk E</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>Y</td>\n<td>Z</td>\n<td><strong>P1</strong></td>\n<td><strong>P1</strong></td>\n</tr>\n<tr>\n<td>I</td>\n<td>J</td>\n<td><strong>P2</strong></td>\n<td><strong>P2</strong></td>\n<td>K</td>\n</tr>\n<tr>\n<td>L</td>\n<td><strong>P3</strong></td>\n<td><strong>P3</strong></td>\n<td>M</td>\n<td>N</td>\n</tr>\n<tr>\n<td><strong>P4</strong></td>\n<td><strong>P4</strong></td>\n<td>O</td>\n<td>P</td>\n<td>Q</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Parity disk가 “실질적으로” 어떻게 데이터를 복구할까…??</p>\n</blockquote>\n<p><strong>XOR Parity 의 경우…</strong></p>\n<ul>\n<li>만약,  디스크가 각각 0 , 1, 1 ,0데이터를 가지고있다고 하자</li>\n<li>패리티 비트는 이 모든 값에 XOR을 취한 값 (((0^1)^1)^0) = 0</li>\n<li>마지막 디스크가 파손되어, 0 값이 사라졌다!</li>\n<li>파손된 디스크를 제외하고 패리티 비트까지 XOR을 수행하면 원래의 값이 복구된다.\n<ul>\n<li>((0^1)^1)^0 = 0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nested-raid\" style=\"position:relative;\"><a href=\"#nested-raid\" aria-label=\"nested raid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nested RAID</h2>\n<p>RAID는 중첩해서 사용할 수 있습니다.\n주로 안정성을 지원하는 RAID와 Striping을 지원하는 RAID( 보통은 RAID 0)를 통해 중첩합니다.</p>\n<p>아래에서는 RAID 0+1, RAID 1+0에 대해 다루지만, 5+0, 6+0, 심지어 1+0+0 등, 안정성과 성능 요구사항에 따라 다양하게 구성할 수 있습니다.</p>\n<p><img src=\"%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20RAID%20c738ef37d2b74244957a62749b73b1e3/360px-RAID_01.svg.png\" alt=\"./360px-RAID_01.svg.png\"></p>\n<p><img src=\"%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20RAID%20c738ef37d2b74244957a62749b73b1e3/440px-RAID_10_01.svg.png\" alt=\"440px-RAID_10_01.svg.png\"></p>\n<p>이미지 출처: <a href=\"https://en.wikipedia.org/wiki/Nested_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Nested_RAID_levels</a></p>\n<p>RAID 0+1, 1+0 두 가지 방법 모두 안정성과 병렬접근 성능을 기반으로 설계된 중복 RAID 방법입니다.</p>\n<p>RAID0+1은 이름에서 알 수 있듯, [ Striping + Mirroring ], 1+0은 [ Mirroring + Striping ] 입니다.</p>\n<p>간단히 보기에는 두 방법이 차이가 없는것 같지만, 성능이나 안정성 측면에서 차이가 존재합니다.</p>\n<p>그 전에, 그림에서 오해할 수 있는 부분이 있어 설명합니다.\nNested RAID에서는 디스크 데이터가 많아질수록 RAID 0이 다중화됩니다.\n이를 참고해, Striping대상이 2개 이상일 경우를 상상해야 둘의 차이를 이해할 수 있습니다.</p>\n<p>RAID 0+1 에서는 Striping 해야하는 데이터가 많아질수록, 가용성 측면에서 단점을 보입니다.</p>\n<p>2개의 미러링 디스크 그룹이 있다고 할 때, 각각의 디스크 그룹에서 하나씩의 손실만 발생해도 Striping을 통해 데이터를 가져오지 못하는 장애가 발생합니다.</p>\n<p>반면 RAID 1 + 0에서는 , 하나의 Mirroring 디스크 그룹에서 모두 손실이 발생하지 않는 한, 여러 Striping 그룹에서 손실이 발생하더라도, 각각의 Mirror 디스크에서 데이터를 가져올 수 있으므로, 안정성이 더 뛰어납니다.</p>\n<p>이런 이유로, 얼핏 비슷해보이는 RAID 0+1과 1+0이지만, 1+0이 실제로 더 자주 사용되는 RAID 구성 방법입니다. RAID 5+0, 6+0 등 다른 RAID를 설계할 때도, 성능/안정성/복구 측면에서 고려해 다양하게 설계할 수 있습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Standard_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Standard_RAID_levels</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Nested_RAID_levels\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Nested_RAID_levels</a></p>","fields":{"slug":"운영체제-디스크와-raid"},"frontmatter":{"title":"[운영체제] 디스크와 RAID","date":"10.14.2024","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":4}},"pageContext":{"slug":"운영체제-디스크와-raid","prev":{"excerpt":"이번 글에서는 앞서 공부한 세마포어를 바탕으로, 대표적으로 알려진 동시성 문제를 다룹니다. 세마포어에 대해서는 이전 글을 참고해주세요. Producer-Consumer Problem Reader-Writer Problem //Dinning Philosopher’s Problem Producer-Consumer 문제 배경지식: Ring Buffer 생산자 소비자 구조에서 자주 사용되는 Ring Buffer구조는 Circular Queue…","html":"<p>이번 글에서는 앞서 공부한 세마포어를 바탕으로, 대표적으로 알려진 동시성 문제를 다룹니다. 세마포어에 대해서는 이전 글을 참고해주세요.</p>\n<ul>\n<li>Producer-Consumer Problem</li>\n<li>Reader-Writer Problem</li>\n<li>//Dinning Philosopher’s Problem</li>\n</ul>\n<h2 id=\"producer-consumer-문제\" style=\"position:relative;\"><a href=\"#producer-consumer-%EB%AC%B8%EC%A0%9C\" aria-label=\"producer consumer 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Producer-Consumer 문제</h2>\n<p><strong>배경지식: Ring Buffer</strong></p>\n<p>생산자 소비자 구조에서 자주 사용되는 Ring Buffer구조는 Circular Queue자료구조입니다. 이는 배열과 head, tail에 대한 포인터를 갖고, size변수를 통해 Ring buffer의 크기를 판별합니다.</p>\n<p>Modular연산을 통해 head, tail 포인터를 정의해 삽입/삭제 시 head/tail 포인터가 배열 범위 안에서 정의되도록 합니다.</p>\n<p><img src=\"https://github.com/lee95292/lee95292.github.io/assets/30853787/05f2b93f-4e6b-48bf-aebe-123595689104\" alt=\"Producer-Consumer drawio\"></p>\n<p>생상자-소비자 문제라고도 불립니다. 이는 컴퓨터와 프린터 관계로 보면 됩니다.</p>\n<p>문서를 등록하는 컴퓨터와 프린터는 여러개입니다.</p>\n<p>컴퓨터는 프린트해야하는 문서들을 작업 큐에 등록합니다(Produce)</p>\n<p>프린터는 작업 큐에 올라온 문서를 차례로 프린트합니다. (Consume)</p>\n<p>생산자-소비자 문제는 일반적인 공유변수에서의 동기화 문제와는 달리, 데이터의 삽입/인출부분이 정해져있다는 차이점이 있습니다.</p>\n<ul>\n<li>그렇기에, Producer가 데이터를 삽입할 때 Consumer가 데이터를 인출하는 작업은 경쟁상태가 발생하지 않습니다.(다른 위치이므로)</li>\n<li>하지만 데이터가 가득 찼거나, 텅 비었을 때는 head/tail 포인터의 위치가 같습니다. 이를 고려해야 합니다.</li>\n<li>여전히 Producer끼리, Consumer끼리는 상호배제가 지켜저야 합니다.</li>\n</ul>\n<p>이를 바탕으로 Consumer와 Producer 코드를 작성해보겠습니다.</p>\n<p><strong>세마포어 변수</strong></p>\n<p>MutexP [0,1]: Binary Semaphore로, 프로듀서간 공유자원 상호배제를 달성합니다.</p>\n<p>MutexC [0,1]: 마찬가지로, 컨슈머간 상호배제를 달성합니다.</p>\n<p>NEmpty  [0 ~ N] : 링버퍼가 비어있는지에 대한 세마포어입니다.  // P(NEmpty)비어있으면 Blocking</p>\n<p>NFull [N ~ 0]: 링버퍼가 가득 차있는지에 대한 세마포어입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Producer's Code</span>\n<span class=\"token comment\">// repeat this code</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>MutexP<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2개 이상의 Producer 접근 금지, Producer간 상호배제 달성</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>NFull<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 데이터가 가득 찬 경우, NFull==0이므로, Blocking</span>\n<span class=\"token punctuation\">[</span>Data Produce<span class=\"token punctuation\">]</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>NEmpty<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>MutexP<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Consumer's Code</span>\n<span class=\"token comment\">// repeat this code</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>MutexC<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2개 이상의 Consumer 접근금지, Consumer간 상호배제 달성</span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>NEmpty<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 데이터가 없는 경우, NEmpty ==0이르모, Blocking</span>\n<span class=\"token punctuation\">[</span>Data Consume<span class=\"token punctuation\">]</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>NFull<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>MutexC<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 예시를 살펴보면, head,tail이 겹치는 부분에서 Producer와 Consumer의 실행이 동시에 일어나지 않습니다.</p>\n<ul>\n<li>링버퍼에 데이터가 가득 찬 경우 : Consumer만 접근 가능</li>\n<li>링버퍼가 텅 빈 경우: Producer만 접근 가능</li>\n</ul>\n<p>이는 underflow, overflow를 막기 위함도 있지만, 단순히 if문을 사용하지 않고 세마포어 변수를 통해 동시 실행을 제어했으므로, 경쟁상태가 발생하지 않습니다.</p>\n<p>(만약, 공유변수인 데이터 개수를 세마포어로 통제하지 않고, 데이터개수가 0일 때 발생하는 문제점을 생각해보면 좋습니다.)</p>\n<h2 id=\"reader-writer문제\" style=\"position:relative;\"><a href=\"#reader-writer%EB%AC%B8%EC%A0%9C\" aria-label=\"reader writer문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reader-Writer문제</h2>\n<p>Reader-Writer문제는 읽기만 담당하는 스레드와 쓰기만 담당하는 스레드가 나뉜 상황입니다. (이하 Reader, Writer)</p>\n<p>Reader-Reader관계에는 상호배제가 필요하지 않지만,  Writer-Writer또는 Reader-Writer간에는 상호배제가 필요합니다.</p>\n<p><strong>우선권 문제</strong></p>\n<p>만약, Reader가 끊임없이 생성되어 Writer 스레드가 작업할 수 없다면 어떻게될까요? 또는, Writer가 계속 생성되어 Reader가 생성되는 경우도 마찬가지입니다.  이에 Reader,Writer에 대해 우선순위를 주도록 구현할 수 있습니다.</p>\n<p><strong>Reader Preference Solution</strong></p>\n<p>Reader 스레드 수가 0일때만 Writer가 세마포어를 획득할 수 있음, Writer는 1개의 스레드만 실행할 수 있다.</p>\n<p>일반변수:</p>\n<ul>\n<li>readCount: 읽기스레드의 개수입니다. 만약 1→0이 되면 쓰기 스레드가 접근할 수 있도록 바꿔주고, 0→1이되면 쓰기 스레드를 사용할 수 없도록 잠궈줍니다.</li>\n</ul>\n<p>세마포어:</p>\n<ul>\n<li>wMutex [1, 0] : 쓰기 스레드가 1개까지 동작할 수 있습니다.</li>\n<li>rsync [1, 0]: 읽기 스레드가 readCount를 수정합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token expression\">Reader's Code</span></span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>        # 읽기 스레드 카운트를 증가하고<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>이라면 wMutex <span class=\"token operator\">-></span> <span class=\"token number\">0</span>\nreadCount<span class=\"token operator\">+=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">if</span> readCount <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span>Read Data<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>    # Reader는 별도의 Mutex 필요없이 여러 스레드가 실행되어도 된다<span class=\"token punctuation\">.</span>\n\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span>        # 읽기 스레드 카운트를 줄이고<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>이라면 wMutex<span class=\"token operator\">-></span> <span class=\"token number\">1</span>\nreadCount<span class=\"token operator\">-=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">if</span> readCount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rsync<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token expression\">Writer's Code</span></span>\n<span class=\"token function\">P</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span>Write Data<span class=\"token punctuation\">]</span>\n\n<span class=\"token function\">V</span><span class=\"token punctuation\">(</span>wMutex<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위같이 세마포어를 활용해 독자-저자 문제를 해결할 수 있습니다. readCount와 wMutex를 수정하는 작업만 배타적으로 실행되면 됩니다.</p>\n<p>하지만 Reader가 계속해 추가된다면 Writer가 Starvation에 빠져, 실행될 수 없다는 문제점이 있습니다.</p>\n<p>이외에도 Writer를 우선하는 방법과 공평하게 분배하는 알고리즘이 있습니다.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">EN wiki 참고: wiki/Readers–writers_problem</a></p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">EN wiki 참고: wiki/Readers–writers_problem</a></p>\n<p>OSTEP: Operating Systems: Three Easy Pieces - <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=CitsUz-Dx7A&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=16\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=CitsUz-Dx7A&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=16</a></p>","id":"1a0e46a0-8d6f-575f-bee5-30ecb5762905","fields":{"slug":"os-독자-저자문제와-생산자-소비자-문제-및-해결"},"frontmatter":{"date":"2023-04-16","title":"OS 독자/저자문제와 생산자/소비자 문제 및 해결","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},"next":null}},"staticQueryHashes":[],"slicesMap":{}}