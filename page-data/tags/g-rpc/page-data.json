{"componentChunkName":"component---src-templates-tag-tsx","path":"/tags/g-rpc/","result":{"pageContext":{"posts":[{"excerpt":"프로토콜 버퍼(Protocol Buffer)는 gRPC에서 데이터의 스키마를 정의하고 직렬화할때 사용하는 메커니즘입니다. google에서 개발했으며, *.proto형식의 메시지 뿐만 아니라, JSON등의 데이터를 직렬화할때도 사용되는 방식이고, gRPC에서 직렬화 방식으로 사용되고 있습니다. 프로토콜 버퍼가 gRPC에서 어떻게 동작하는지는 링크:이전 글을 참조해주세요 이 글에서는 Protocol Buffer3(Proto…","html":"<p>프로토콜 버퍼(Protocol Buffer)는 gRPC에서 데이터의 스키마를 정의하고 직렬화할때 사용하는 메커니즘입니다. google에서 개발했으며, *.proto형식의 메시지 뿐만 아니라, JSON등의 데이터를 직렬화할때도 사용되는 방식이고, gRPC에서 직렬화 방식으로 사용되고 있습니다.</p>\n<p>프로토콜 버퍼가 gRPC에서 어떻게 동작하는지는 링크:이전 글을 참조해주세요</p>\n<p>이 글에서는 Protocol Buffer3(Proto3)에서 스키마를 정의하는 방법들 중, 기본적인 내용에 대해 다룹니다.</p>\n<h2 id=\"메시지를-정의하는-방법\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"메시지를 정의하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지를 정의하는 방법</h2>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">syntax</span><span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchRequest</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">string</span> query<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token builtin\">int32</span> page_number<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token builtin\">int32</span> result_per_page<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/*\nC/C++ Style Comment\n*/</span>\n<span class=\"token comment\">//C/C++ Style Comment</span></code></pre></div>\n<p>위의 프로토콜 버퍼는 아래와 같은 특징을 가지고 있습니다.</p>\n<ul>\n<li><strong>확장자:</strong> .proto 입니다.</li>\n<li><strong>버전 명시:</strong> 주석, 빈 라인을 제외한 첫 번째 라인에  Proto3 임을 명시해주어야 합니다.  (아니면 기본값 proto2로 지정)</li>\n<li><strong>필드 정의 :</strong> string,int32/64와 같은 타입과 , query, page_number같은 이름의 쌍으로 필드를 정의합니다. (참고로, 필드명은 snake case, 메시지명은 cammel case를 권장하고있습니다)</li>\n<li><strong>주석</strong> : C/C++스타일 주석으로, “//” 와 “/**/” 를 사용할 수 잇습니다.</li>\n<li><strong>필드번호 정의:</strong> 필드번호는 메시지 내 유일한 숫자로 지정해줍니다.\n<ul>\n<li>필드번호를 통해 이진 포멧에서 필드를 식별할 수 있고, 메시지 유형이 사용된경우 변경하면 안됩니다.</li>\n<li>1-15 까지의 번호는 1바이트만 사용하지만, 16~2047은 2바이트, 번호가 커질수록 사용하는 바이트 수가 늘어납니다. 또한, 19000 ~19999까지는 예약된 필드번호로, 사용이 불가능합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"필드-규칙\" style=\"position:relative;\"><a href=\"#%ED%95%84%EB%93%9C-%EA%B7%9C%EC%B9%99\" aria-label=\"필드 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>필드 규칙</h3>\n<p>메시지의 필드는 아래 4개중 하나의 타입에 해당합니다.</p>\n<p>Proto3에서는 <strong>field presence</strong>라는 개념이 존재합니다. 자세한 내용은 링크(<a href=\"https://protobuf.dev/programming-guides/field_presence/\">https://protobuf.dev/programming-guides/field_presence/</a>)를 참고하시면 되고, 필드 규칙을 이해하기 위해서는 [ explicit, no ] present의 개념에 대해서만 이해하면 됩니다.</p>\n<p><strong>explicit present</strong>: 명시적으로 값이 존재하는지를 저장하는 값 체계</p>\n<p><strong>no present</strong>: 값이 존재하는지 아닌지를 노출하지 않고, 기본값을 통해 대치하는 방식</p>\n<p><a href=\"https://protobuf.dev/programming-guides/field_presence/\">https://protobuf.dev/programming-guides/field_presence/</a></p>\n<ul>\n<li>singular: proto3에서 규칙을 지정하지 않으면 기본값으로 사용됩니다. no-present방식의 값 체계를 따릅니다.</li>\n<li>optional: proto2에서 기본으로 사용되었으며, 직렬화 시 explicit present방식을 사용합니다.</li>\n<li>repeated : 반복되는 값에 대해 사용합니다. key-value로 매핑되지만, packed옵션을 통해 값만 반복하도록 설정할 수 있습니다.</li>\n<li>map: key-value형태의 값에 대해 사용합니다.</li>\n</ul>\n<h3 id=\"기본값\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%EA%B0%92\" aria-label=\"기본값 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본값</h3>\n<p><strong>메시지 파싱 시, 특정 필드가 지정되어있지 않으면 필드는 기본값으로 설정됩니다!</strong> 그러므로, <strong>메시지 필드가 직렬화 이후 파싱되었을 때, 필드의 값이 기본값인지 지정되지 않았던것인지 판단할 수 없습니다.  주의해야합니다.</strong></p>\n<p>각 타입별 기본값입니다.</p>\n<ul>\n<li>string- 빈 문자열</li>\n<li>bool - false</li>\n<li>숫자타입 - 0</li>\n<li>enum- 첫 번째로 정의된 열거형 값이고, 0 이어야 함.</li>\n<li>repeated - 빈 배열(언어에 따라 다릅니다)</li>\n</ul>\n<h2 id=\"proto3-필드-타입과-각-언어별-자료형-매핑\" style=\"position:relative;\"><a href=\"#proto3-%ED%95%84%EB%93%9C-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B0%81-%EC%96%B8%EC%96%B4%EB%B3%84-%EC%9E%90%EB%A3%8C%ED%98%95-%EB%A7%A4%ED%95%91\" aria-label=\"proto3 필드 타입과 각 언어별 자료형 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>proto3 필드 타입과 각 언어별 자료형 매핑</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088289-7eabb332-4681-44f1-9ffd-5a67e0906b0d.png\" alt=\"프로토콜버\"></p>\n<p>출처: <a href=\"https://protobuf.dev\">https://protobuf.dev</a></p>\n<h3 id=\"메시지-정의-유형\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%95%EC%9D%98-%EC%9C%A0%ED%98%95\" aria-label=\"메시지 정의 유형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 정의 유형</h3>\n<p>하나의 파일에서 여러개의 메시지를 정의할 수 있으며, 정의한 메시지를 다른 메시지에서 타입으로 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchResponse</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token positional-class-name class-name\">Result</span> results <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">Result</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">string</span> url <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">string</span> title <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token builtin\">string</span> snippets <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>메시지를 원하는만큼 중첩해 정의할 수 있으며, 메시지 내부에 정의된 메시지는 부모  메시지로부터 참조해야합니다</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchResponse</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">message</span> <span class=\"token class-name\">Result</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> url <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> title <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">repeated</span> <span class=\"token builtin\">string</span> snippets <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token positional-class-name class-name\">Result</span> results <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">SomeOtherMessage</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token positional-class-name class-name\">SearchResponse<span class=\"token punctuation\">.</span>Result</span> result <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"여러가지-타입들\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%ED%83%80%EC%9E%85%EB%93%A4\" aria-label=\"여러가지 타입들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러가지 타입들</h2>\n<h3 id=\"map\" style=\"position:relative;\"><a href=\"#map\" aria-label=\"map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Map</h3>\n<p>Map을 통해 키와 값을 매핑시킬 수 있으며, 기본 형식은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token map class-name\">map<span class=\"token punctuation\">&lt;</span>key_type<span class=\"token punctuation\">,</span> value_type<span class=\"token punctuation\">></span></span> map_field <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>키 타입으로는 Integer, String과 관련된 scalar type이 가능하며, byte, float타입은 불가능합니다.</li>\n<li>Map타입은 repeated를 적용할 수 없습니다.</li>\n</ul>\n<h3 id=\"oneof\" style=\"position:relative;\"><a href=\"#oneof\" aria-label=\"oneof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OneOf</h3>\n<p>OneOf타입은 상수형 값을 매핑시키는 enum과 다릅니다! 실제 자료형을 통해 선언된 여러 필드들 중, 하나의 값을 가질 수 있습니다. (map과 repeated는 사용할 수 없습니다)</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SampleMessage</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">oneof</span> test_oneof<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token builtin\">string</span> name<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token positional-class-name class-name\">SubMessage</span> sub_message<span class=\"token operator\">=</span><span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>메모리를 공유하기때문에 OneOf필드를 세팅하면 기존에 가지고있던 값이 사라집니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\">SampleMessage <span class=\"token keyword\">message</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">set_name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">CHECK_EQ</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// sub_messgae필드를 없애고, name값을 할당합니다. </span>\n<span class=\"token comment\">// sub_message to a new instance of SubMessage with none of its fields set.</span>\n<span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">mutable_sub_message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">CHECK</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>언어별로 WhichOf, Case 등, 내부에 있는 값을 확인하는 로직을 통해 사용합니다.</p>\n<h3 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h3>\n<ul>\n<li>Map타입에서 float타입이 안되면, string으로 대체하는건가?</li>\n<li>reserved : 다시 쓸  수 있나?</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://protobuf.dev/programming-guides/proto3/#simple\">https://protobuf.dev/programming-guides/proto3/#simple</a></p>\n<p><a href=\"https://protobuf.dev/reference/protobuf/proto3-spec/\">https://protobuf.dev/reference/protobuf/proto3-spec/</a></p>\n<p><a href=\"https://medium.com/naver-cloud-platform/nbp-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EC%8B%9C%EB%8C%80%EC%9D%98-%ED%9D%90%EB%A6%84-grpc-%EA%B9%8A%EA%B2%8C-%ED%8C%8C%EA%B3%A0%EB%93%A4%EA%B8%B0-1-39e97cb3460\">https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460</a></p>\n<p><a href=\"https://protobuf.dev/programming-guides/encoding\">https://protobuf.dev/programming-guides/encoding</a></p>","id":"2906e18a-afe6-5891-a776-cbea6f00b4bb","fields":{"slug":"protocol-buffer-3-spec정리"},"frontmatter":{"date":"2023-02-01","title":"Protocol Buffer 3 Spec정리","category":"tech","tags":["protobuf3","gRPC","gRPC 스터디"],"banner":null,"description":null},"timeToRead":2},{"excerpt":"gRPC 개요 gRPC 소개, Pros & Cons MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다. [+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다. [+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다. Binary framing layer…","html":"<h1 id=\"grpc-개요\" style=\"position:relative;\"><a href=\"#grpc-%EA%B0%9C%EC%9A%94\" aria-label=\"grpc 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 개요</h1>\n<h2 id=\"grpc-소개-pros--cons\" style=\"position:relative;\"><a href=\"#grpc-%EC%86%8C%EA%B0%9C-pros--cons\" aria-label=\"grpc 소개 pros  cons permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 소개, Pros &#x26; Cons</h2>\n<p>MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다.</p>\n<ul>\n<li>[+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다.</li>\n<li>[+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다.\n<ul>\n<li><strong>Binary framing layer</strong>: 데이터를 <strong>바이너리로 이뤄진 프레임으로 전달, 송/수신 레이어에서 다시 재조립</strong>하는 기능을 제공하는 HTTP2에서 도입된 계층</li>\n<li><strong>Multiflexing</strong>지원: Binary framing을 통해 가능해짐. 여러 스트림에서 양방향으로 frame을 통신. <strong>비동기, 양방향 데이터 통신</strong></li>\n<li>이외에도 서버 푸시, 스트림 우선순위 등의 특징과 함께 성능이 대폭 개선됨.</li>\n</ul>\n</li>\n<li>[-] 데이터 스키마 수정 시 서버 및 클라이언트 코드를 모두 변경해야합니다.</li>\n<li>[-] human readable하지 않습니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021105-c50f8ef0-6537-4060-98dc-f42dd517319c.png\" alt=\"1\">\n[그림] - Soap, REST, gRPC의 기본 데이터 전송 포멧의 장단점 비교</p>\n<h2 id=\"간단하게-요약해보는-grpc-매커니즘\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9A%94%EC%95%BD%ED%95%B4%EB%B3%B4%EB%8A%94-grpc-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"간단하게 요약해보는 grpc 매커니즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 요약해보는 gRPC 매커니즘</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021110-d92e6249-993d-4055-a541-de3e9bdf957d.png\" alt=\"2\"></p>\n<ul>\n<li>서버는 클라이언트 호출을 핸들링하고, 클라이언트는 서버와 같은 메서드를 실행하는 Stub을 작성한다.</li>\n<li>gRPC는 서로 다른 <strong>다양한 언어</strong>로 작성된 서버/클라이언트 사이에서 통신할 수 있다.</li>\n<li>gRPC는 <strong>서버의 메서드를 로컬 객체인것처럼 호출한다.</strong></li>\n</ul>\n<h2 id=\"protocol-buffer를-통해-동작\" style=\"position:relative;\"><a href=\"#protocol-buffer%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8F%99%EC%9E%91\" aria-label=\"protocol buffer를 통해 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protocol Buffer를 통해 동작</h2>\n<p>Protocol Buffer란, gRPC에서 구조화된 데이터를 직렬화하기 위한 오픈소스 메커니즘입니다. 언어와 플랫폼에 중립적으로 동작합니다. (영향을 받지 않습니다)</p>\n<p>자세한 스펙은 <a href=\"https://protobuf.dev/\">https://protobuf.dev/</a> 를 참고해주세요!</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bool</span> has_ponycopter <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>gRPC는 서버와 클라이언간 이진 바이트 통신을 하기 위해 Protocol Buffer를 기본 전략으로 사용합니다.</p>\n<p>*.proto파일에 데이터 구조를 정의합니다. 직렬화하고싶은 데이터를 위와 같이 key-value필드로 매핑해 *.proto 파일로 작성합니다.</p>\n<h2 id=\"컴파일-및-메시지-인코딩\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%9D%B8%EC%BD%94%EB%94%A9\" aria-label=\"컴파일 및 메시지 인코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일 및 메시지 인코딩</h2>\n<p><strong>protoc</strong>은 프로토콜 버퍼 컴파일러입니다.</p>\n<p>이는 *.proto 파일에서 정의한 내용으로 <strong>특정 언어가 데이터에 접근할 수 있는 클래스파일을 생성</strong>합니다.</p>\n<p>name(), set_name()과 같은 메서드를 통해 <strong>raw bytes에서 메시지로 직렬화하거나 그 반대로 파싱</strong>할 수 있습니다.</p>\n<h2 id=\"동작\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91\" aria-label=\"동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작</h2>\n<ul>\n<li>서버 측에서 서버는 서비스에서 선언한 메서드를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리합니다. gRPC 인프라는 들어오는 요청을 디코딩하고 서비스 메서드를 실행하며 서비스 응답을 인코딩합니다.</li>\n<li>클라이언트에는 메시지를 서버와 동일한 방식으로 바라보는 <strong>stub</strong>이라는 객체를 통해 메시지와 파라미터를 인코딩해 rpc를 수행하고, 서버가 처리한 결과를 디코딩해 처리합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021107-2b48721b-bd09-421a-bd36-72ea21d11cc0.png\" alt=\"3\"></p>\n<blockquote>\n<p>출처 Geeks for geeks</p>\n</blockquote>\n<h2 id=\"grpc-요청-타입\" style=\"position:relative;\"><a href=\"#grpc-%EC%9A%94%EC%B2%AD-%ED%83%80%EC%9E%85\" aria-label=\"grpc 요청 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 요청 타입</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021109-7b7dacd0-f65d-45cc-b5b0-af7188288e7e.png\" alt=\"4\"></p>\n<p>stream을 통해 대량 데이터가 전달될 수도 있습니다. 그래도 gRPC의 프로그래밍 API에서는 대부분 비동기 처리를 지원하므로, stream data 및 단일 요청에 대해서도 Blocking없이 비동기적으로 처리 가능합니다.</p>\n<p><strong>Unary RPC</strong></p>\n<p>클라이언트에서 단일 요청을 보내고, 서버가 단일 응답을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Server Streaming RPC</strong></p>\n<p>클라이언트가 단일 요청을 보내고, 서버가 스트림을 통해 여러개의 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfReplies</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Clinet Streaming RPC</strong></p>\n<p>클라이언트가 스트림을 통해 여러게의 메시지를 보내고, 서버가 단일 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfGreetings</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Bidrectional Streaming RPC</strong></p>\n<p>클라이언트와 서버가 독립적인 스트림을 주고받으며</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">BidiHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h2>\n<ul>\n<li>server와 client의 stub간 동기화가 필요하지 않나?\n<ul>\n<li>→ 그렇다. protocol buffer를 사용하는 경우, 스키마를 공유하기 위해 스키마 정보를 가진 proto파일을 동기화해 컴파일하거나, 컴파일된 protob파일을 동기화해서 사용해야 한다.</li>\n</ul>\n</li>\n<li>stub을 웹 브라우저에 올릴 수 없는 이유?\n<ul>\n<li>→ 기술적으로는 가능하다. but 엄격한 타입 정의를 통해 통신이 이뤄지는데,만약 스키마 변경 시 end-user에게는 전달되지 않아 장애가 발생할 수 있음.</li>\n</ul>\n</li>\n<li>기존 RPC와는 어떤 차이가 있나?\n<ul>\n<li>gRPC의 경우 HTTP2을 통해 통신한다고 가정하고 구현했으므로, protocol buffer를 통해 binary data로 컴파일하고, binary frame으로 통신해 오버헤드가 적다. (기존 RPC에서는 주로 XML같은 text 기반으로 통신했으므로, 비효율적이다)</li>\n</ul>\n</li>\n<li>text기반 통신이 binary기반 통신에 비해 비효율적인 이유는 무엇인가?\n<ul>\n<li>문자를 제외한 number, boolean을 표현할 때, 사용하는 데이터 공간이 더 크고, 이는 통신 속도에도 영향을 미친다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"keyword\" style=\"position:relative;\"><a href=\"#keyword\" aria-label=\"keyword permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>keyword</h2>\n<p>gRPC, Protocol Buffer, Multiflex, Data access object, Binary framing, Async</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://grpc.io/docs/what-is-grpc/introduction/\">https://grpc.io/docs/what-is-grpc/introduction/</a></p>\n<p><a href=\"https://web.dev/performance-http2/\">https://web.dev/performance-http2/</a> - (Refer:HTTP2 spec, binary framing, multiflexing)</p>\n<p><a href=\"https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0\">https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0</a> (refer: pros&#x26;cons of gRPC)</p>\n<p><a href=\"https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/\">https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/</a></p>\n<p><a href=\"https://codingffler.tistory.com/28\">https://codingffler.tistory.com/28</a></p>","id":"b1635c4c-bdab-51e6-94d5-c0de80c48403","fields":{"slug":"g-rpc의-동작원리와-기본-개념"},"frontmatter":{"date":"2023-01-23","title":"gRPC의 동작원리와 기본 개념","category":"tech","tags":["gRPC","gRPC 스터디"],"banner":null,"description":null},"timeToRead":2}],"tagName":"gRPC"}},"staticQueryHashes":[],"slicesMap":{}}