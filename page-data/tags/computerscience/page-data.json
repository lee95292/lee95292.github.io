{"componentChunkName":"component---src-templates-tag-tsx","path":"/tags/computerscience/","result":{"pageContext":{"posts":[{"excerpt":"데이터베이스 인덱스 데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다. Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다. Clustered Index…","html":"<h1 id=\"데이터베이스-인덱스\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"데이터베이스 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 인덱스</h1>\n<p>데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다.</p>\n<p>Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다.</p>\n<h1 id=\"clustered-index\" style=\"position:relative;\"><a href=\"#clustered-index\" aria-label=\"clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clustered Index</h1>\n<p>Clustered Index는, Primary Key에 주로 사용되며 실제 데이터가 정렬된 상태로 존재합니다. 어떤 칼럼을 Clustered Index Key로 지정하는 경우 하나의 키만이 Clustered Index Key로 지정될 수 있으며, 지정 시 모든 데이터를 정렬해야하므로 많은 시간이 필요합니다.</p>\n<h3 id=\"인덱스-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777748-1cdb21e0-8f9d-4220-b542-583272432b22.png\" alt=\"Clustered Index drawio\"></p>\n<p>클러스터드 인덱스의 경우 인덱스 키값과 데이터페이지 주소가 저장되며, 두 번의 페이지 조회만에 데이터를 찾을 수 있습니다.</p>\n<h1 id=\"non-clustered-index\" style=\"position:relative;\"><a href=\"#non-clustered-index\" aria-label=\"non clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non Clustered Index</h1>\n<p>InnoDB는 B+Tree 자료구조를 통해 인덱스 데이터를 관리합니다. B+Tree는 자식이 2개 이상인 m-ary 균형(Balanced) 트리입니다.</p>\n<ul>\n<li>N개 데이터에 대한 조회에 O(Log(N))의 시간복잡도를 가집니다. 이는 데이터가 일정수준 이상일 때, Full Scan 방식인 O(N)에 비해 월등히 빠른 속도입니다.</li>\n<li>삽입,삭제는 인덱스 트리에 대한 수정과 더불어 , 불균형 있는 경우 Rebalancing과정까지 추가되어 인덱스를 적용하기 전보다 느려집니다. 이는 B+Tree가 깊이를 일정하게 하기 위한 rebalancing과정에서 소요되는 시간입니다.</li>\n<li>인덱스 트리를 저장하기 위해 전체 데이터의 10%정도에 해당하는 추가 저장공간을 사용합니다.</li>\n</ul>\n<h3 id=\"인덱스-구조-1\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0-1\" aria-label=\"인덱스 구조 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777762-504433d0-48d2-4609-9bb4-a3f1a580f9ea.png\" alt=\"Non Clustered Index drawio\"></p>\n<p>트리의 루트 및 브랜치 노드에는 키값과 인덱스 페이지의 주소가 담겨있고, 인덱스 키값으로 정렬된 모습을 확인할 수 있습니다.<br>\n트리의 리프 노드에는 키값과 데이터 페이지의 주소와 슬롯이 담겨있어 루트노드에서 리프노드까지 트리를 탐색하며 키에 해당하는 데이터를 가져올 수 있습니다.<br>\n(<em>추가적으로, 부모/자식노드간 키가 중복으로 들어가며, 리프노드들이 링크드 리스트 형태로 연결되었다는 특징이 있습니다. InnoDB는 여기서 조금 더 발전해 같은 레벨의 노드들이 더블 링크드 리스트로 연결되어 있습니다.)</em></p>\n<h2 id=\"페이지란\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80%EB%9E%80\" aria-label=\"페이지란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지란?</h2>\n<p>데이터베이스는 디스크에 페이지라는 단위로 데이터를 저장합니다. InnoDB에서는 16KB로 고정된 크기를 가지기 때문에, 인덱스를 구성하는 키가 커질수록 페이지에 저장할 수 있는 키가 적어지고, B+Tree의 깊이가 깊어져 성능 저하를 가져오게 됩니다.</p>\n<p>극단적으로 말했을 때, 페이지 주소가 12Byte이고 Varchar(1024)인 1KB 사이즈의 게시글 내용을 인덱스 키로 지정한다면,<br>\n한 페이지에 (16 * 1024) / (12 + 1024) = 15.xx로, 15개의 키밖에 저장할 수 없습니다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Database_index#Index_concurrency_control\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">위키피디아 https://en.wikipedia.org/wiki/Database_index</a></p>\n<p><a href=\"https://jojoldu.tistory.com/m/243\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">향로님 블로그</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#B-Tree_%EC%9D%B8%EB%8D%B1%EC%8A%A4_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">인파님 블로그, 인덱스 총정리</a></p>","id":"f0da8866-3059-5999-9f12-9ad8bbfb644a","fields":{"slug":"데이터베이스-인덱스"},"frontmatter":{"date":"2022-10-17","title":"데이터베이스 인덱스","category":"tech","tags":["computerscience","database","index"],"banner":null},"timeToRead":1},{"excerpt":"주제 : 운영체제 메모리 관리: 물리메모리 할당 방식! 목차 연속 메모리 할당 고정 분할 방식 Fixed Allocation 가변 분할 방식 Variable Allocation 비연속 메모리 할당 세그멘테이션 Segmentation 페이징 Paging ---continue--- 페이징/세그멘테이션 혼합 페이지 요구 Demand Paging…","html":"<blockquote>\n<p>주제 : 운영체제 메모리 관리: 물리메모리 할당 방식!</p>\n</blockquote>\n<ul>\n<li>\n<p>목차</p>\n</li>\n<li>\n<p>연속 메모리 할당</p>\n<ul>\n<li>고정 분할 방식 Fixed Allocation</li>\n<li>가변 분할 방식 Variable Allocation</li>\n</ul>\n</li>\n<li>\n<p>비연속 메모리 할당</p>\n<ul>\n<li>세그멘테이션 Segmentation</li>\n<li>페이징 Paging</li>\n</ul>\n<p>---continue---</p>\n<ul>\n<li>페이징/세그멘테이션 혼합</li>\n<li>페이지 요구 Demand Paging</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 할당 방식</h1>\n<p>하나의 프로그램이 실행되는 메모리 순서를 연속적으로 물리 메모리에 할당하는 방법</p>\n<h3 id=\"고정-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%A0%95-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"고정 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고정 분할 방식</h3>\n<p>물리적 메모리를 몇 개의 영구적인 분할로 나누어 각각의 영역에 프로그램을 적재시킨다.</p>\n<p>심각한 내부 단편화가 발생할 수 있다.<br>\n예를 들어 256MB의 메모리를 32MB씩 분할한다면, 2MB의 메모리만이 필요한 프로그램이 실행되는 경우 30MB의 내부 단편화가 발생한다.<br>\n(보통은 다양한 크기의 프로그램을 실행하기 위해 메모리를 다양한 크기로 분할한다.)</p>\n<h3 id=\"가변-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"가변 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 분할 방식</h3>\n<p>프로그램이 실행/종료되는 시점마다 프로그램 크기에 맞는 메모리를 할당/해제하는 방식.</p>\n<p>첫 할당 이후 메모리 위치를 재정리할 수 없으므로, 다양한 크기의 프로그램에 대해 메모리 할당/해제를 반복하다 보면 아래와 같이 외부 단편화가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-----------------------------------------------------\n| running(120MB) | empty(20MB) | running(8MB) | ...</code></pre></div>\n<hr>\n<h1 id=\"비연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"비연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속 할당 방식</h1>\n<p>프로그램의 메모리 할당 요청을 비연속적으로 메모리에 할당하는 방식. swap space를 사용하는 가상화 기법이 활용된다.</p>\n<h3 id=\"세그먼트-\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-\" aria-label=\"세그먼트  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그먼트 :</h3>\n<p>메모리를 나누는 단위.</p>\n<p>세그먼트: 프로세스 크기에 따라 가변 크기를 갖는 <strong>물리 메모리 분할 단위</strong></p>\n<hr>\n<h3 id=\"페이지--프레임\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80--%ED%94%84%EB%A0%88%EC%9E%84\" aria-label=\"페이지  프레임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 / 프레임</h3>\n<p>페이지 : 고정 크기로 <strong>가상 메모리를 분할하는 단위</strong></p>\n<p>프레임 : 페이지와 1:1로 매핑되는 <strong>물리 메모리 분할 단위</strong></p>\n<p>페이지와 프레임은 페이지 테이블을 매개로 연결된다.</p>\n<p>따라서, 프로세스가 page(N)을 가지고있을 경우, OS는 가상주소 N에 데이터를 요청하고, 가상주소 N은 페이지 테이블의 정보를 통해 물리 주소인 frame(K)에 접근한다. 이 때, frame(k)주소가 존재하지 않을 경우, swap space(주로 보조 기억장치)에서 데이터를 가져온다. 이는 page fault라고 불리며, 이는 성능 저하를 일으키기도 하며 segmentation-paging 기법에서 Thrashing 등을 일으켜 심각한 성능 저하를 내기도 한다.</p>\n<hr>\n<h3 id=\"페이지-테이블--페이징-기법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94--%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\"페이지 테이블  페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 / 페이징 기법</h3>\n<p><strong>페이징 기법</strong> : 가상 메모리를 <strong>고정 크기</strong>로 분할한 페이지를 통해 메모리를 관리하는 방식.<br>\n만약 프로세스가 페이지의 크기보다 적은 메모리를 필요로 하는 경우, **내부 단편화((페이지)내부의 메모리 일부가 사용되지 않아 낭비되는 현상)**가 발생한다.</p>\n<p>(페이지의 크기 :프로세스의 크키가 커지면서 4KB > 4MB까지 크기가 커짐.)</p>\n<p>LRU, FIFO, LFU, NUR등의 페이지 교체 알고리즘을 통해 물리 메모리를 관리.</p>\n<p><strong>페이지 테이블</strong> : 페이지와 프레임의 매칭 정보를 담고있는 테이블.</p>\n<p>프로세스가 가상 메모리(page)의 정보를 hit할때 실제 물리 메모리 주소(frame)로 변환하는 역할을 수행한다.</p>\n<p>페이지의 크기가 커지면 아래와 같은 변화가 생긴다.</p>\n<ul>\n<li>내부 단편화가 증가한다.</li>\n<li>Page fault(페이지 요청 실패)가 감소한다.</li>\n<li>페이지 테이블의 크기가 감소한다.\n<ul>\n<li>(TMI)페이지 테이블 비례 : 전체 메모리 사이즈 /  페이지 크기</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"세그멘테이션-테이블-세그멘테이션-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 테이블 세그멘테이션 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션 테이블 /세그멘테이션 기법</h3>\n<p><strong>세그멘테이션 기법</strong> : 하나의 프로세스가 사용하는 메모리의 크기 단위로 가상 주소를 관리하는 기법.</p>\n<p>프로세스별로 요구하는 메모리가 다르므로, 세그먼트의 크기는 가변적이다.</p>\n<p>세그멘테이션 테이블 :</p>\n<ul>\n<li>물리 메모리에서 세그먼트의 <strong>start address</strong></li>\n<li>가변적인 세그먼트의 크기를 나타내는 <strong>limit</strong></li>\n</ul>\n<p>위 두 가지를 보관하고 있는 자료구조이다.</p>\n<hr>\n<h3 id=\"세그멘테이션-페이징-혼합-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%98%BC%ED%95%A9-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 페이징 혼합 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션-페이징 혼합 기법</h3>\n<p>.</p>\n<h3 id=\"pcb-process-control-block\" style=\"position:relative;\"><a href=\"#pcb-process-control-block\" aria-label=\"pcb process control block permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB: Process Control Block</h3>\n<p>프로세스 생성 시 커널 스택만들어지는 자료구조 : Status / Pointer(addr)/ Identifier / PC / Priority 등을 저장한다.\n<img src=\"https://t1.daumcdn.net/cfile/tistory/995A6E395A5E0DAF18\" alt=\"PCB\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">/</th>\n<th align=\"center\">연속 메모리 할당</th>\n<th align=\"center\">가상화(swap)</th>\n<th align=\"center\">관리 테이블</th>\n<th align=\"center\">단편화</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">고정 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">가변 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">외부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">페이징 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">페이지테이블</td>\n<td align=\"center\">페이지 내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">세그멘테이션 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">세그먼테이션 테이블</td>\n<td align=\"center\">세그멘테이션 외부 단편화</td>\n</tr>\n</tbody>\n</table>","id":"0db54144-01a0-551b-bfac-e41061832274","fields":{"slug":"continue-os-메모리파트-정리"},"frontmatter":{"date":"2020-05-24","title":"[Continue,OS] 메모리파트 정리","category":"tech","tags":["운영체제","computerscience"],"banner":null},"timeToRead":2}],"tagName":"computerscience"}},"staticQueryHashes":[],"slicesMap":{}}