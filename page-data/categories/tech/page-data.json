{"componentChunkName":"component---src-templates-category-tsx","path":"/categories/tech","result":{"pageContext":{"posts":[{"excerpt":"JPA의 엔티티매니저와 영속성 관리 JPA의 엔티티매니저가…","html":"<h1 id=\"jpa의-엔티티매니저와-영속성-관리\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%EB%8B%88%EC%A0%80%EC%99%80-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC\" aria-label=\"jpa의 엔티티매니저와 영속성 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 엔티티매니저와 영속성 관리</h1>\n<p>JPA의 엔티티매니저가 1차캐시, 쓰기지연, 영속성 관리 등의 역할을 하기 위해 어떻게 동작하는지 살펴보자</p>\n<h2 id=\"엔티티-매니저-팩토리-엔티티-매니저\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80\" aria-label=\"엔티티 매니저 팩토리 엔티티 매니저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 매니저 팩토리, 엔티티 매니저</h2>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 클래스입니다. 일반적으로 하나의 데이터베이스를 사용하는 애플리케이션은, 하나의 엔티티 매니저 팩토리를 생성하고 이를 통해 엔티티 매니저를 생성합니다.</p>\n<p>엔티티 매니저 팩토리는 생성시 매우 큰 비용을 지불해야 하므로, 애플리케이션당 하나를 사용하면 되고, <strong>Thread-safe</strong>하므로 다른 스레드와 공유해도 괜찮습니다.</p>\n<p>반면 엔티티매니저의 경우, 생성 비용이 거의 들지 않지만 여러 스레드가 동시에 접근할 경우, <strong>동시성 문제</strong>가 발생하므로, 스레드간 공유하면 안됩니다.</p>\n<img width=\"473\" alt=\"JPA_3_1\" src=\"https://user-images.githubusercontent.com/30853787/210956641-10027f43-7206-4d82-96d1-25c6d304035e.png\">\n<p>또한, 엔티티 매니저는 데이터베이스 연결이 필요한 시점까지 커넥션이 없는 상태로 유지하다가, 트랜잭션이 시작되는 등, 데이터베이스 연결이 필요한 시점이 되면 커넥션을 획득합니다.</p>\n<h2 id=\"엔티티의-생명주기\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"엔티티의 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티의 생명주기</h2>\n<p>엔티티는 영속성 컨텍스트라는 엔티티 저장소에 영속되어 관리됩니다.  엔티티는 영속 상태에 따라 4가지의 상태가 있고, 생명주기는 아래와 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956646-f95a5164-e574-4b35-a23b-988c0e0780da.png\" alt=\"JPA_4\"></p>\n<ul>\n<li>비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태\n<ul>\n<li>New를 통해 엔티티를 생성해, 엔티티와 영속성 컨텍스트가 아무 관련이 없는 상태이다.</li>\n</ul>\n</li>\n<li>영속: 엔티티가 영속성 컨텍스트에 의해 관리되는 상태\n<ul>\n<li><strong>em.persiste(member)</strong> 또는, <strong>em.find(Member.class, “memberId”);</strong> 로 SQL을 통해 데이터 조회 시, 영속상태가 된다</li>\n<li>영속된 엔티티는 식별자를 통해 관리된다.</li>\n</ul>\n</li>\n<li>준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태\n<ul>\n<li>em.close()로 영속성 컨텍스트를 닫거나 em.clear()를 호출해 영속성 컨텍스트를 초기화하는 경우, 엔티티들이 준영속 상태가 된다</li>\n<li>**em.detach(member)**같이 특정 엔티티를 준영속시킬수도 있다.</li>\n<li>개발자가 엔티티를 준영속 상태로 만드는 일은 흔치않은 일입니다.</li>\n</ul>\n</li>\n<li>삭제: 삭제된 상태\n<ul>\n<li>em.remove(member); 를 통해 영속성 컨텍스트 및 데이터베이스에서 삭제됩니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"영속성-컨텍스트란\" style=\"position:relative;\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80\" aria-label=\"영속성 컨텍스트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>영속성 컨텍스트란?</h2>\n<p><strong>엔티티를 영구 저장하는 환경</strong>으로, 엔티티 매니저를 통해 엔티티를 저장하거나 조회했을 때, 엔티티 매니저는 엔티니를 영속성 컨텍스트에 보관 및 관리합니다. 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제나 성능 개선을 위해 아래와 같은 특징을 갖습니다.</p>\n<h3 id=\"엔티티-조회-시-1차캐시-제공\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%A1%B0%ED%9A%8C-%EC%8B%9C-1%EC%B0%A8%EC%BA%90%EC%8B%9C-%EC%A0%9C%EA%B3%B5\" aria-label=\"엔티티 조회 시 1차캐시 제공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 조회 시 1차캐시 제공</h3>\n<p>영속성 컨텍스트 내부에는 Map 자료구조가 존재합니다. @Id로 매핑한 값을 Key로 사용하고, 엔티티 인스턴스를 Value로 합니다.</p>\n<p>만약 멤버 인스턴스가 생성되어 <strong>영속성 컨텍스트에 영속된 상태</strong>라면, 해당 엔티티에 대해 식별자로 조회했을 때 동일성이 보장되는 멤버 인스턴스를 <strong>데이터베이스 조회 없이</strong> 조회해주는 <strong>캐싱 기능</strong>을 제공합니다. 이를 <strong>1차캐시</strong>라고 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//동일성 보장, Insataces has same identity 출력</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>emMember <span class=\"token operator\">==</span> member<span class=\"token punctuation\">)</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Insataces has same identity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>1차캐시에 엔티티가 저장되어있는경우의 workflow입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956653-ad82cf2d-7e52-48f9-b3f0-785f73a587c5.png\" alt=\"JPABook_97 drawio\"></p>\n<p>위의 경우와 달리, 멤버 <strong>엔티티가 1차캐시에 등록되어있지 않다면</strong>, SQL문으로 데이터를 조회하고, 엔티티를 생성한 뒤 1차캐시에 저장해 이를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//데이터베이스에 존재하지만, 영속상태가 아닌 엔티티 조회 </span>\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"member2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956650-60b80152-5734-4d92-a11a-3028a9178bf8.png\" alt=\"JPABook_97 drawio_(1)\"></p>\n<p>따라서 영속성 컨텍스트는 1차캐시 기능을 통해 총 두 가지의 이점을 얻습니다.</p>\n<ul>\n<li>엔티티의 동일성 보장</li>\n<li>캐싱을 통한 성능 향상</li>\n</ul>\n<h3 id=\"트랜잭션을-지원하는-쓰기지연-transactional-write-behind\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%93%B0%EA%B8%B0%EC%A7%80%EC%97%B0-transactional-write-behind\" aria-label=\"트랜잭션을 지원하는 쓰기지연 transactional write behind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션을 지원하는 쓰기지연 (Transactional write-behind)</h3>\n<p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 전달하지 않고, 쓰기지연 저장소에 쌓아놓고, 트랜잭션이 커밋되는 순간 데이터베이스에 쿼리를 전달합니다. 이것을 트랜잭션을 지원하는 쓰기지연이라고 합니다.</p>\n<p>(1) Commit 전까지 영속성 컨텍스트에 쿼리 저장, 1차캐시에 엔티티 저장</p>\n<p>(2) 트랜잭션 커밋 시, DB에 flush.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956659-2e9b80db-b21d-4ed8-8694-3561dfbff315.png\" alt=\"JPABook-100 drawio\"></p>\n<h3 id=\"엔티티-수정\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%88%98%EC%A0%95\" aria-label=\"엔티티 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 수정</h3>\n<p>SQL을 사용한 엔티티 수정 작업은 많은 양의 쿼리 반복과 SQL의존성을 갖게됩니다.</p>\n<p>JPA는 역시 트랜잭션을 지원하는 쓰기지연을 이용해 객체지향적인 방법으로 해결합니다.</p>\n<p>이 때, 스냅샷이라는 새로운 개념이 등장하는데요, <strong>스냅샷</strong>은 엔티티가 영속성 컨텍스트에 <strong>처음 저장될 때의 값</strong>을 기억해놓은 것입니다.  영속성 컨텍스트는 이를 기반으로, 플러시가 호출되었을 때 엔티티와 스냅샷을 비교해 Update 쿼리를 생성하고, 데이터베이스에 전송, 커밋합니다.</p>\n<ul>\n<li>\n<ol>\n<li>flush 호출 시, Entity와 Snapshot 비교해 변경 감지</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>변경된부분이 있다면, 쓰기지연 저장소에 Update Query 추가</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>DB에 Update Query 전달 후 커밋</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956656-6dec4769-15cb-4516-a35b-debf65f1a6c9.png\" alt=\"JPABook-100 drawio_(1)\"></p>\n<p>JPA 변경감지의 특징 : <strong>JPA가 생성하는 Update Query는  기본적으로 엔티티의 모든 필드를 업데이트합니다.</strong></p>\n<p>왜 이렇게 하는걸까요? 책에서는 <strong>재사용 측면</strong>에서 두 가지 정도의 장점을 설명합니다.</p>\n<ul>\n<li>수정쿼리가 항상 같아, 이를 애플리케이션 로딩 시점에 미리 로드해서 재사용할 수 있음</li>\n<li>데이터베이스는 동일한 쿼리를 받았을 때, 이전에 파싱된 쿼리를 재사용할 수 있음</li>\n</ul>\n<p>수정된 필드만을 이용해 쿼리를 전송하고 싶다면, @DynamicUpdate어노테이션을 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Mklee\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\"># Name 필드만 변경할것으로 예상</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> NAME <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">WHERE</span> ID <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#모든 필드를 수정</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> \n\t\tNAME<span class=\"token operator\">=</span>?\n\t\tAGE<span class=\"token operator\">=</span>?\n\t\tADDRESS<span class=\"token operator\">=</span>?\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">WHERE</span> \n\t\tID<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"엔티티-삭제\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%82%AD%EC%A0%9C\" aria-label=\"엔티티 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 삭제</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> memberA <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"memberA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>memberA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>앞선 생성/수정과정과 마찬가지로, 삭제쿼리 역시 쓰기지연 저장소에 추가됩니다.</p>\n<p>영속성 컨텍스트에서 즉시 엔티티가 삭제되고, 삭제쿼리가 플러시되면 데이터베이스에서도 삭제됩니다.</p>\n<h3 id=\"플러시\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9F%AC%EC%8B%9C\" aria-label=\"플러시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플러시</h3>\n<p>플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영합니다.( 동기화 )</p>\n<p><strong>동작과정</strong></p>\n<ul>\n<li>변경감지 동작, 변경된 엔티티에 대해 수정쿼리를 만들어 쓰기지연 저장소에 저장</li>\n<li>쓰기지연 저장소에 쿼리를 데이터베이스에 전달( 여기는 삽입,수정,삭제 쿼리 포함입니다)</li>\n</ul>\n<p><strong>플러시를 일으키는 방법</strong></p>\n<ul>\n<li>직접호출: em.flush()를 통해 직접 플러시를 호출하는 방법 ( 실무에서 잘 쓰지 않습니다)</li>\n<li>트랜잭션 커밋: 플러시 없이 트랜잭션만 커밋하면, 데이터베이스에 변경한 데이터가 반영되지 않고, 서버가 종료되는 등의 상황에서 Durability가 보장되지 않는다.</li>\n<li>JPQL 사용: JPQL은, 뒤에서 다루지만 조회쿼리 시 1차캐시를 사용하지 않고 SQL문으로 변환합니다. 이 경우 1차캐시에 저장된 내용이 누락되므로, flush 이후 JPQL이 수행되어야 합니다.</li>\n</ul>\n<p><strong>플러시 모드 옵션</strong></p>\n<ul>\n<li>FlushModeType.AUTO: 커밋이나 쿼리 실행 시 플러시</li>\n<li>FlushModeType.COMMIT: 커밋 실행시 플러시, 최적화를 위한 옵션입니다.</li>\n</ul>\n<h2 id=\"준영속-상태\" style=\"position:relative;\"><a href=\"#%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C\" aria-label=\"준영속 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>준영속 상태</h2>\n<p>엔티티가 준영속”detached” 상태라는 것은, 영속성 컨텍스트에서 분리되어 관리대상에서 벗어남을 의미하며, 앞서 설명한 영속성 컨텍스트의 기능들을 활용할 수 없음을 의미합니다.</p>\n<p>영속성 컨텍스트에서 분리되는 방법: 준영속 엔티티를 만드는 방법</p>\n<ul>\n<li>em.detach(entity);  → 특정 엔티티만을 준영속상태로 만듦</li>\n<li>em.clear(); → 영속성 컨텍스트를 비워, 내부에 있던 엔티티를 준영속상태로 만듦.</li>\n<li>em.close(); → 엔티티매니저를 닫힘.</li>\n</ul>\n<p>준영속과 비영속은 매우 가까운 상태입니다. 하지만, 준영속 상태는 이미 영속된적이 있는 엔티티로, 식별자 값이 존재합니다.</p>\n<p>또한 준영속 → 영속상태로 가는 동작을 merge라고 합니다. 책에서는 길게 설명하지만, 짧게 요약하자면,</p>\n<p>“merge 와 persist는 매우 비슷하지만, merge는 식별자 값을 제외한 값을 영속성 컨텍스트에 복사 후 리턴한다” 입니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저와 엔티티 매니저 팩토리란? 각각의 역할, 특징은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2. 1차캐시의 장점은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  3. 쓰기지연은 무엇이고, 어떤 장점이 있는가?</li>\n</ul>\n<h3 id=\"챕터에-나오지-않지만-알아야하는-부분\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EB%82%98%EC%98%A4%EC%A7%80-%EC%95%8A%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84\" aria-label=\"챕터에 나오지 않지만 알아야하는 부분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 나오지 않지만 알아야하는 부분</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저가 커넥션을 맺는 시점과 끊는 시점</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2.준영속 상태가 되면, 데이터베이스에는 남아있는가?</li>\n</ul>\n<p><strong>복습질문 정답</strong></p>\n<ol>\n<li>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 객체, DB 커넥션 풀을 관리하고,<br>\nJPA의 <strong>엔티티메니저</strong>는 엔티티를 저장/수정/삭제/조회 하는 등, 엔티티와 관련된 많은 일을 처리하는 엔티티 관리자입니다(이름과 같은 역할).<br>\n또한 <strong>영속성 컨텍스트에 엔티티를 저장하면서 캐싱/변경감지/쓰기지연 등, CRUD의 성능을 개선합니다.</strong></p>\n</li>\n<li>\n<p>성능상의 이점과 엔티티 간 동일성을 보장해주는 장점이 있습니다.</p>\n</li>\n<li>\n<p>트랜잭션을 커밋할때까지 엔티티를 1차캐시에 저장해놓고, 쓰기지연 SQL저장소에 쓰기 SQL을 저장해놓는다. 이후 트랜잭션이 커밋되면 flush작업과 함께, 쓰기 SQL을 데이터베이스에 전달하는것을 쓰기지연이라고 하고,</p>\n</li>\n</ol>\n<p><strong>더 알아보기 정답</strong></p>\n<ol>\n<li>엔티티매니저는 데이터가 변경되는 시점에 트랜잭션을 시작합니다.  앤티티메니저의 메서드를 호출 할 때, 트랜잭션 상태가 아니면 <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/TransactionRequiredException.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TransactionRequiredException</a>을 발생시킵니다.</li>\n<li>데이터베이스에는 남아있지만, 1차캐시에는 존재하지 않는 상태가 됩니다.</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n<li><a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle Java Docs(javax.persistence)</a></li>\n</ul>","id":"776bb867-4d09-5c57-9ae5-d6b293e1271d","fields":{"slug":"jpa의-엔티티-매니저와-영속성-관리"},"frontmatter":{"date":"2023-01-03","title":"JPA의 엔티티 매니저와 영속성 관리 ","category":"tech","tags":["JPA","study"],"banner":null},"timeToRead":7},{"excerpt":"JPA를 사용하는 이유와 패러다임 불일치 문제 기존 시스템들에서 어떤 방식을 통해 데이터를 접근했는지, 어떤 문제점들이 있었는지 살펴보고, JPA가 이를 어떻게 해결했는지 살펴봅시다. 목차 주제 1.  JPA 등장 배경 SQL을 기반으로 구현했을 때의 문제점 패러다임 불일치 문제 상속,연관관계 참조, 객체그래프 탐색, 비교 불일치 JPA란? JPA의 장점 JPA의 탄생 배경: SQL을 직접 다룰 때 생기는 문제점 JPA…","html":"<h1 id=\"jpa를-사용하는-이유와-패러다임-불일치-문제\" style=\"position:relative;\"><a href=\"#jpa%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%99%80-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"jpa를 사용하는 이유와 패러다임 불일치 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA를 사용하는 이유와 패러다임 불일치 문제</h1>\n<p>기존 시스템들에서 어떤 방식을 통해 데이터를 접근했는지, 어떤 문제점들이 있었는지 살펴보고, JPA가 이를 어떻게 해결했는지 살펴봅시다.</p>\n<h3 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h3>\n<ul>\n<li>주제 1.  JPA 등장 배경\n<ul>\n<li>SQL을 기반으로 구현했을 때의 문제점</li>\n<li>패러다임 불일치 문제\n<ul>\n<li>상속,연관관계 참조, 객체그래프 탐색, 비교 불일치</li>\n</ul>\n</li>\n<li>JPA란? JPA의 장점</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"jpa의-탄생-배경-sql을-직접-다룰-때-생기는-문제점\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD-sql%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%8B%A4%EB%A3%B0-%EB%95%8C-%EC%83%9D%EA%B8%B0%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"jpa의 탄생 배경 sql을 직접 다룰 때 생기는 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 탄생 배경: SQL을 직접 다룰 때 생기는 문제점</h1>\n<hr>\n<p>JPA이전 관계형 데이터베이스의 데이터를 가져오기 위해서는 JDBC API를 통해 SQL 쿼리를 직접 날려주는 방식을 사용했습니다. 이는 직관적인것을 떠나 매우 직접적인 방법이고, 여러가지 문제점과 불편함이 존재합니다.</p>\n<h3 id=\"sql에-의존적인-개발\" style=\"position:relative;\"><a href=\"#sql%EC%97%90-%EC%9D%98%EC%A1%B4%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C\" aria-label=\"sql에 의존적인 개발 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL에 의존적인 개발</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> tel<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 전화번호 필드 추가</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>데이터에서 하나의 필드(컬럼) 이 추가될 때, SQL을 직접 매핑해 개발하는 방식에서는 삽입,조회,변경,삭제 시 많은 코드 변경이 필요합니다.</p>\n<ul>\n<li>생성코드 변경:  SQL 수정 / Prepared Statement에 필드 추가하는 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token string\">\"INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) values(?,?,?);\"</span><span class=\"token punctuation\">;</span>\n''' \npstmt<span class=\"token punctuation\">.</span><span class=\"token function\">setString</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getTel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>조회코드 변경 :  SQL수정 / 필드 가져오는 코드 / 필드 설정하는 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token string\">\"SELECT MEMBER_ID, NAME, TEL from MEMBER WHERE MEMBER_ID = ?\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> tel <span class=\"token operator\">=</span> rs<span class=\"token punctuation\">.</span><span class=\"token function\">getString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TEL\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"XXX\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>연관객체 조회: Member가 Team이라는 연관된 데이터를 새로 개발하는 경우, member.getTeam().getTeamName()을 통해 멤버가 속한 팀을 가져오는 마법같은 일은 벌어지지 않습니다. DAO에서 SQL Join을  통해 다른 테이블을 연결해야 가능합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> M<span class=\"token punctuation\">.</span>MEMBER_ID<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">.</span>NAME<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">.</span>TEL<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span>TEAM_ID<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span>TEAM_NAME \n\t<span class=\"token keyword\">FROM</span> MEMBER M \n\t<span class=\"token keyword\">JOIN</span> TEAM T <span class=\"token keyword\">ON</span> M<span class=\"token punctuation\">.</span>TEAM_ID <span class=\"token operator\">=</span> T<span class=\"token punctuation\">.</span>TEAM_ID</code></pre></div>\n<p>많은 비즈니스 로직에서 데이터 간 연관관계가 존재하는데, 위같이 SQL에 의존하는 개발을 하는 경우, “진정한 계층 분할이 어렵다”는 문제가 있습니다.</p>\n<p>DAO를 통해 데이터에 접근하는 로직만 분리했을 뿐이지, 필드를 추가할때만 해도 SQL과 CRUD와 관련된 코드를 추가해야하기 때문이다. 이때문에 엔티티를 신뢰할 수 없게됩니다.</p>\n<h3 id=\"jpa와-문제-해결\" style=\"position:relative;\"><a href=\"#jpa%EC%99%80-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"jpa와 문제 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA와 문제 해결</h3>\n<p>JPA는 위에서 소개한 문제들을 효율적으로 해결합니다.</p>\n<ul>\n<li>조회기능: 객체의 필드를 바탕으로 SELECT SQL 을 생성하고, 그 결과를 Member객체로 생성해 반환합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"MyeonggGyu Lee\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>수정기능: “영속상태”에 있는 엔티티의 변경을 감지해, 트랙잭션이 커밋될 때 Update SQL문을 전달합니다.\n<ul>\n<li>“변경감지”란 EntityManager에서 엔티티를 영속할 때 Snapshot을 저장하고 트랜잭션 커밋 시 이와 비교하므로서 변경을 감지하는 동작이 가능합니다.  (CH3에서 본격적으로 다룬다.)</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Changed_Name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>연관객체 조회:  JPA는 연관객체를 조회하는 시점에 적절한 SELECT문을 실행합니다. JPA에서는 단순히 객체그래프를 탐색하는것만으로 수행할 수 있는데, 이를 위해 실제 객체의 참조를 저장하는 프록시를 반환하고, 이를 지연로딩이라 합니다. (H2에서 지연로딩은 프록시와 바이트코드 수정을 통한 방법이 있고, CH8에서 본격적으로 다룬다.)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> teamName<span class=\"token operator\">=</span> team<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"패러다임-불일치-문제\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"패러다임 불일치 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패러다임 불일치 문제</h1>\n<hr>\n<p>관계형 데이터베이스와  객체지향 프로그래밍 언어는 그 목적이 다른만큼 데이터의 기본 단위인 레코드와 객체의 기능과 표현 방법이 다릅니다. 따라서, 개발자가 이를 중간에서 해결해주어야 하지만, 이를 일일히 해결하는것은 너무 많은 리소스를 투입해야하는 작업입니다.</p>\n<p>이같은 패러다임 불일치로 생기는 문제 또한 여러가지가 있으며, JPA가 어떤 방법으로 이를 해결하는지 살펴보겠습니다.</p>\n<h2 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h2>\n<p>객체의 경우 상속이라는 기능을 통해 다형성을 제공하지만, 대부분의 데이터베이스는 상속 기능이 없습니다.</p>\n<p>아래 그림과 같이 서브타입과 슈퍼타입을 사용하면 그나마 해결이 가능하지만, 이는 많은 불편함을 초래합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210951775-582b7a16-6641-4a51-862f-11148a8f158b.png\" alt=\"Untitled\"></p>\n<p>위의 경우, 만약 ALBUM 객체를 저장하기 위해서는 두 개의 INSERT문이 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ITEM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span> NAME<span class=\"token punctuation\">,</span> PRICE<span class=\"token punctuation\">,</span> DTYPE<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ALBUM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span>ARTIST<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>만약 데이터베이스를 사용하지 않고 자바 컬렉션(Ex, ArrayList)에 저장한다면, **list.add(album)**처럼  부모 객체에 대해 고려하지 않고도 데이터를 저장할 수 있습니다.</p>\n<p>이처럼 상속으로 인한 자바 객체와 관계형 데이터베이스 사이의 패러다임 불일치문제는 분명히 존재하는것을 알아보았습니다 .</p>\n<p>JPA에 상속하는 객체를 저장하면 상속에 의한 패러다임 불일치문제를 개발자 대신 해결해줍니다.</p>\n<p>JPA의 EntityManager에 객체를 저장하면, ITEM,ALBUM 테이블에 데이터를 각각 나누어 저장합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">jpa<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>album<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ITEM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span> NAME<span class=\"token punctuation\">,</span> PRICE<span class=\"token punctuation\">,</span> DTYPE<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ALBUM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span>ARTIST<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이후 album 객체를 찾고자 할 때, ITEM, ALBUM 테이블을 조인해서 데이터를 조회하고, 그 결과를 반환합니다 .</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> I<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> \n\t\t<span class=\"token keyword\">FROM</span> ITEM I \n\t\t<span class=\"token keyword\">JOIN</span> ALBUM A <span class=\"token keyword\">ON</span> A<span class=\"token punctuation\">.</span>ITEM_ID <span class=\"token operator\">=</span> I<span class=\"token punctuation\">.</span>ITEM_ID<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"연관관계\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계</h3>\n<p>객체는 <strong>참조</strong>를 통해서 다른 객체와 연관관계를 가지고, <strong>참조에 접근</strong>을 통해 연관관계의 객체를 조회합니다. 반면 관계형 데이터베이스의 테이블은 <strong>외래 키</strong>를 통해 다른 테이블과 연관관계를 가지고, <strong>JOIN</strong>을 통해 연관된 테이블을 조회합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token class-name\">Team</span> <span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> team<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> M<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> \n\t<span class=\"token keyword\">FROM</span> MEMBER M \n\t<span class=\"token keyword\">JOIN</span> TEAM T <span class=\"token keyword\">ON</span> M<span class=\"token punctuation\">.</span>TEAM_ID <span class=\"token operator\">=</span> T<span class=\"token punctuation\">.</span>TEAM_ID</code></pre></div>\n<p>위에서 다룬 상속에서의 패러다임 불일치문제는 서브타입/슈퍼타입을 통해 객체지향적으로 데이터를 다룰 수 있었지만, 연관관계로 인한 패러다임 불일치 문제는 객체지향적으로 풀어내기에 꽤 복잡합니다.</p>\n<p>객체는 다른 연관관계를 조회하고자 할 때, 외래키 대신 참조만 있으면 되고, RDB의 테이블에서는 참조 대신 외래키만 있으면 조회가 가능합니다.</p>\n<p>또한, 객체는 member.getTeam()을 통한 member → team 으로의 단방향 조회만 가능하지만, team에서 member에 대한 참조가 없으므로, team.getMember()을 통한 team → member 조회가 불가능합니다.</p>\n<p>(RDB에서는 외래키를 통해 양방향으로 연관관계를 Join할 수 있습니다)</p>\n<ul>\n<li>저장 시</li>\n</ul>\n<p>(직접구현) 개발자는 객체에서의 연관관계만 지정해주면, team의 참조를 외래키로 변환해 INSERT SQL문을 데이터베이스에 전달합니다.</p>\n<p>(JPA 사용)JPA에서는 이런 연관관계로 인한 패러다임 문제 역시 해결해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njpa<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njpa<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>조회 시</li>\n</ul>\n<p>(직접구현) 조회시에는 TEAM_ID 외래 키 값을 Member 객체의 team 참조로 변활해 객체로 저장합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Member</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//SQL 실행 후, 멤버 데이터 입력</span>\n\n\t\t<span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// team 외래키를 통해 팀 정보 조회 후, 팀 관련 정보 입력</span>\n\n\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//팀 연관관계 생성</span>\n\n\t\t<span class=\"token keyword\">return</span> meber<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(JPA 사용) 마찬가지로  jpa entitymanager를 통해 find하면, 위의 과정을 간단하게 수행할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">.</span> <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"객체-그래프-탐색\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89\" aria-label=\"객체 그래프 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 그래프 탐색</h3>\n<p>실제 데이터의 연관관계가 복잡하게 얽혀있는 구조를 생각해보자. 예를 들어 아래와 같다고 해보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210951768-9a789a7c-579a-4a1b-b571-fa684e3cab82.png\" alt=\"jpabook-48 drawio\"></p>\n<p>만약 DAO를 통해 SQL을 직접 조작한다고 해보자. 아래와 같은 자유로운 객체그래프 탐색이 가능할끼?</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span>getOrder<span class=\"token punctuation\">.</span><span class=\"token function\">getOrderItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>get…<span class=\"token punctuation\">.</span></code></pre></div>\n<p>만약 member을 조회하는 기능에서 order까지 참조로 저장하였다면, getOrder까지는 성공할 것이다. 하지만 그 이후부터는 데이터가 존재하지 않으므로 탐색할 수 없다.</p>\n<p>비즈니스 로직에 따라 객체 그래프를 자유롭게 탐색할 수 있어야하지만, DAO내부에서 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지가 정해집니다. 결국 객체 그래프를 탐색할때마다 새로운 메서드와 SQL을 만들어야하는 복잡하고 불편한 상황이 연출됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmemberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMemberWithOrderWithDelivery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>앞서 해결했던 문제들과 달리, 객체 그래프 탐색 문제는 소스코드 몇줄을 추가한다 해서 해결될 수 없습니다.  member와 관련된 모든 객체들을 메모리에 올려놓으면, 엄청난 메모리 낭비가 발생하기 때문이죠.</p>\n<p>JPA는 실제 객체 사용 시점까지 데이터베이스 조회를 미루는 <strong>지연로딩</strong>을 통해 해당 문제를 해결합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Order</span> order <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\norder<span class=\"token punctuation\">.</span><span class=\"token function\">gerOrderDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Order객체를 사용하는 시점에 SELECE Order 쿼리를 날림. </span></code></pre></div>\n<h3 id=\"비교-불일치\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%90-%EB%B6%88%EC%9D%BC%EC%B9%98\" aria-label=\"비교 불일치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비교 불일치</h3>\n<p>데이터베이스에서는 기본 키(PK)를 통해 데이터를 비교합니다. 반면 객체는 동일성과 동등성을 통해 데이터를 비교합니다.</p>\n<p><strong>동일성</strong> 비교는 “==”을 통해 비교합니다. 객체의 주소값을 비교하는 비교방법입니다.</p>\n<p><strong>동등성</strong> 비교는 “equals()”메서드를 통해 비교합니다.  객체 내부 값을 비교합니다.</p>\n<p>SQL을 통해 Java에서 데이터베이스 레코드를 여러 번 불러왔을 때, 비교과정에 대해 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"12\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> m1 <span class=\"token operator\">=</span> memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> m2 <span class=\"token operator\">=</span> memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>m1 <span class=\"token operator\">==</span> m2<span class=\"token punctuation\">)</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Equal\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not Equal\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ouput : Not Equal</span></code></pre></div>\n<p>m1과 m2는 같은 member id를 통해 조회했으므로 그 내용은 같겠지만, 동일한 객체는 아닙니다. equals메서드를 통해 내용만 비교하면 되지 않나 라는 생각을 할 수 있지만, 만약 두 객체가 다른 스레드에서 각각 생성되고, 변경된다고 가정하면, 예상하지 않은 결과를 가져올 것입니다.</p>\n<p>JPA에서는 같은 트랜잭션일 때, 같은 객체가 조회되는 것을 보장한다. 이는 엔티티메니저의 식별자를 통해 가능하다.</p>\n<h1 id=\"jpa란-무엇인가\" style=\"position:relative;\"><a href=\"#jpa%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"jpa란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA란 무엇인가</h1>\n<p>Java Persistence API의 약자로, 자바 진영의 ORM 기술.</p>\n<h3 id=\"orm이란\" style=\"position:relative;\"><a href=\"#orm%EC%9D%B4%EB%9E%80\" aria-label=\"orm이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM이란?</h3>\n<p>Object Relational Mapping으로, 객체와 관계형 데이터베이스를 매핑하는 기술로, 앞서 설명했던 패러다임 불일치 문제를 해결해준다.</p>\n<h3 id=\"jpa를-사용해야하는-이유\" style=\"position:relative;\"><a href=\"#jpa%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"jpa를 사용해야하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA를 사용해야하는 이유?</h3>\n<ul>\n<li><strong>생산성</strong>: JPA를 사용하면 자바 컬렉션 객체에 저장하듯 엔티티메니저에 저장하면, JDBC API를 사용하는 반복적인 SQL 작성은 JPA가 대신 처리해준다</li>\n<li><strong>유지보수성</strong>: SQL을 직접 매핑하면 필드가 추가될 때마다 많은 양의 코드가 추가되었지만, JPA에서는 필드가 추가/삭제되더라도 변경되는 코드가 줄어든다.</li>\n<li><strong>패러다임 불일치 해결</strong>: 앞서 살펴본 상속, 연관관계, 객체그래프 탐색, 비교 불일치 등으로 인한 패러다임 불일치 문제를 해결해준다</li>\n<li><strong>성능:</strong> 엔티티메니저의 1차캐시는 앞서 살펴본것같이 동일성을 보장해주기도 하지만, 캐시의 역할과 쓰기지연 저장소 역할도 수행한다.</li>\n<li><strong>벤더 독립성:</strong> 데이터베이스는 같은 기능이어도 벤더마다 사용법이 다른 경우가 많다. JPA는 다른 데이터베이스 벤더들을 하나로 통합한 방언(Dialect)을 제공해 데이터베이스 기술을 추상화하고, 특정 기술에 종속되지 않도록 한다.</li>\n</ul>\n<hr>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1. SQL을 직접 다뤄서 생기는 문제점에는 어떤것이 있는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2. 객체지향 프로그래밍과 관계형 데이터베이스의 데이터의 패러다임 불일치에는 어떤 문제들이 있는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  3.JPA를 사용해 얻을 수 있는 이점은 무엇인가?</li>\n</ul>\n<h3 id=\"챕터에-나오지-않지만-알아야하는-부분들\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EB%82%98%EC%98%A4%EC%A7%80-%EC%95%8A%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EB%93%A4\" aria-label=\"챕터에 나오지 않지만 알아야하는 부분들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 나오지 않지만 알아야하는 부분들</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  1. member.setName()만으로 데이터를 수정할 수 있는 개념인 “변경감지” 란 무엇인가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  2.member.getTeam()을 통해 연관객체를 불러올 수 있는 원리는 무엇인가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  3.JPA 구현체인 H2에서는 지연로딩을 구현하는 방법으로 무엇들이 있는가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  4.JPA에서 같은 레코드에 대한 동일성을 보장하는 방법은 무엇인가?</p>\n<p>정답</p>\n<ol>\n<li>\n<p>패러다임 불일치 문제 → 계층분할 힘듦 → 코드 작업량 증가,</p>\n</li>\n<li>\n<p>상속, 연관관계 참조, 객체그래프 탐색,  비교 방법 불일치 문제</p>\n</li>\n<li>\n<p>생산성,유지보수, 성능, 벤더 독립성</p>\n</li>\n<li>\n<p>엔티티매니저에서 객체 영속 시 스냅샷을 저장하고,commit, JPQL등으로 인한 커밋 시, 스냅샷과 엔티티를 비교하는 방법</p>\n</li>\n<li>\n<p>지연로딩. 프록시객체를 가지고있다가 해당 객체가 사용되는 시점에 SQL 실행</p>\n</li>\n<li>\n<p>바이트코드 수정, 프록시</p>\n</li>\n<li>\n<p>엔티티매니저 1차캐시에 식별자 비교를 통해서 동일성 보장</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>","id":"a30b6231-38b0-55d3-a1ec-a7ac7a7bf4ff","fields":{"slug":"패러다임-불일치-문제와-jpa를-사용하는-이유"},"frontmatter":{"date":"2022-12-19","title":"패러다임 불일치 문제와 JPA를 사용하는 이유 ","category":"tech","tags":["JPA","study"],"banner":null},"timeToRead":9},{"excerpt":"본 글은  Link: Spring 공식문서에서 1절을 읽고 궁금한점을 찾아보며 정리한 글입니다. 1.1  Introduction to the Spring IoC Container and Beans 1.2  Container Overview 1.3  Bean Overview ...and so on Spring IoC Container와 ApplicationContext IoC, Inversion of Control…","html":"<p>본 글은  <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Link: Spring 공식문서에서 1절</a>을 읽고 궁금한점을 찾아보며 정리한 글입니다.</p>\n<ul>\n<li>1.1  Introduction to the Spring IoC Container and Beans</li>\n<li>1.2  Container Overview</li>\n<li>1.3  Bean Overview</li>\n</ul>\n<p>...and so on</p>\n<h1 id=\"spring-ioc-container와-applicationcontext\" style=\"position:relative;\"><a href=\"#spring-ioc-container%EC%99%80-applicationcontext\" aria-label=\"spring ioc container와 applicationcontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring IoC Container와 ApplicationContext</h1>\n<p>IoC, Inversion of Control은 직역하면 제어의 역전이라는 뜻을 가지고있으며, Spring의 주요 특징 중 하나입니다.</p>\n<p>IoC의 예시로, Dependency Injection(DI)를 들 수 있는데요, 런타임 시점의 의존관계는 의존 대상 인스턴스가 아니라 컨테이너나 팩토리가 결정하며, 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않기 때문에,  (DI의 경우) 의존성 설정에 대한 제어권이 역전된 모습이라 해 제어의 역전이라고 합니다.</p>\n<p><code class=\"language-text\">org.springframework.beans</code> 와 <code class=\"language-text\">org.springframework.context</code> 패키지는 Spring IoC컨테이너의 근간이 되는 패키지입니다.<br>\n그 중에서도, <code class=\"language-text\">org.springframework.beans.factory</code>패키지의 <code class=\"language-text\">BeanFactory</code> 인터페이스는 모든 타입의 객체에 고급 설정을 구성할 수 있는 메커니즘을 제공합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/202149288-44e3789f-9fd7-4eaf-b5d3-4221be5c9e3d.png\" alt=\"IoCContainer drawio (1)\"></p>\n<p><code class=\"language-text\">BeanFactory</code> 의 하위 인터페이스인 <code class=\"language-text\">ApplicationContext</code>가 제공하는 기능입니다.</p>\n<ul>\n<li>\n<p>Spring AOP 통합</p>\n</li>\n<li>\n<p>메시지 리소스 국제화</p>\n</li>\n<li>\n<p>이벤트 생성</p>\n</li>\n<li>\n<p><code class=\"language-text\">WebApplicationContext</code>같은 애플리케이션 레이어 컨텍스트 제공</p>\n</li>\n</ul>\n<p>간단히 말하자면, <code class=\"language-text\">BeanFactory</code> 는 Spring 기본 기능과 설정 기능을 제공하고, <code class=\"language-text\">ApplicationContext</code>는 enterprise application에 특화된 기능을 제공합니다. <code class=\"language-text\">ApplicationContext</code>가 기능적으로 <code class=\"language-text\">BeanFactory</code>를 모두 포함하기때문에, 위에서 설명한 추가기능을 사용하기 위해서 기본적으로 <code class=\"language-text\">ApplicationContext</code>를 사용하는게 좋습니다.</p>\n<p>Spring에서는 애플리케이션의 중추를 담당하고 IoC컨테이너가 관리하는 객체를 빈(bean)이라고 합니다. 빈은 애플리케이션의 일반적인 객체와 달리, IoC 컨테이너에 의해 조합되거나 관리되는 객체이고, 컨테이너가 사용하는 설정 메타데이터에 의해 반영됩니다. (groovy script, xml파일이나 annotation 등)</p>\n<h1 id=\"ioc-container에-대해서\" style=\"position:relative;\"><a href=\"#ioc-container%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"ioc container에 대해서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IoC Container에 대해서</h1>\n<p><code class=\"language-text\">org.springframework.context.ApplicationContext</code> 인터페이스는 스프링의 IoC 컨테이너를 나타내고, 빈의 인스턴스화, 설정, 조합(instantiating, configuring, assembling)을 담당합니다. 즉, (IoC)컨테이너는 설정 메타정보를 읽으며 어떤 객체를 인스턴스화할지, 설정할지, 조합할지에 대한 명령어를 읽어들입니다. 설정 메타데이터는 XML, Java annotations, Java code에 존재합니다.</p>\n<p>기존에 많은 경우에 XML을 통해 설정을 해왔지만, XML 코드를 추가해 Java annotation을 통해 설정할 수 있도록 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>context</span> <span class=\"token attr-name\">:</span> <span class=\"token attr-name\">component-scan</span> <span class=\"token attr-name\">base-package</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.sample<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n</code></pre></div>\n<p>위와같은 설정파일을 추가하면 <code class=\"language-text\">@Component, @Repository, @Service, @Controller, @RestController, @Configuration</code>를 base-package에서 찾아 빈으로 등록합니다.</p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/container-magic.png\" alt=\"img\"></p>\n<p>위 그림은 IoC 컨테이너가 어떤 동작을 하는지에 대한 간단한 과정입니다. 컨테이너는 비즈니스 로직을 포함한 POJO 객체와 설정 메타데이터를 로드해 실행가능한 애플리케이션을 생산해냅니다.</p>\n<p>이때, Business Object뒤에 POJO 객체라고 정확히 지칭한부분이 재미있습니다. 직접 의존성을 로드해 개발했을 때 객체가 무거워지고 결합도가 높아지는 단점이 생겼고, 의존성 라이브러리를 결합해서 사용할 수 있도록 IoC의 개념 중 하나인 DI가 생겨났기 때문입니다. POJO라고 특정지어서 말하는 부분은 이 부분을 강조하는듯 합니다.</p>\n<p>단적인 예로, 이전에는 JDBC드라이버를 직접 로드해서 커넥션을 맺고 끊는 로직을 직접 구현했다면, 최근에는 JPA나 MyBatis등의 라이브러리, 심지어 JDBC API까지도 XML설정 또는 애너테이션을 통해 DAO 빈을 생성하면 POJO만으로도 비즈니스 로직을 구현해낼 수 있게 되었고, 결합도가 낮아져 리팩토링이나 확장에 들어가는 작업량이 현저히 줄었습니다.</p>\n<h3 id=\"configuration-metadata\" style=\"position:relative;\"><a href=\"#configuration-metadata\" aria-label=\"configuration metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Configuration Metadata</h3>\n<p>그림에서 컨테이너가 설정 메타데이터를 사용하는 부분을 확인했습니다. 설정 메타데이터는 컨테이너에게 Bean이 무엇이고 어떻게 인스턴스화하고 조립할지에 대해 알려주는 정보입니다. 이 정보를 쓰는 방법을 간단하게만 알아보겠습니다.</p>\n<blockquote>\n<p>참고로, 스프링 설정 메타데이터를 작성하는 방법은 몇가지가 있으나, 작성하는 포멧 형식은 컨테이너와 분할되어있으므로, 어떤 형식으로 작성하는지는 중요하지 않습니다.</p>\n</blockquote>\n<ul>\n<li>XML: <code class=\"language-text\">beans</code>라는 루트 엘리먼트 하위에 <code class=\"language-text\">bean</code> 엘리먼트를 선언하는 방식</li>\n<li>Java: <code class=\"language-text\">@Configuration</code> 애너테이션을 가진 클래스 하위에 <code class=\"language-text\">@Bean</code>애너테이션을 가진 메서드를 선언하는 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span><span class=\"token punctuation\">></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>services.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>resources/messageSource.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/resources/themeSource.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bean1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bean2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>일반적인 XML설정 메타데이터는 위와 같이 구성합니다. bean의 id에는 빈을 유일하게 식별할 수 있는 id, class에는 빈에 해당하는 클래스명을 패키지까지 포함해 작성합니다.</p>\n<p>import를 통해 다른 파일의 설정을 불러올 수 있습니다. resource, 경로에 해당하는 부분은 가급적 상대경로를 포함하지 않습니다. (애플리케이션 외부에 종속성이 생길 수 있기 때문)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathXmlApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"services.xml\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"daos.xml\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token class-name\">PetStoreService</span> service <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"petStore\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">PetStoreService</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> userList <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">getUsernameList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 앞서 언급했듯 빈들은 BeanFactory를 상속한 <code class=\"language-text\">ApplicationContext</code>에 의해 관리되므로, 위같은 방법으로  인스턴스화된 빈들을 가져올 수 있습니다. 하지만 비즈니스로직에서 이같이 선언적 방법으로 빈을 로드하는것은 권장하지 않는 방법입니다.</p>\n<h1 id=\"bean에-대해서\" style=\"position:relative;\"><a href=\"#bean%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"bean에 대해서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean에 대해서</h1>\n<p>아래 내용은 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">1.3 Bean Overview</a> 및 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">1.The IoC Container</a>에서 원문으로 확인할 수 있습니다.</p>\n<h3 id=\"bean의-생성과정\" style=\"position:relative;\"><a href=\"#bean%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC%EC%A0%95\" aria-label=\"bean의 생성과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean의 생성과정</h3>\n<ul>\n<li>\n<p>Bean을 생성하기 위해 [XML,Java,Groovy]로 이뤄진 Configuration Metadata(설정 메타데이터)를 작성합니다.</p>\n</li>\n<li>\n<p>컨테이너는 설정 메타데이터를 통해 <code class=\"language-text\">패키지가 포함된 클래스명</code> <code class=\"language-text\">동작 구성요소(생명주기, 콜백,스코프 등)</code> <code class=\"language-text\">다른 Bean 의존성</code>, <code class=\"language-text\">Bean 설정(property)</code>를 <code class=\"language-text\">XML,Java,Groovy BeanDefinitionReader</code>를 통해 <code class=\"language-text\">BeanDefinition</code>으로 구성합니다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">BeanDefinition은</code> 아래와 같은 정보를 포함하게 되며, 결과적으로 컨테이너는 설정파일을 어떤 형식으로 구성해도 <code class=\"language-text\">BeanDefinition</code>이라는 일관된 객체를 불러올 수 있습니다. 공식문서에서는 BeanDefinition객체를 '레시피'라고 표현합니다. 여러개의 Bean 인스턴스를 생성해도 같은 객체를 생성할 수 있도록 합니다.</p>\n</li>\n</ul>\n<h3 id=\"beandefinition의-구성요소와-bean의-특징\" style=\"position:relative;\"><a href=\"#beandefinition%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C%EC%99%80-bean%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"beandefinition의 구성요소와 bean의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BeanDefinition의 구성요소와 Bean의 특징</h3>\n<ul>\n<li>\n<p>Class: 인스턴스화할 빈 클래스. Java Config의 경우 Return Class의 패키지경로+클래스이름, XML Config의 경우 class 프로퍼티로 자동 지정되며, 필수값입니다.</p>\n</li>\n<li>\n<p>Name: Bean을 하나로 구분할 수 있도록 하는 식별자. XML의 경우 id, name프로퍼티를 사용해 IoC Container가 지정합니다. Java의 경우, @Bean프로퍼티가 붙은 메서드의 이름으로 지정됩니다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//(Class, Id, Name 적용 예시)</span>\r\n<span class=\"token annotation punctuation\">@Configuration</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppConfig</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token annotation punctuation\">@Bean</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CouponService</span> <span class=\"token function\">couponService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CouponService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span><span class=\"token punctuation\">></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>couponService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.demo.service.CouponService<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\r\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>\n<p>Scope: singleton, prototype, session, request 등 Bean을 생성하는 방법과 생명주기에 관련된 요소입니다.</p>\n</li>\n<li>\n<p>Constructor arguments: 생성자 인자들입니다. 생성자를 통해서 Bean 의존성을 설정할 수 있습니다.</p>\n</li>\n<li>\n<p>Properties: Bean에 저장되는 속성값입니다.(JDBC의 경우 max-pool등의 것들)</p>\n</li>\n<li>\n<p>Autowiring mode:</p>\n</li>\n<li>\n<p>Late initialization mode</p>\n</li>\n<li>\n<p>Initialization method</p>\n</li>\n<li>\n<p>Destruction  method</p>\n</li>\n</ul>\n<h3 id=\"bean-의-scope\" style=\"position:relative;\"><a href=\"#bean-%EC%9D%98-scope\" aria-label=\"bean 의 scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean 의 scope</h3>\n<p>앞서 말했듯, scope는 Bean의 생성방법이나 생명주기를 나타내는 요소입니다. BeanDefinition에서 scope라는 구성을 제공하므로서 Bean을 생성하고 Java Class계층에서 자신의 생성방법을 정의하지 않아도 되고, 생성/소멸에 관련된 부분에 대해 이미 정해진 방법으로 동작할 수 있도록 합니다.</p>\n<p><code class=\"language-text\">singleton</code>: 기본값이며, 하나의 빈 인스턴스가 공유됩니다. 컨테이너는 여러번의 생성 요청에도 하나의 특정 빈 인스턴스만을 리턴하기때문에, 하나의 BeanDefinition에 하나의 Bean 인스턴스를 갖습니다.</p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/singleton.png\" alt=\"img_singleton\"></p>\n<p><code class=\"language-text\">prototype</code>: 싱글톤과 달리, 모든 요청에 대해 Bean을 인스턴스화하므로, == 연산자 비교(레퍼런스 비교) 시 false를 반환합니다. <strong>또한 prototype으로 생성된 bean instance들은 spring container의 관리대상이 아니므로, 사용을 완료한 prototype bean은 직접 자원을 해제하거나 lifecycle callback등을 이용해 자원을 해제해야 합니다.</strong></p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/6.0.3-SNAPSHOT/reference/html/images/prototype.png\" alt=\"img_prototype\"></p>\n<p>&#x3C;Singleton과 Prototype Bean 비교></p>\n<p>JPA같이 EntityManager를 통해 데이터를 관리하는 경우, 이를 prototype bean으로 설정하는 경우, 매번 새로운 EM을 반환합니다. 이런 경우, singleton으로 빈을 생성해야 합니다.</p>\n<p>유저 정보를 저장하는 Bean이 있다고 가정하면, singleton으로 생성하는 경우 동시성 문제 또는 초기화 문제로 잘못된 데이터를 사용할 걱정이 있습니다. 이런 경우 prototype 빈을 생성해야 합니다.</p>\n<p>아래의 request, session, application, socket scope는 Spring framework의 ApplicationContext아래에서만 사용할 수 있는 scope입니다.</p>\n<p><code class=\"language-text\">request</code>: HTTP 단일 요청과 같은 생명주기를 갖는 BeanDefinition. 각각의 요청이 하나의 Bean 인스턴스를 갖게됩니다.</p>\n<p><code class=\"language-text\">session</code>: HTTP Session과 같은 생명주기를 갖습니다.</p>\n<p><code class=\"language-text\">application</code>: ServletContext와 같은 생명주기를 갖습니다.</p>\n<p><code class=\"language-text\">websocket</code>: Websocket과 같은 생명주기를 갖습니다.</p>\n<h1 id=\"후기\" style=\"position:relative;\"><a href=\"#%ED%9B%84%EA%B8%B0\" aria-label=\"후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>후기</h1>\n<p>Spring은 추상화가 정말 잘 되어있는 프레임워크라 개인적으로 공부할때 의문이 생기는게 많았는데, 오히려 자세히 설명된 글을 읽으니까 더 재밌네요. 다음으론 추상화 끝판왕 AOP부분에 대해 살펴볼듯 싶습니다.</p>\n<p>Spring의 IoC, Bean을 공부하며 이 개념으로 뭔갈 할 수 있겠다 라는 생각보다는 이미 숨쉬듯 사용하던 코드들이\r\n내부적으로 어떻게 동작하는지 공부한 느낌이었습니다! Bean과 관련된 에러는 이제 조금 친숙하지 않을까 생각합니다.</p>","id":"b2b57dbe-180b-5d8f-9ef1-c9a464946168","fields":{"slug":"spring-framework의-io-c와-bean이란"},"frontmatter":{"date":"2022-11-17","title":"Spring Framework의 IoC와 Bean이란","category":"tech","tags":["spring framework","IoC","Bean"],"banner":null},"timeToRead":6},{"excerpt":"데이터베이스 인덱스 데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다. Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다. Clustered Index…","html":"<h1 id=\"데이터베이스-인덱스\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"데이터베이스 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 인덱스</h1>\n<p>데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다.</p>\n<p>Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다.</p>\n<h1 id=\"clustered-index\" style=\"position:relative;\"><a href=\"#clustered-index\" aria-label=\"clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clustered Index</h1>\n<p>Clustered Index는, Primary Key에 주로 사용되며 실제 데이터가 정렬된 상태로 존재합니다. 어떤 칼럼을 Clustered Index Key로 지정하는 경우 하나의 키만이 Clustered Index Key로 지정될 수 있으며, 지정 시 모든 데이터를 정렬해야하므로 많은 시간이 필요합니다.</p>\n<h3 id=\"인덱스-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777748-1cdb21e0-8f9d-4220-b542-583272432b22.png\" alt=\"Clustered Index drawio\"></p>\n<p>클러스터드 인덱스의 경우 인덱스 키값과 데이터페이지 주소가 저장되며, 두 번의 페이지 조회만에 데이터를 찾을 수 있습니다.</p>\n<h1 id=\"non-clustered-index\" style=\"position:relative;\"><a href=\"#non-clustered-index\" aria-label=\"non clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non Clustered Index</h1>\n<p>InnoDB는 B+Tree 자료구조를 통해 인덱스 데이터를 관리합니다. B+Tree는 자식이 2개 이상인 m-ary 균형(Balanced) 트리입니다.</p>\n<ul>\n<li>N개 데이터에 대한 조회에 O(Log(N))의 시간복잡도를 가집니다. 이는 데이터가 일정수준 이상일 때, Full Scan 방식인 O(N)에 비해 월등히 빠른 속도입니다.</li>\n<li>삽입,삭제는 인덱스 트리에 대한 수정과 더불어 , 불균형 있는 경우 Rebalancing과정까지 추가되어 인덱스를 적용하기 전보다 느려집니다. 이는 B+Tree가 깊이를 일정하게 하기 위한 rebalancing과정에서 소요되는 시간입니다.</li>\n<li>인덱스 트리를 저장하기 위해 전체 데이터의 10%정도에 해당하는 추가 저장공간을 사용합니다.</li>\n</ul>\n<h3 id=\"인덱스-구조-1\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0-1\" aria-label=\"인덱스 구조 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777762-504433d0-48d2-4609-9bb4-a3f1a580f9ea.png\" alt=\"Non Clustered Index drawio\"></p>\n<p>트리의 루트 및 브랜치 노드에는 키값과 인덱스 페이지의 주소가 담겨있고, 인덱스 키값으로 정렬된 모습을 확인할 수 있습니다.<br>\n트리의 리프 노드에는 키값과 데이터 페이지의 주소와 슬롯이 담겨있어 루트노드에서 리프노드까지 트리를 탐색하며 키에 해당하는 데이터를 가져올 수 있습니다.<br>\n(<em>추가적으로, 부모/자식노드간 키가 중복으로 들어가며, 리프노드들이 링크드 리스트 형태로 연결되었다는 특징이 있습니다. InnoDB는 여기서 조금 더 발전해 같은 레벨의 노드들이 더블 링크드 리스트로 연결되어 있습니다.)</em></p>\n<h2 id=\"페이지란\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80%EB%9E%80\" aria-label=\"페이지란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지란?</h2>\n<p>데이터베이스는 디스크에 페이지라는 단위로 데이터를 저장합니다. InnoDB에서는 16KB로 고정된 크기를 가지기 때문에, 인덱스를 구성하는 키가 커질수록 페이지에 저장할 수 있는 키가 적어지고, B+Tree의 깊이가 깊어져 성능 저하를 가져오게 됩니다.</p>\n<p>극단적으로 말했을 때, 페이지 주소가 12Byte이고 Varchar(1024)인 1KB 사이즈의 게시글 내용을 인덱스 키로 지정한다면,<br>\n한 페이지에 (16 * 1024) / (12 + 1024) = 15.xx로, 15개의 키밖에 저장할 수 없습니다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Database_index#Index_concurrency_control\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">위키피디아 https://en.wikipedia.org/wiki/Database_index</a></p>\n<p><a href=\"https://jojoldu.tistory.com/m/243\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">향로님 블로그</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#B-Tree_%EC%9D%B8%EB%8D%B1%EC%8A%A4_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">인파님 블로그, 인덱스 총정리</a></p>","id":"f0da8866-3059-5999-9f12-9ad8bbfb644a","fields":{"slug":"데이터베이스-인덱스"},"frontmatter":{"date":"2022-10-17","title":"데이터베이스 인덱스","category":"tech","tags":["computerscience","database","index"],"banner":null},"timeToRead":2},{"excerpt":"운영체제 Heap 메모리 영역에 접근해 사용하지 않는 Object를 정리해주는 JVM의 구성요소입니다. 개발자가 직접적으로 메모리 해제를 C/C++과 달리, JVM에서는 GC를 제공해 개발에만 집중하고, Memory Leak을 신경쓰지 않아도 됩니다.  JVM은 다음과 같은 구성요소가 존재합니다. 실행엔진 : 자바 인터프리터(interpreter) ,JIT 컴파일러(Just-In Time compiler) 클래스 로더(class loader…","html":"<p>운영체제 Heap 메모리 영역에 접근해 <strong>사용하지 않는 Object를 정리</strong>해주는 JVM의 구성요소입니다. 개발자가 직접적으로 메모리 해제를 C/C++과 달리, JVM에서는 GC를 제공해 개발에만 집중하고, Memory Leak을 신경쓰지 않아도 됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/205865221-357f520b-465f-4c5f-a80c-a78a53707ac8.png\" alt=\"\"></p>\n<blockquote>\n<p>JVM은 다음과 같은 구성요소가 존재합니다.</p>\n</blockquote>\n<ul>\n<li>실행엔진 : 자바 인터프리터(interpreter) ,JIT 컴파일러(Just-In Time compiler)</li>\n<li>클래스 로더(class loader)</li>\n<li>Runtime Data Area(Heap, Stack, 등등 실행데이터)</li>\n<li><strong>가비지 컬렉터(garbage collector)</strong>  (오늘 알아볼 내용)</li>\n</ul>\n<h1 id=\"gc의-동작-과정\" style=\"position:relative;\"><a href=\"#gc%EC%9D%98-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"gc의 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC의 동작 과정</h1>\n<p>대부분의 객체는 생성되고 얼마되지 않아 Unreachable Object가 됩니다. JVM에서 Heap에 Object를 적재할 때, 생성시기와 생존기간을 고려해 크게 <strong>Young Generation, Old Generation</strong>으로 구역을 나누어, GC를 위한 데이터 접근을 효율적으로 수행합니다.</p>\n<blockquote>\n<p>Unreachable Object: 메서드가 종료되거나 참조가 사라져 사용할 수 없는 객체.</p>\n</blockquote>\n<p>또한, JVM을 설계할 때, 객체는 금방 Unreachable 상태가 된다는 것을 가정하고 시작하므로 Young Geneartion 영역이 Old Generation 영역보다 작고, GC도 더 자주 수행됩니다.</p>\n<p>YG,OG영역에서 수행되는 GC를 각각 Minor GC, Major GC 라고 하며 수행방법또한 차이가 있지만, 모두 <strong>Stop-the-world, Mark&#x26;Sweep동작</strong>이 기본이 됩니다.</p>\n<h3 id=\"stop-the-world동작은\" style=\"position:relative;\"><a href=\"#stop-the-world%EB%8F%99%EC%9E%91%EC%9D%80\" aria-label=\"stop the world동작은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Stop the world</strong>동작은</h3>\n<hr>\n<p><strong>Stop the world</strong>동작은 GC를 수행하는 스레드를 제외한 모든 스레드를 중지하면서 GC과정을 Thread-safe하게 수행하도록 하는 과정입니다.</p>\n<h3 id=\"mark--sweep동작은\" style=\"position:relative;\"><a href=\"#mark--sweep%EB%8F%99%EC%9E%91%EC%9D%80\" aria-label=\"mark  sweep동작은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Mark &#x26; Sweep</strong>동작은</h3>\n<hr>\n<p><strong>Mark &#x26; Sweep</strong>동작은, 전역변수와 현재 scope의 로컬 변수를 루트로 시작해 참조하고 있는 Object를 탐색하며 mark bit를 true로 변경해줍니다.</p>\n<p>이후 Mark되지 않은 Object(회색부분)를 삭제해주며, GC과정을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192480693-1eaf6928-40bb-43e1-8d12-a7159829dd2e.png\" alt=\"GC drawio (6)\"></p>\n<ul>\n<li>\n<p>이 때, 메모리에서 데이터가 부분적으로 존재하는 파편화 문제가 발생하며, Compaction 알고리즘을 통해 이를 해결합니다.</p>\n</li>\n</ul>\n<h2 id=\"young-generation과-minor-gc\" style=\"position:relative;\"><a href=\"#young-generation%EA%B3%BC-minor-gc\" aria-label=\"young generation과 minor gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young Generation과 Minor GC</h2>\n<hr>\n<p>Young Generation(YG)영역의 경우, 처음 생성한 객체를 저장하는 Eden영역과, Eden영역에서 살아남은 객체가 저장되는 Survival영역이 두 개 존재합니다.\n동적으로 할당된 메모리 영역(Heap)에서 <strong>Unreachable Object를</strong> 찾아 삭제하는 역할 수행합니다.</p>\n<h3 id=\"기본-프로세스\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"기본 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 프로세스</h3>\n<ol>\n<li>새로 생성된 객체들이 YG의 Eden영역에 할당되고, 곧 가득 찹니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445234-d42612cd-6d71-4b67-bb1b-85ae5ef0c53b.png\" alt=\"GC drawio\">\n<br></p>\n<ol start=\"2\">\n<li>Eden영역이 가득 찼으면, Minor GC를 수행합니다. 그 결과 , Eden에서 살아남은 Object가 Survival1에 위치합니다. 이 때부터, Object는 Age라는 변수를 가지며, <strong>자신의 생존 기간을 기록합니다.</strong></li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445223-b080df35-f96d-41f3-8a7b-37b9e245949f.png\" alt=\"GC drawio (1)\">\n<br></p>\n<ol start=\"3\">\n<li>또 다시 Eden 영역이 가득 찼습니다. 이번에는 Eden영역과 Survival0영역에도 Object가 있으므로, 이에 대해 Minor GC를 수행합니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445232-b81745cd-bdaf-40a6-b405-37715a2b69db.png\" alt=\"GC drawio (2)\">\n<br></p>\n<ol start=\"4\">\n<li>Eden영역과 Survival0영역에서 살아남은 Object는 Survival1영역으로 이동합니다.</li>\n</ol>\n<p>Survival0,1 두 개의 영역은 서로의 역할을 번갈아가며 3번과 4번 과정이 여러번 반복됩니다. 이때, Eden영역에서 살아남은 Object는 Age값이 초기값이지만, Survival0(또는 1) 영역의 객체들은 살아남은 기간만큼의 Age값을 갖습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192446180-d9496029-1f76-4dd2-95a0-82143bde39fe.png\" alt=\"GC drawio (4)\"></p>\n<!-- ![GC drawio (3)](https://user-images.githubusercontent.com/30853787/192445233-4de84416-ccba-45e6-9cab-0264da936c57.png) -->\n<br>\n<ol start=\"5\">\n<li>Survival0(또는 1)영역에서, JVM에 설정된 Max age값에 도달한 객체가 있다면, Old Generation영역으로 이동합니다. 이를 Promotion이라고 합니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192446711-9e79557e-c7b1-4fc0-a920-674e26812e44.png\" alt=\"GC drawio (5)\"></p>\n<ul>\n<li>추가적으로, YGd에서의 MinorGC에서 Mark되지 않은 Object를 OG영역이 참조할 경우, OG영역이 YG영역을 참조할 때마다 카드 테이블에 정보를 기록해, OG에서 YG로의 참조를 기록합니다. 이를 통해 OG에서 참조하는 YG의 객체가 mark되지 않는 문제를 해결합니다.</li>\n</ul>\n<h2 id=\"old-generation에서의-gc\" style=\"position:relative;\"><a href=\"#old-generation%EC%97%90%EC%84%9C%EC%9D%98-gc\" aria-label=\"old generation에서의 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old Generation에서의 GC</h2>\n<hr>\n<p>Old Generaion(OG)영역의 경우, YG영역에서 특정기간 이상 살아남은 객체들이 존재하는 영역입니다. 데이터가 가득 차면 GC를 수행하므로 그만큼 GC실행빈도는 적고, Stop the wolrd(STW)시간은 약 10배 이상 깁니다.</p>\n<p>GC의 STW시간은 애플리케이션 실행 성능에 큰 영향을 미칩니다. STW를 줄이는것이 GC의 역사라고 해도 과언이 아닐 정도로, GC에서 중요한 지표로 사용됩니다.</p>\n<p>여러가지 GC 알고리즘이 있지만, JDK8 이하 버전에서 사용된 SerialGC, ParallelGC JDK9이상 버전에서 사용중인 G1GC, JDK15에서 Production버전으로 준비되어 좋은 성능을 내고있는 ZGC에 대해서 Reference탭에 있는 링크를 통해 확인해주세요.</p>\n<h2 id=\"serial-gc--xxuseserialgc\" style=\"position:relative;\"><a href=\"#serial-gc--xxuseserialgc\" aria-label=\"serial gc  xxuseserialgc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial GC (-XX:+UseSerialGC)</h2>\n<hr>\n<p>YG영역에서는 앞부분 에서 설명한 GC를 그대로 수행하지만, OG 영역에서는 mark&#x26;sweep 이후 각 객체들이 연속되게 쌓이도록 Compaction 과정을 수행합니다. JDK 8버전 이하에서, 클라이언트 애플리케이션을 위한 GC 기본값으로 사용했습니다.</p>\n<h2 id=\"parallel-gc--xxuseparallelgc\" style=\"position:relative;\"><a href=\"#parallel-gc--xxuseparallelgc\" aria-label=\"parallel gc  xxuseparallelgc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel GC (-XX:+UseParallelGC)</h2>\n<p>SerialGC와 기본 알고리즘은 같지만, GC를 처리하는 스레드의 수가 여러개라는 차이가 있습니다. JDK8버전 이하에서, 서버 애플리케이션을 위한 GC 기본값으로 사용됩니다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://d2.naver.com/helloworld/1329\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Naver D2,  Java Garbage Collection</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=vZRmCbl871I&#x26;list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&#x26;index=219\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">[10분 테코톡] 👌던의 JVM의 Garbage Collector</a></p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle ZGC</a></p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle G1GC Tuning</a></p>\n<p><a href=\"https://coding-factory.tistory.com/829\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">코딩팩토리, [Java] 가비지 컬렉션(GC, Garbage Collection) 총정리</a></p>\n<p><a href=\"https://nobilitycat.tistory.com/entry/Mark-and-Sweep\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">고귀양이 노트, Mark &#x26; Sweep</a></p>\n<p><a href=\"https://steady-coding.tistory.com/590\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">느리더라도 꾸준하게, [Java] G1 GC의 동작 과정</a></p>","id":"05a833b7-9ea2-5502-8e4c-96942496c98e","fields":{"slug":"jvm의-garbage-collector-동작방법"},"frontmatter":{"date":"2022-09-23","title":"JVM의 Garbage Collector 동작방법","category":"tech","tags":["java","jvm","garbage collector"],"banner":"/assets/bg/3.jpg"},"timeToRead":4},{"excerpt":"Intro 여기 링크에서도 자세한 설명을 확인할 수 있습니다. 함수의 메소드와 arguments: 제로초님 블로그 자바스크립트 this 바인딩 우선순위 : 김정환님 블로그 Function.prototype의 call, apply, bind 메서드,\n공부를 해도 사용시에 헷갈릴때가 많아서 정리합니다..! call, apply Call과 Assign은 함수에 객체를 바인딩 후 호출하는 방법입니다. Javascript…","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>여기 링크에서도 자세한 설명을 확인할 수 있습니다.</p>\n<ul>\n<li><a href=\"https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">함수의 메소드와 arguments: 제로초님 블로그</a></li>\n<li><a href=\"http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바스크립트 this 바인딩 우선순위 : 김정환님 블로그</a></li>\n</ul>\n<p>Function.prototype의 call, apply, bind 메서드,\n공부를 해도 사용시에 헷갈릴때가 많아서 정리합니다..!</p>\n<h2 id=\"call-apply\" style=\"position:relative;\"><a href=\"#call-apply\" aria-label=\"call apply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>call, apply</h2>\n<p>Call과 Assign은 함수에 객체를 바인딩 후 호출하는 방법입니다.</p>\n<p>Javascript에서는 함수 역시 객체이므로, 함수 객체 내에서 call, apply, bind 메서드 역시 객체의 프로퍼티 메서드로 가지고있습니다.</p>\n<p>따라서 <strong>myFunction.call()</strong>, **myFunction.bind()**와 같은 형태로 호출해서 사용하지만, 그 역할은 **myFunction()**과 비슷합니다.</p>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">myMethod</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> arg3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr <span class=\"token operator\">=</span> <span class=\"token string\">\"my attr\"</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> arg3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//result</span>\n<span class=\"token comment\">// myattr 1 2 3</span>\n<span class=\"token comment\">// myattr 1 2 4</span>\n<span class=\"token comment\">// myattr 1,2,5</span></code></pre></div>\n<p>예시와 결과로 알 수 있듯, call(null, arg, arg2, arg)와 apply(null, [arg1, arg2, arg3])은 메서드 호출의 역할을 함을 알 수 있습니다.</p>\n<p>그렇다면 첫 번째 인자는 어떤 역할을 수행할까요?</p>\n<p>바로 this 객체를 바인딩 역할을 수행합니다.</p>\n<p>예시는 어떻게 출력될까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">attr</span><span class=\"token operator\">:</span> <span class=\"token string\">\"myattr\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">attr</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your attr\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>너무 티나는 예시때문에 알 수 있듯 아래와 같이 출력됩니다.</p>\n<p>your attr 1 2 3</p>\n<p>myMethod.call의 첫 번째 인자가 실행 컨텍스트를 바꿨기 때문이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> va <span class=\"token operator\">=</span> <span class=\"token string\">\"globalValue\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"asd\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">myFunc2</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> va <span class=\"token operator\">=</span> <span class=\"token string\">\"lexicalSocpe\"</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//(1)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//(2)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"callValue\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"arg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이건 본문과는 관련성이 떨어지지만 조금 헷갈리는 예제네요~</p>\n<p>(1): Lexical scope에 의해 \"lexicalSocpe\"가 출력됩니다.</p>\n<ul>\n<li>함수가 실행될 때, 변수 참조 체인은 Call Stack이 아닌 Lexical stack에서 참조된다는 의미입니다.</li>\n</ul>\n<p>(2): call함수가 this를 교체했으므로, \"callValue\"가 출력됩니다.</p>\n<ul>\n<li>myFunc.call에서, myFunc.va = \"callValue\"로 교체해 실행합니다.</li>\n</ul>\n<h2 id=\"bind\" style=\"position:relative;\"><a href=\"#bind\" aria-label=\"bind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>bind</h2>\n<p>Function.prototype.bind는 apply, call과 조금 다릅니다,</p>\n<p>apply, call 은 bind + execute였다면, bind는 메서드와 오브젝트를 바인딩합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> binded <span class=\"token operator\">=</span> myObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"binded value\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">binded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// result: bindex value</span></code></pre></div>\n<p>이렇게 this가 바뀌는 것은, new 키워드에서도 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Persion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> age</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">introduce</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> myeonggyu <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mklee\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyeonggyu<span class=\"token punctuation\">.</span><span class=\"token function\">introduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// mklee 23</span></code></pre></div>\n<p>!! 글을 작성하다가 알게되었는데, 위 예시의 log선언부를 익명함수로 고치면 this.attr이 undefinded가 출력됩니다. 익명함수는 무조건 this가 루트를 가르키는듯 합니다.</p>\n<p>위에서 new를 이용해 this를 바인딩한것이 <strong>new 바인딩</strong>,</p>\n<p>bind,call,apply를 통해 바인딩한것이 <strong>명시적 바인딩</strong>,</p>\n<p>상위객체의 this값을 가지는 방법으로 바인딩되는것이 <strong>암시적 바인딩입니다.</strong></p>\n<p>결과적으로, 바인딩 우선순위는 <strong>new > 명시적 > 암시적</strong> 바인딩 순으로 결합되며,</p>\n<p><a href=\"http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바스크립트 this 바인딩 우선순위 : 김정환님 블로그</a>에 잘 설명되어있습니다.</p>\n<h2 id=\"close\" style=\"position:relative;\"><a href=\"#close\" aria-label=\"close permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Close</h2>\n<p>사용되는것이 종종 보이긴 하지만, 볼때마다 헷갈려서 학습하곤 합니다. 관련 내용을 찾아가다 보면 Javascript동작구조에 대한 재미있는 글들이 많이 보이니, 위 글에서 얻은 키워드를 바탕으로 더 찾아보시면 도움될것 같습니다.</p>","id":"92725c1b-dfcb-51fb-88ee-3532106d1a93","fields":{"slug":"javascript-function-call-apply-bind-메서드"},"frontmatter":{"date":"2020-08-14","title":"[Javascript Function] call, apply, bind 메서드","category":"tech","tags":["javascript"],"banner":null},"timeToRead":2},{"excerpt":"본문은 Typescript 핵심 개념 을 번역(+ 개인적인 의견 추가)한 글입니다. OOP에 대한 기본 지식이 있으신 분은 Learn Typescript in Y minutes또는 MS 공식 DOCS에서 문법만 훑어보시면 좋습니다. 타입스크립트를 접했을때 드는 느낌은 OOP + Compile + javascript => typescript로 요약할 수 있겠습니다. typechecking, OOP개념이 분명하지 않은 Javscript(이하 JS…","html":"<blockquote>\n<p>본문은 <a href=\"https://www.educative.io/blog/advanced-typescript-concepts\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Typescript 핵심 개념</a> 을 번역(+ 개인적인 의견 추가)한 글입니다.</p>\n</blockquote>\n<blockquote>\n<p>OOP에 대한 기본 지식이 있으신 분은 <a href=\"https://learnxinyminutes.com/docs/typescript/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Learn Typescript in Y minutes</a>또는 <a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MS 공식 DOCS</a>에서 문법만 훑어보시면 좋습니다.</p>\n</blockquote>\n<hr>\n<p>타입스크립트를 접했을때 드는 느낌은 OOP + Compile + javascript => typescript로 요약할 수 있겠습니다.</p>\n<p>typechecking, OOP개념이 분명하지 않은 Javscript(이하 JS)의 단점을 커버하는 언어입니다.</p>\n<p>실제로 typechecking을 하지 않음으로 인해 발생하는 런타임에러는 꽤 큰 골칫거리기에 , typechekcing, compilable한 typescript의 개념이 아주 매력적입니다.</p>\n<p>그리고 javascript에 익숙하다면 학습난이도도 높지 않은듯 합니다.</p>\n<p><em>(통번역입니다. 오역주의) Lets go!</em></p>\n<hr>\n<p>자바스크립트를 사용할 때, 디버깅은 많은 개발자들의 골칫거리입니다! 프로그램을 실행하고, 버그를 찾고 고치기를 반복합니다. 디버깅을 시작한지 몇시간 뒤에야 마침내 버그를 고치곤 합니다. 이러한 문제는 자바스크립트같이 컴파일을 하지 않는 언어(인터프리터 언어)의 공통적인 특징입니다.</p>\n<p><em>python 역시 타입체킹을 하지 않는 인터프리터 언어인데 디버깅이나 런타임 에러 문제에 대해 논의하는것을 보지 못했네요.. 왜 그럴까요..?</em></p>\n<p>이런 자바스크립트의 단점을 고치기 위해 Microsoft는 Typescript를 만들어냅니다. 거대한 팀들이 Typescript의 장점을 깨닫고 그들의 기술스택에 적용하면서, 많은 개발자들이 이를 학습하게 되었습니다!</p>\n<ul>\n<li>Typescript란?</li>\n<li>Strict types 소개</li>\n<li>Typescript와 OOP(객체지향 프로그래밍)</li>\n<li>Typescript의 타입들</li>\n<li>그 외 알아야하는 것들</li>\n</ul>\n<h2 id=\"typescript란\" style=\"position:relative;\"><a href=\"#typescript%EB%9E%80\" aria-label=\"typescript란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript란?</h2>\n<p>Microsoft가 만들고 관리하는, javascript의 모집합(superset)으로, 모든 자바스크립트 코드는 Typescript에서 유효하다는 특징을 가지고있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">즉, JS로 할 수 있는건, TS로 할 수 있다는 뜻.</code></pre></div>\n<p>TS는 아래 두개의 핵심 개념에 초점을 맞춘 Application 규모(대규모) 개발을 위한 Javascript입니다.</p>\n<ul>\n<li>\n<p>현재버전 이후의 자바스크립트 엔진의 기능을 현재 자바스크립트 엔진에서 제공</p>\n</li>\n<li>\n<p>Javascript에서 type system 제공</p>\n</li>\n</ul>\n<p>Typescript의 구성요소는</p>\n<ol>\n<li>기본적으로 javascript와 추가적인 특징/문법들로 이루어진 Typescript 자체 문법과,</li>\n<li>Typescript 코드를 javascript 코드로 변환해주는 컴파일러,</li>\n<li>Compiler 파이프라인의 끝에서 에디터같은 기능을 제공하는 Language service가 있습니다.</li>\n</ol>\n<p>(3번기능은 지금으로서 어떤 기능인지 와닿지 않네요.)</p>\n<p>Typescript를 사용하는 이유!</p>\n<ul>\n<li>\n<p>타입체킹 : MS나 Google같은 거대한 팀들이 Typescript의 정적 타입 체크가 개발 프로세스 간소화에 있어 유용함을 알아냈습니다.</p>\n</li>\n<li>\n<p>객채지향 프로그래밍 : Typescript는 인터페이스, 상속, 클래스 등의 객체지향 프로그래밍 개념을 지원합니다.</p>\n</li>\n<li>\n<p>컴파일 : Typescript는 인터프리팅 언어인 JS와 달리 컴파일을 지원하며, 이는 여러분 코드의 컴파일 에러를 찾아주고, 디버깅을 간편하게 해줍니다.</p>\n</li>\n</ul>\n<p>Typescript 설치</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> typescript</code></pre></div>\n<p>compile</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> tsc hellowrold.ts</code></pre></div>\n<p>npm을 사용하지 않는다면, <a href=\"https://www.typescriptlang.org/#download-links\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">링크</a>에서 typescript패키지를 다운받을 수 있습니다.</p>\n<h2 id=\"typescript의-장점과-한계\" style=\"position:relative;\"><a href=\"#typescript%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%ED%95%9C%EA%B3%84\" aria-label=\"typescript의 장점과 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript의 장점과 한계</h2>\n<h3 id=\"타입체킹\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%B2%B4%ED%82%B9\" aria-label=\"타입체킹 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입체킹</h3>\n<p>Javascript는 동적으로 타입을 체킹하는 언어로, 오직 런타임에서만 에러를 찾을 수 있음을 의미합니다. 이것은 복잡한 프로젝트를 진행하는 큰 팀에게 거대한 단점으로, 코드에 대한 모든 실수를 미리 찾는 방법이 더 수월합니다.</p>\n<p>Typescript는 선택적(optional) 정적 타입체킹을 제공하므로, 변수는 타입을 바꿀 수 없으며, 특정 값만을 받을 수 있습니다. 이를 통해 Typescript 컴파일러가 에러가 발생하기 쉬운 코드에서 더 많은 버그를 잡을 수 있도록 합니다. 또한 타입은 가독성있고 쉽게 리팩토링하기 위한 구조를 만듭니다.</p>\n<p>Typescript와 Javacsript의 차이점을 보고싶다면 <a href=\"https://www.typescriptlang.org/#download-links\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a>로!</p>\n<h3 id=\"ide-지원\" style=\"position:relative;\"><a href=\"#ide-%EC%A7%80%EC%9B%90\" aria-label=\"ide 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IDE 지원</h3>\n<p>Typescript가 정적 타입체킹을 지원하므로, 코드 에디터 또는 IDE에서 더 많은 이점을 가질 수 있다.</p>\n<ol>\n<li>자동완성( Javascript의 변수는 type이 존재하지 않으므로, 변수에 대한 자동완성을 지원하지 않는다. 지원하더라도, 에디터 또는 IDE는 변수의 타입을 모르기에, 적절한 메서드명이나 애트리뷰트 명을 자동완성할 수 없음),</li>\n<li><a href=\"https://visualstudio.microsoft.com/ko/services/rich-code-navigation/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">code navigation</a>,</li>\n<li>type에 의한 Error flagging</li>\n</ol>\n<p>이런 IDE에서의 기능 지원은, Tpyescript로 작성해야하는 코드량이 Javascript보다 많더라도, 생산성 경쟁력에 많은 부분을 기여하고 있다.</p>\n<p>Typescrpt3를 지원하는 인기있는 IDE들</p>\n<ul>\n<li>MS Visual Studio</li>\n<li>Webstorm</li>\n<li>Visual Studio Code</li>\n<li>Atom</li>\n</ul>\n<h3 id=\"browser-호환성\" style=\"position:relative;\"><a href=\"#browser-%ED%98%B8%ED%99%98%EC%84%B1\" aria-label=\"browser 호환성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Browser 호환성</h3>\n<p>브라우저 호환성은 Typescript의 강력한 특징중 하나입니다. Typescript는 모든 모던 브라우저와 호환 가능한 코드로 Typescript 코드를 컴파일합니다. 이런 높은 호환성이 가능한 이유는, Typescript코드를 모든 기기와 플랫폼, 브라우저를 지원하는 vanilla JS(순수 Javscript)로 컴파일할 수 있기 때문에 가능합니다.</p>\n<p>Typescript를 사용하며 얻는 많은 장점이 있음에도, 이것은 완벽한 솔루션은 아닙니다.</p>\n<hr>\n<p>코드 가독성을 높히는 것에 있어 하나의 단점은, VanillaJS를 사용할 때와 비교해 Typescript를 사용할때는 가독성있는 코드를 위해 더 많은 코드를 써야하고,\n이는 잠재적으로 여러분의 개발 시간을 증가시킵니다.</p>\n<hr>","id":"a68d2bfe-4173-51c0-87f0-33ad79aba22a","fields":{"slug":"타입스크립트-핵심-concepts-번역"},"frontmatter":{"date":"2020-08-01","title":"타입스크립트 핵심 Concepts! (번역)","category":"tech","tags":["typescript","javascript"],"banner":null},"timeToRead":3},{"excerpt":"주제 : 운영체제 메모리 관리: 물리메모리 할당 방식! 목차 연속 메모리 할당 고정 분할 방식 Fixed Allocation 가변 분할 방식 Variable Allocation 비연속 메모리 할당 세그멘테이션 Segmentation 페이징 Paging ---continue--- 페이징/세그멘테이션 혼합 페이지 요구 Demand Paging…","html":"<blockquote>\n<p>주제 : 운영체제 메모리 관리: 물리메모리 할당 방식!</p>\n</blockquote>\n<ul>\n<li>\n<p>목차</p>\n</li>\n<li>\n<p>연속 메모리 할당</p>\n<ul>\n<li>고정 분할 방식 Fixed Allocation</li>\n<li>가변 분할 방식 Variable Allocation</li>\n</ul>\n</li>\n<li>\n<p>비연속 메모리 할당</p>\n<ul>\n<li>세그멘테이션 Segmentation</li>\n<li>페이징 Paging</li>\n</ul>\n<p>---continue---</p>\n<ul>\n<li>페이징/세그멘테이션 혼합</li>\n<li>페이지 요구 Demand Paging</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 할당 방식</h1>\n<p>하나의 프로그램이 실행되는 메모리 순서를 연속적으로 물리 메모리에 할당하는 방법</p>\n<h3 id=\"고정-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%A0%95-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"고정 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고정 분할 방식</h3>\n<p>물리적 메모리를 몇 개의 영구적인 분할로 나누어 각각의 영역에 프로그램을 적재시킨다.</p>\n<p>심각한 내부 단편화가 발생할 수 있다.<br>\n예를 들어 256MB의 메모리를 32MB씩 분할한다면, 2MB의 메모리만이 필요한 프로그램이 실행되는 경우 30MB의 내부 단편화가 발생한다.<br>\n(보통은 다양한 크기의 프로그램을 실행하기 위해 메모리를 다양한 크기로 분할한다.)</p>\n<h3 id=\"가변-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"가변 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 분할 방식</h3>\n<p>프로그램이 실행/종료되는 시점마다 프로그램 크기에 맞는 메모리를 할당/해제하는 방식.</p>\n<p>첫 할당 이후 메모리 위치를 재정리할 수 없으므로, 다양한 크기의 프로그램에 대해 메모리 할당/해제를 반복하다 보면 아래와 같이 외부 단편화가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-----------------------------------------------------\n| running(120MB) | empty(20MB) | running(8MB) | ...</code></pre></div>\n<hr>\n<h1 id=\"비연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"비연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속 할당 방식</h1>\n<p>프로그램의 메모리 할당 요청을 비연속적으로 메모리에 할당하는 방식. swap space를 사용하는 가상화 기법이 활용된다.</p>\n<h3 id=\"세그먼트-\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-\" aria-label=\"세그먼트  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그먼트 :</h3>\n<p>메모리를 나누는 단위.</p>\n<p>세그먼트: 프로세스 크기에 따라 가변 크기를 갖는 <strong>물리 메모리 분할 단위</strong></p>\n<hr>\n<h3 id=\"페이지--프레임\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80--%ED%94%84%EB%A0%88%EC%9E%84\" aria-label=\"페이지  프레임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 / 프레임</h3>\n<p>페이지 : 고정 크기로 <strong>가상 메모리를 분할하는 단위</strong></p>\n<p>프레임 : 페이지와 1:1로 매핑되는 <strong>물리 메모리 분할 단위</strong></p>\n<p>페이지와 프레임은 페이지 테이블을 매개로 연결된다.</p>\n<p>따라서, 프로세스가 page(N)을 가지고있을 경우, OS는 가상주소 N에 데이터를 요청하고, 가상주소 N은 페이지 테이블의 정보를 통해 물리 주소인 frame(K)에 접근한다. 이 때, frame(k)주소가 존재하지 않을 경우, swap space(주로 보조 기억장치)에서 데이터를 가져온다. 이는 page fault라고 불리며, 이는 성능 저하를 일으키기도 하며 segmentation-paging 기법에서 Thrashing 등을 일으켜 심각한 성능 저하를 내기도 한다.</p>\n<hr>\n<h3 id=\"페이지-테이블--페이징-기법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94--%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\"페이지 테이블  페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 / 페이징 기법</h3>\n<p><strong>페이징 기법</strong> : 가상 메모리를 <strong>고정 크기</strong>로 분할한 페이지를 통해 메모리를 관리하는 방식.<br>\n만약 프로세스가 페이지의 크기보다 적은 메모리를 필요로 하는 경우, **내부 단편화((페이지)내부의 메모리 일부가 사용되지 않아 낭비되는 현상)**가 발생한다.</p>\n<p>(페이지의 크기 :프로세스의 크키가 커지면서 4KB > 4MB까지 크기가 커짐.)</p>\n<p>LRU, FIFO, LFU, NUR등의 페이지 교체 알고리즘을 통해 물리 메모리를 관리.</p>\n<p><strong>페이지 테이블</strong> : 페이지와 프레임의 매칭 정보를 담고있는 테이블.</p>\n<p>프로세스가 가상 메모리(page)의 정보를 hit할때 실제 물리 메모리 주소(frame)로 변환하는 역할을 수행한다.</p>\n<p>페이지의 크기가 커지면 아래와 같은 변화가 생긴다.</p>\n<ul>\n<li>내부 단편화가 증가한다.</li>\n<li>Page fault(페이지 요청 실패)가 감소한다.</li>\n<li>페이지 테이블의 크기가 감소한다.\n<ul>\n<li>(TMI)페이지 테이블 비례 : 전체 메모리 사이즈 /  페이지 크기</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"세그멘테이션-테이블-세그멘테이션-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 테이블 세그멘테이션 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션 테이블 /세그멘테이션 기법</h3>\n<p><strong>세그멘테이션 기법</strong> : 하나의 프로세스가 사용하는 메모리의 크기 단위로 가상 주소를 관리하는 기법.</p>\n<p>프로세스별로 요구하는 메모리가 다르므로, 세그먼트의 크기는 가변적이다.</p>\n<p>세그멘테이션 테이블 :</p>\n<ul>\n<li>물리 메모리에서 세그먼트의 <strong>start address</strong></li>\n<li>가변적인 세그먼트의 크기를 나타내는 <strong>limit</strong></li>\n</ul>\n<p>위 두 가지를 보관하고 있는 자료구조이다.</p>\n<hr>\n<h3 id=\"세그멘테이션-페이징-혼합-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%98%BC%ED%95%A9-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 페이징 혼합 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션-페이징 혼합 기법</h3>\n<p>.</p>\n<h3 id=\"pcb-process-control-block\" style=\"position:relative;\"><a href=\"#pcb-process-control-block\" aria-label=\"pcb process control block permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB: Process Control Block</h3>\n<p>프로세스 생성 시 커널 스택만들어지는 자료구조 : Status / Pointer(addr)/ Identifier / PC / Priority 등을 저장한다.\n<img src=\"https://t1.daumcdn.net/cfile/tistory/995A6E395A5E0DAF18\" alt=\"PCB\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">/</th>\n<th align=\"center\">연속 메모리 할당</th>\n<th align=\"center\">가상화(swap)</th>\n<th align=\"center\">관리 테이블</th>\n<th align=\"center\">단편화</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">고정 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">가변 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">외부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">페이징 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">페이지테이블</td>\n<td align=\"center\">페이지 내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">세그멘테이션 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">세그먼테이션 테이블</td>\n<td align=\"center\">세그멘테이션 외부 단편화</td>\n</tr>\n</tbody>\n</table>","id":"0db54144-01a0-551b-bfac-e41061832274","fields":{"slug":"continue-os-메모리파트-정리"},"frontmatter":{"date":"2020-05-24","title":"[Continue,OS] 메모리파트 정리","category":"tech","tags":["운영체제","computerscience"],"banner":null},"timeToRead":4},{"excerpt":"Intro 오늘 소개할 주제는 webhook 입니다. 서비스를 배포하거나 관련 공부를 해보셨다면, github과 Jenkins같은 CI도구를 연동하며 github에서 푸쉬를 비롯한 특정 이벤트를 jenkins로 전달해주기 위해 연동해본 경험이 있습니다. 이때 github서버는 Jenkins가 별다른 요청을 하지 않아도 서버 내에서 특정 이벤트가 일어났을 때 Jenkins…","html":"<h1 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h1>\n<p>오늘 소개할 주제는 <strong>webhook</strong> 입니다.</p>\n<p>서비스를 배포하거나 관련 공부를 해보셨다면,<br>\ngithub과 Jenkins같은 CI도구를 연동하며 github에서 푸쉬를 비롯한 특정 이벤트를 jenkins로 전달해주기 위해 연동해본 경험이 있습니다.</p>\n<p>이때 github서버는 Jenkins가 별다른 요청을 하지 않아도 서버 내에서 특정 이벤트가 일어났을 때 Jenkins로 관련 정보들을 보내줍니다.<br>\n이것은 \"웹훅\"이라고 불리는 과정인데요, 일반적으로 클라이언트가 서버에게 정보 또는 행위를 요청하는 방식과는 다릅니다.</p>\n<p>오늘은 위에서 설명한 웹훅이 어떻게 가능한지 간단하게 공부하려합니다.</p>\n<hr>\n<p>클라이언트에서 서버의 자원을 이용하기 위해, 또는 서버를 동작하기 위한 인터페이스로 Web API를 사용합니다.</p>\n<p>이와 반대로 <strong>역방향 API, 서버에서 발생하는 이벤트를 처리하기 위해 Webhook을 사용한다는 것을 알게되었습니다.</strong></p>\n<p>웹 API를 통해 클라이언트의 요청을 처리하는 방식은 일상적인 방법이기에 무리없이 관련 동작을 이해하고 개발에 사용했지만,<br>\n서버에서 발생하는 이벤트를 클라이언트로 전달하는 과정은 쉽사리 이해되지 않았습니다.<br>\n또한 순수하게 이것이 어떤 원리로 가능한지 궁금하기도 했습니다.</p>\n<h1 id=\"principle\" style=\"position:relative;\"><a href=\"#principle\" aria-label=\"principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Principle</h1>\n<p>핵심적인 원리에 접근하는것은 어렵지 않았습니다.</p>\n<p>webhook은 언제부턴가 익숙한 개념이 되어있었고, RFC문서가 존재할것이라 생각해서 <a href=\"https://tools.ietf.org/html/rfc8030\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rfc webhook</a>으로 검색한 결과 HTTP/2.0 부터 지원하는 <strong>Web push</strong>스펙을 확인할수 있었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">\n    +-------+           +--------------+       +-------------+\n    <span class=\"token operator\">|</span>  UA   <span class=\"token operator\">|</span>           <span class=\"token operator\">|</span> Push Service <span class=\"token operator\">|</span>       <span class=\"token operator\">|</span> Application <span class=\"token operator\">|</span>\n    +-------+           +--------------+       <span class=\"token operator\">|</span>   Server    <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>               +-------------+\n        <span class=\"token operator\">|</span>      Subscribe       <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>---------------------<span class=\"token operator\">>|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>       Monitor        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span><span class=\"token operator\">&lt;=</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token operator\">>|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>          Distribute Push Resource           <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>--------------------------------------------<span class=\"token operator\">>|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token builtin class-name\">:</span>                      <span class=\"token builtin class-name\">:</span>                      <span class=\"token builtin class-name\">:</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>     Push Message     <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>    Push Message      <span class=\"token operator\">|</span><span class=\"token operator\">&lt;</span>---------------------<span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span><span class=\"token operator\">&lt;</span>---------------------<span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n\n                      Figure <span class=\"token number\">1</span>: WebPush Architecture</code></pre></div>\n<p>RFC 8030에 소개된 overview에 소개된 webpush의 구조입니다. (UA: user agent)</p>\n<p>사실 이 그림을 보자마자 웹훅을 위한 Push service가 따로 존재하는구나! Push sevice가 메시지 브로커 역할을 하는군! 이라고 이해하시면 웹훅을 사용할때 큰 문제가 없습니다.</p>\n<p>발행/구독 구조에서 확인할 수 있는 push, monitor, message를 이해하신다면</p>\n<p>Subscriber : UA (user agent)<br>\nPublisher : Application Server<br>\nBroker : <strong>Push Service</strong></p>\n<p>라고 생각하시면 됩니다.</p>\n<p>이는 아래와 같이 동작합니다.</p>\n<ol>\n<li>UA가 Application Server의 push service를 구독하고, push service를 모니터링합니다.</li>\n<li>이후 Application Server에서 UA가 원하는 동작이 발생하고 trigger를 통해 이벤트 메서드를 호출합니다.</li>\n<li>Application server는 발생한 Action에 대한 정보를 담은 메시지를 Push service에 전달하고,</li>\n<li>Push service는 구독 정보를 참조해 관련있는 Subscripbers에게 메시지들을 전달합니다.</li>\n</ol>\n<img src=\"https://www.researchgate.net/profile/Ashwin_Makwana/publication/301350598/figure/fig1/AS:352171422961666@1460975618330/Publish-Subscribe-Model.png\"/>\n<p>&#x3C;그림: 발행/구독 모델></p>\n<hr>\n<h3 id=\"features\" style=\"position:relative;\"><a href=\"#features\" aria-label=\"features permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Features</h3>\n<p>발행/구독구조의 특징과 함께 Webpush에 존재하는 몇가지 특징이 있습니다.</p>\n<p>User Agent(이하 UA)가 구독을 시작하며 Webpush 시나리오가 시작됩니다.<br>\n구독은 UA와 Push server, Application server간 연결을 뜻하며, HTTPS(port:443)위에서만 동작합니다.</p>\n<p>구독과 관련된 정보는 push service에 저장되며, 이 정보를 UA와 Application server가 각각 사용합니다.</p>\n<hr>\n<p><em>실제 API 문서와 RFC의 overview에 소개된 내용을 위주로 특징들을 리스트해보았습니다.</em></p>\n<ul>\n<li>\n<p>UA는 모든 incomming messages를 모니터링하기 위해 구독정보를 사용합니다.</p>\n</li>\n<li>\n<p>Application server는 trigger가 발생한 Action 관련 정보들을 push service에게 던지는 과정을 위해 구독 정보를 사용합니다.</p>\n</li>\n<li>\n<p>Push API는 클라이언트와 서버 간 비동기적 통신을 지원합니다</p>\n<ul>\n<li>\n<p>Push service는 UA가 비활성 상태이더라도 메시지를 전달하기 위해 활성상태가 될때까지 메시지를 저장합니다.</p>\n</li>\n<li>\n<p>마찬가지로 Push service는 Application Server가 비활성 상태이더라도 저장된 Push message를 UA에게 전달합니다</p>\n</li>\n<li>\n<p>(WebPush API의 이러한 특징과 Notification API를 이용해 Chrome에서는 알림 API를 지원합니다!)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>UA와 Application server가 통신중일때도 push service는 동작합니다.<br>\n하지만 fetch, websocket등의 직접통신 API들에 비해 리소스가 많이 소요되고 지연현상이 많아 UA와 Application server가 활성연결 상태가 아닐 때 사용하는것을 권장하고 있습니다.</p>\n</li>\n</ul>\n<h1 id=\"ending\" style=\"position:relative;\"><a href=\"#ending\" aria-label=\"ending permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ending</h1>\n<p>W3C의 API 스펙과 RFC8030의 Overview탭을 위주로 작성했습니다.</p>\n<p>설명한 특징 이외에도 다양한 동작 시나리오 / 특징들이 있습니다.<br>\n아래 그림에서는 User Agent를 webpage와 service worker까지 추가해서 설명하고있습니다.</p>\n<p>저처럼 WebPush에 대한 호기심이 생기셨다면, 추가로 읽어보시는것도 추천드립니다..!</p>\n<img src=\"https://www.w3.org/TR/push-api/sequence_diagram.png\" />\n<p>&#x3C;그림 Webpush API 메서드 동작 시나리오 (WC3)></p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://medium.com/@shlee1353/http1-1-vs-http2-0-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-5727b7499b78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http1,2 차이점</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc8030\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RFC8030 Web push</a></p>\n<p><a href=\"https://www.w3.org/TR/push-api/#application-server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">W3C Webpush API spec</a></p>","id":"9673e296-0c47-5baf-a5ee-c22d57f5c9ba","fields":{"slug":"웹훅-webhook-이-뭐야-http-2-0-webpush-스펙-요약"},"frontmatter":{"date":"2020-05-10","title":"웹훅 (webhook)이 뭐야?, HTTP/2.0 Webpush 스펙 요약","category":"tech","tags":["http","webhook"],"banner":null},"timeToRead":3},{"excerpt":"React.js 기초 튜터리얼을 학습하며 작성하는 글입니다. 오류가 있을 수 있으며, 이메일을 통한 오류 수정 환영합니다. JSX 위와 같은 문법으로 JSX를 작성한다. JSX는 Javascript의 String도 아니고, HTML역시 아닌데, JSX는 React Element를 생성하고, DOM에 렌더링한다. React.js의 컴포넌트 JSX의 중괄호 안에는 모든 Javascript 표현식이 들어갈 수 있다. 부연설명 -  이는 React…","html":"<blockquote>\n<p><a href=\"https://ko.reactjs.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React.js 기초 튜터리얼</a>을 학습하며 작성하는 글입니다. 오류가 있을 수 있으며, 이메일을 통한 오류 수정 환영합니다.</p>\n</blockquote>\n<h1 id=\"jsx\" style=\"position:relative;\"><a href=\"#jsx\" aria-label=\"jsx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSX</h1>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span> hello <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span></code></pre></div>\n<p>위와 같은 문법으로 JSX를 작성한다.</p>\n<p>JSX는 Javascript의 String도 아니고, HTML역시 아닌데, JSX는 <strong>React Element</strong>를 생성하고, DOM에 렌더링한다.</p>\n<h3 id=\"reactjs의-컴포넌트\" style=\"position:relative;\"><a href=\"#reactjs%EC%9D%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"reactjs의 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.js의 컴포넌트</h3>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'mklee'</span>\r\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n    element<span class=\"token punctuation\">,</span>\r\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">gelElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>JSX의 중괄호 안에는 모든 Javascript 표현식이 들어갈 수 있다.</p>\n<p>부연설명 -  이는 React의 컴포넌트가 로직과 뷰를 분리하지 않는다는 특성과 관련있다. 컴포넌트는 엘리먼트를 포함하는 개념으로만 알고있자.</p>\n<p>(참고로, JSX는 뷰와 로직이 섞여있기는 하지만, Javascript에 더 가깝기에, Camelcase 변수 표기법을 사용한다.)</p>\n<ul>\n<li>JSX 예제</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>\r\n<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\r\n    <span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>profileURL<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\r\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이처럼,</p>\n<ul>\n<li>Attribute에도 Javascript 표현식이 들어갈 수 있고,</li>\n<li>자식으로 JSX를 포함할 수도 있다.</li>\n<li>인터프리터 언어 특성 상, 줄바꿈 시 자동 세미콜론이 등록되므로, 엘리먼트 범위를 소괄호로 묶어주거나 한 줄에 작성하도록 하자.</li>\n</ul>\n<h1 id=\"react의-엘리먼트-렌더링\" style=\"position:relative;\"><a href=\"#react%EC%9D%98-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"react의 엘리먼트 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React의 엘리먼트 렌더링</h1>\n<hr>\n<p>앞의 예제에서 살펴보았듯,  **ReactDOM.render(element,,target)**를 통해 엘리먼트를 렌더링한다.</p>\n<h3 id=\"렌더링된-엘리먼트-업데이트\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%9C-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8\" aria-label=\"렌더링된 엘리먼트 업데이트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링된 엘리먼트 업데이트</h3>\n<p>React의 엘리먼트는 불변객체(const로 선언)이므로, 이것의 내용을 변경할 수 없다.</p>\n<p>하지만, 새로운 Element를 생성하고 이를 렌더링하는 방식으로 극복할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>참고 - 이후에 배우는 개념을 학습하면...</p>\n<p>유상태 컴포넌트(엘리먼트 변경이 있는 컴포넌트)는 대부분 한번의 rㅣender하는 방식으로 작성할 수 있다.\r\nReactDom은 변경이 필요한 경우에만 업데이트를 수행한다.</p>\n<h1 id=\"component와-props\" style=\"position:relative;\"><a href=\"#component%EC%99%80-props\" aria-label=\"component와 props permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Component와 Props</h1>\n<hr>\n<p>UI를 분리하여 재사용 가능하도록 하는 React의 유닛을 컴포넌트라고 한다.</p>\n<p>또한, 속성을 나타내는 props 객체를 통해 결과를 표현합니다.</p>\n<p>컴포넌트 선언 시, 이름의 첫글자는 대문자입니다(컨벤션).</p>\n<ul>\n<li>함수 컴포넌트</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Welcome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>props객체를 인자로 받아 React 앨리먼트를 반환하는 Javascript 함수를 유효한 함수 컴포넌트라고 합니다.</p>\n<ul>\n<li>클래스 컴포넌트</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Class Welcome <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>응용 - 사용자 정의 컴포넌트로 엘리먼트 생성</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Welcome name<span class=\"token operator\">=</span><span class=\"token string\">\"mklee\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<h3 id=\"컴포넌트-렌더링\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"컴포넌트 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 렌더링</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Welcome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Welcome name<span class=\"token operator\">=</span><span class=\"token string\">\"Sara\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n  element<span class=\"token punctuation\">,</span>\r\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"state와-lifecycle\" style=\"position:relative;\"><a href=\"#state%EC%99%80-lifecycle\" aria-label=\"state와 lifecycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>State와 LifeCycle</h1>\n<hr>\n<p>위쪽 파트에서 작성한 시계 코드를 리팩토링 해보자.</p>\n<ul>\n<li>기존 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>UI를 업데이트하기 위해 ReactDOM.render()를 호출해주었는데, state 개념을 활용해 효율적인 코드를 작성한다.</p>\n<ul>\n<li>컴포넌트로 분리하기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Clock</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's props<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>Clock date<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\r\n        document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드의 문제점</p>\n<ul>\n<li>한번의 실행이 업데이트를 수행하지 않음</li>\n</ul>\n<p>해결방법?</p>\n<ul>\n<li>state를 사용하자</li>\n<li>state는 props와 유사한 개념</li>\n<li>props와 달리 비공개 객체</li>\n</ul>\n<p>코드 수정하기</p>\n<ul>\n<li>우선, 함수 컴포넌트를 클래스 컴포넌트로 전환하고</li>\n<li>render()의 리턴으로 해당 JSX를 추가</li>\n<li>생성자를 아래와 같이 작성하고, status를 초기화해주기</li>\n<li>React의 컴포넌트 생명주기 메서드인 componentDidMount(), componentDidMount()를 작성해 시계가 랜더링될 때와 언마운트 될때의 수행코드 작성</li>\n<li>매 초 status를 변경해주는 tick함수 작성. (이 떄, status값의 수정은 setStatus를 통해서만 갱신된다)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Class Clock <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>   \r\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>     \r\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timerID<span class=\"token operator\">=</span><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timerID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n    <span class=\"token operator\">&lt;</span>Clock <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\r\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행과정</p>\n<ul>\n<li>**ReactDOM.render()**의 Clock 컴포넌트의 생성자를 호출하고 status 초기화됨.</li>\n<li>**Clock의 render()**가 호출된다. 이제부터 React에서 화면에 표시될 내용과 Clock의 렌더링 출력을 비교해 DOM을 업데이트한다.</li>\n<li>DOM이 업데이트 된 이후, componentDidMount() (마운트 동작)를 호출하고, 매 초 tick()함수를 호출하며, tick()함수에서는 status를 새로운 날짜로 갱신합니다.</li>\n<li>만약 Clock 컴포넌트가 삭제된다면, clearInterval을 통해 타이머가 중지됩니다.</li>\n</ul>","id":"ca4cdf75-95e5-5ba2-a562-ac1dcf9730af","fields":{"slug":"react-js-기초-튜터리얼-개념-편-1"},"frontmatter":{"date":"2019-09-12","title":"React.js 기초 튜터리얼, 개념 편 [1]","category":"tech","tags":["react"],"banner":null},"timeToRead":4}],"categoryName":"tech"}},"staticQueryHashes":[]}