{"componentChunkName":"component---src-templates-category-tsx","path":"/categories/tech/","result":{"pageContext":{"posts":[{"excerpt":"물리메모리를 필요로 하는 프로세스가 N개 있다고 하고, N개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 물리메모리의 크기보다 커지면 우리는 페이징 기법을 사용한다고 해도 N개의 프로그램을 동시에 실행하지 못할 것입니다. Swap Space 이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space…","html":"<p>물리메모리를 필요로 하는 프로세스가 N개 있다고 하고, N개의 프로세스는 각각 꽤 큰 크기의 물리메모리를 필요로 해서 물리메모리의 크기보다 커지면 우리는 <strong>페이징 기법을 사용한다고 해도 N개의 프로그램을 동시에 실행하지 못할 것입니다.</strong></p>\n<h3 id=\"swap-space\" style=\"position:relative;\"><a href=\"#swap-space\" aria-label=\"swap space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swap Space</h3>\n<p>이러한 물리메모리의 크기 한계를 극복하기 위해 HDD,SSD 등 보조기억장치를 임시 저장공간인 Swap Space로 사용합니다. 이런 Swap Space에는 자주 사용되지 않는 페이지가 위치합니다.</p>\n<p>물리메모리에서 자주 사용되지 않는 페이지가 Swap Space로 옮기는것을 Swap-out,</p>\n<p>반대로 Swap Space에 존재하는 페이지를 사용하기 위해 물리 메모리에 옮기는것을 Swap-in</p>\n<p>이라고 합니다.</p>\n<h3 id=\"가상-메모리-지원을-위한-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A7%80%EC%9B%90%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"가상 메모리 지원을 위한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 지원을 위한 방법</h3>\n<p>이렇듯 스왑 공간까지 사용해 메모리를 더 큰것처럼 사용할 수 있도록 하는 방법을 가상 메모리(VIrtual Memory)라고 합니다.</p>\n<p>가상 메모리를 사용을 지원하기 위해서는 Swap-in 또는 Swap-out 시 참조할 <strong>디스크상 페이지 주소</strong>를 알고있어야 합니다. 두번째로는 <strong>Present Bit</strong>를 알고있어야 합니다. Present Bit는 페이지 테이블 상의 페이지가 실제 물리메모리에 적재되어있는지 여부를 나타내는 데이터입니다.</p>\n<p><strong>Present Bit가 1인 경우</strong></p>\n<p>물리메모리에 데이터가 존재합니다. 이 경우 일반적인 페이징 방법처럼 PFN을 MMU로 전달해 CPU가 메모리에 접근 할 수 있습니다.</p>\n<p><strong>Present Bit가 0인 경우</strong></p>\n<p>해당 페이지 엔트리는 물리메모리에 없고 Swap Space에 존재함을 의미합니다. 이를 <strong>Page Fault</strong>라고 합니다.</p>\n<p>이 때 MMU는 인터럽트(Page Fault Trap)을 발생시켜 Page Fault Handler를 동작하고 여기서 페이지 교체 작업이 발생합니다.</p>\n<p>Page Fault Handler는 Page Table Entry의 Present Bit를 1로 변경하고, 디스크 데이터를 물리메모리로 적재하는 I/O작업을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093270-5092c56f-513e-4842-8bd9-320ed0dc6557.png\" alt=\"1\"></p>\n<p>앞서 Page Fault Handler를 통해 디스크에서 물리 메모리에 페이지를 적재한다고 했습니다. 그렇다면 위 그림을 보고 의문점이 생겨야 합니다.</p>\n<p><strong>Swap out을 언제 실행해야 하는가?</strong></p>\n<p>프로그램이 언제든 새로 시작될 수 있을 뿐만 아니라 운영체제는 특성상 항상 어느정도의 여유공간을 확보하고 있어야합니다. 이러한 운영체제 특성상 물리메모리가 가득 찼을 때만 Swap out을 하게되면 많은 문제점들이 발생합니다.</p>\n<p>이때문에 운영체제는 메모리 여유공간의 **최댓값(High watermark), 최솟값(Low watermark)**을 가지고있습니다. <strong>여유공간이 최솟값보다 적어지면 여유공간의 크기가 최댓값보다 작을때까지 여유공간을 확보</strong>합니다.  해당 스레드는 페이지 데몬(page daemon), 스왑 데몬(swap daemon)이라고 불리며, 충분한 여유공간이 확보될때까지 동작하다가 확보되면 백그라운드 스레드로 돌아갑니다.</p>\n<p><strong>Swap-out을 수행하는데, 어떤 페이지를 Swap Out 해야하는가</strong></p>\n<p>뒤이어 페이지 교체 정책에서 설명합니다.</p>\n<h2 id=\"페이지-교체-정책\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85\" aria-label=\"페이지 교체 정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 교체 정책</h2>\n<p>페이지 교체 정책에 대해 이야기하기 전에 교체 정책의 성능을 측정하는 방법에 대해 알아보아야 합니다.</p>\n<p><strong>AMAT(Average Memory Access Time): 평균 메모리 접근시간 = P(Hit) * T(M) + P(Miss) * T(D)</strong></p>\n<p>설명하자면, 스왑공간을 사용하는 가상 메모리 시스템의 평균 메모리 접근시간은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">P(Hit): 캐시 히트 확률 * T(M): 메모리 접근 시간을 곱해준 값 +\nP(Miss):페이지 폴트 확률과 T(D): 디스크 접근 시간</code></pre></div>\n<h3 id=\"최적-교체-방식-optimal-replacement-policy\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EA%B5%90%EC%B2%B4-%EB%B0%A9%EC%8B%9D-optimal-replacement-policy\" aria-label=\"최적 교체 방식 optimal replacement policy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 교체 방식 (Optimal Replacement Policy)</h3>\n<p>최적 교체방식의 원리는 간단합니다. <strong>“가장 나중에 참조할 페이지를 축출한다”</strong> 입니다.</p>\n<p>최적 교체방식은 이상적인 방법이지만, 가장 나중에 참조할 페이지 찾기라는 <strong>미래를 예측하는 불가능한 과정을 포함</strong>합니다.</p>\n<p>최적의 방법은 비교 기준으로만 사용되며, 비교하고자 하는 알고리즘이 정답에 얼마나 가까운지 알 수 있습니다.</p>\n<h3 id=\"lruleast-recently-used\" style=\"position:relative;\"><a href=\"#lruleast-recently-used\" aria-label=\"lruleast recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU(Least Recently Used)</h3>\n<p>LRU방식은 과거 메모리 접근에 대한 정보를 사용합니다. 이름 그대로 <strong>가장 먼 시점에 사용된 페이지를 교체합니다.</strong></p>\n<p>메모리 접근 정보 중에서 **최근성(recency)**를 사용한 방법입니다. 얼마나 최근에 접근했는지에 대한 정보를 가지고있습니다. 더 최근에 접근한 페이지일수록 가까운 시점에 다시 접근할 확률 이 높다는 특성인 **캐시 지역성의 원칙(Principle of locality)**이라는 특성에 기반을 둡니다.</p>\n<p>이처럼 메모리 접근 정보에는 빈도(frequency)도 있지만, MFU(Most Frequently Used)알고리즘은 캐시의 지역성 특징과 맞지 않으므로 효율적으로 동작하지 않습니다.</p>\n<p>예를들어 100번째 페이지를 5000회 접근한 이후 한번도 접근하지 않는다면 빈도수는 높아서 계속 물리메모리에 남아있지만 사용되지는 않습니다.</p>\n<p>LRU는 메모리 교체 방식중 효율이 가장 좋은 방법으로, 주로 사용되는 페이지 교체 알고리즘입니다.</p>\n<h3 id=\"간단한-방식들-fifo-random-select\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B0%A9%EC%8B%9D%EB%93%A4-fifo-random-select\" aria-label=\"간단한 방식들 fifo random select permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 방식들( FIFO, Random Select)</h3>\n<p><strong>First In First Out : 선입선출</strong></p>\n<p>먼저 들어온것이 먼저 나갑니다. 매우 간단한 알고리즘이지만 성능이 떨어집니다.</p>\n<p><strong>Ramdom Select: 무작위 선택</strong></p>\n<p>무작위로 Swap out될 페이지를 선택합니다. 해당 방법은 그때마다 수행 결과가 달라집니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"17750e88-7178-50d4-b121-377268c8ac01","fields":{"slug":"페이지-교체와-정책-swap"},"frontmatter":{"date":"2023-03-09","title":"페이지 교체와 정책 (Swap)","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},{"excerpt":"페이징 기법의 문제점 앞선 글에서 소개한 페이징 기법에서는 페이지의 크기를 4KB로 가정했습니다. 그러나 현대에는 메모리의 크기가 4GB를 넘어 64GB까지도 사용됩니다. 이런 컴퓨터에서 4KB의 페이지를 사용한다면 페이지 개수가 10^6 ~ 10^…","html":"<h3 id=\"페이징-기법의-문제점\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"페이징 기법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법의 문제점</h3>\n<p>앞선 글에서 소개한 페이징 기법에서는 페이지의 크기를 4KB로 가정했습니다. 그러나 현대에는 메모리의 크기가 4GB를 넘어 64GB까지도 사용됩니다.</p>\n<p>이런 컴퓨터에서 4KB의 페이지를 사용한다면 페이지 개수가 10^6 ~ 10^7까지도 커지게 됩니다.</p>\n<p>페이지 테이블은 각 프로세스마다 가지는 자료구조이고, <strong>“커널메모리”에 저장</strong>되는 자료이다 보니, <strong>페이지 테이블이 커지면 커질수록</strong> <strong>메모리 가용역역이 작아집니다.</strong></p>\n<p>또한, Segmentation에서는 해결된 메모리의 보호와 공유가 어렵다는 문제가 남아있습니다.</p>\n<h3 id=\"페이지-테이블-크기-문제-해결방법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95\" aria-label=\"페이지 테이블 크기 문제 해결방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 크기 문제 해결방법</h3>\n<p><strong>(1) 더 큰 페이지 크기</strong></p>\n<p>단순하게 생각하면 페이지 크기를 더 키우면 페이지 테이블 사이즈는 작아집니다.</p>\n<p>이를 통해 <strong>(1)디스크 접근횟수를 줄이고 (2)페이지 테이블크기를 줄이는</strong> 효과를 얻을 수 있습니다.</p>\n<p>메모리 크기가 커짐에 따라 페이지 사이즈를 키울수록 이 방법은 몇 가지 <strong>단점</strong>이 있습니다</p>\n<ol>\n<li>내부 단편화가 더 크게 발생합니다.</li>\n<li>큰 페이지를 로드했지만, 사용되는 비율이 적어 <strong>메모리 사용률이 줄어듭니다</strong>.</li>\n</ol>\n<p><strong>(2) Multi Level Paging 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093248-29394fe1-480b-41af-8c30-ed6745922558.png\" alt=\"1\"></p>\n<p>Multi Level Paging기법에서는 페이지 디렉터리를 통해 하나의 레벨을 추가합니다.</p>\n<p>또한 페이지 디렉터리 테이블(PDT)에는 valid bit가 존재합니다. 앞선 페이징 방법에서는 Heap공간에서 사용중인 페이지를 valid bit로 판별했던 반면, <strong>PDT에서의 valid bit는 PDE가 가르키는 페이지 테이블의 엔트리들 중 하나라도 유효한지에 대한 여부입니다(중요) → Heap 또는 Stack의 빈공간으로 인해 사용되는 메모리 낭비를 없애줌.</strong></p>\n<p><strong>장단점</strong></p>\n<p>페이징에서는 페이지 번호를 통해 페이지 테이블에 접근했으므로, 해당 페이지가 스왑 스페이스에 있어도 하나의 페이지  테이블을 가지고있어야 했습니다.</p>\n<p><strong>Multi Level Paging방법에서는 PDT의 valid bit가 1인 PMT에 대해서만 메모리 공간을 할당하므로 메모리 공간 효율성이 뛰어납니다.</strong></p>\n<p>그러나 Multi Level로 페이지 테이블이 존재하는 경우 가상주소 변환에 있어 메모리 접근을 N회 해야한다는 단점이 있습니다. (TLB로 완화할 수 있습니다)</p>\n<p>이처럼 MultiLevel Paging에는 시간-공간 등가교환이 존재합니다.</p>\n<p><strong>(번외) Segmentation/Paging Hybrid 방법</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093250-bb5c0f90-8f66-4cc1-8b47-ab1a13a3f84b.png\" alt=\"2\"></p>\n<p>Hybrid기법은 Segmentattion과 Paging기법을 혼합한 방법입니다.</p>\n<p>가상 메모리를 논리 단위의 세그먼트로 분할한 뒤, 이를 또 다시 페이지로 나눕니다.</p>\n<p>그렇기에 (그림 우측 상단의)가상 메모리 주소는 세그먼트 비트, 가상 페이지 번호인 Virtual Page Number,와 페이지 내에서의 Offset으로 이루어져 있습니다.</p>\n<p>즉, (S,P,D)값을 통해 물리 메모리 주소를 얻는것인데요, 방법은 아래와 같습니다.</p>\n<p><strong>1) 세그먼트 매핑 테이블 접근</strong></p>\n<p>세그먼트별로 존재하는 SMT에서 S번째 엔트리를 찾아갑니다. 여기서는 <strong>세그먼트 길이 검증, Protection Bit를 통해 자원의 공유와 보호를 수행</strong>합니다.</p>\n<p>또한 세그먼트에 대한 페이징 정보를 가지고있는 페이지 테이블 주소를 MMU에 전달합니다.</p>\n<p>물리메모리에는 Page 단위로 올라가므로 Residence bit는 존재하지 않습니다.</p>\n<p><strong>2) 페이지 매핑 테이블 접근</strong></p>\n<p>SMT에서 얻은 S(j)의 PMT 주소와 가상 페이지 번호인 VPN을 통해 물리 메모리에서 페이지의 주소를 획득합니다.</p>\n<p>이 때 Residence bit를 확인해 페이지가 존재하는지 확인하고 존재하지 않는다면 Page Fault Trap을 발생시켜 페이지 교체 알고리즘을 수행합니다.</p>\n<p><strong>3) PFN 획득 및 메모리 접근</strong></p>\n<p>PMT에서는 PFN을 얻었고, 여기에 페이지 크기를 곱하면 물리 메모리상 주소를 알 수 있습니다.</p>\n<p>Hybrid 기법은 페이징을 통해 메모리 사용률을 높혀준다는 장점과 세그멘테이션을 통해 보호와 공유를 용이하게 해준다는 장점이 있습니다.</p>\n<p>그러나 Hybrid방법에도 한계점은 존재합니다.</p>\n<ol>\n<li>여전히 페이지 테이블 크기가 많은 메모리 공간을 차지한다는 단점과</li>\n<li>Direct Mapping의 경우 가상 메모리 변환 시, 3회의 메모리 접근이 필요하다는 점입니다.\n<ol>\n<li>이는 TLB 활용으로 극복 가능합니다.</li>\n</ol>\n</li>\n</ol>\n<p>Fact Check</p>\n<ul>\n<li>\n<p>Protection Bit가 세그먼트에서 더 효율적인 이유</p>\n<p>→ 횟수에따른 용이성일것으로 생각, paging에서는 다음주소 참조시에도 또 확인해야해서</p>\n</li>\n<li>\n<p>Page Directory Table에서 또는 Page Table에서 Valid bit가 0인경우 swap공간에 있기는 한지?</p>\n<ul>\n<li>Multi Level Paging에서는 valid 가 0인 경우에 대해서 Page를 할당하지도 않는다! 따라서 swap공간에 있는게 아니라 사용하게되면 페이지를 다시 할당함.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"dfda67c2-6b6f-5a74-9ce7-bd696f306d49","fields":{"slug":"다양한-페이징-기법-hybrid-multi-level-paging"},"frontmatter":{"date":"2023-03-08","title":"다양한 페이징 기법 [ Hybrid, Multi Level Paging]","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},{"excerpt":"불연속 메모리 할당기법 세그멘테이션, 페이징은 대표적인 불연속 메모리 할당기법입니다. 각각 세그먼트, 페이지라는 단위로 프로그램을 나누고 페이지/세그먼트 테이블을 통해 가상/물리 메모리를 매핑, 연속적인 가상 주소공간을 사용할 수 있도록 합니다. 특징 및 연속 할당기법과의 차이 1 여전히 명령어는 가상주소를 기반으로 실행됩니다. Segmentation 프로그램을 의미있는 단위인 Heap, Stack, Code, Data…","html":"<h2 id=\"불연속-메모리-할당기법\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9%EA%B8%B0%EB%B2%95\" aria-label=\"불연속 메모리 할당기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불연속 메모리 할당기법</h2>\n<p><strong>세그멘테이션, 페이징</strong>은 대표적인 불연속 메모리 할당기법입니다. 각각 세그먼트, 페이지라는 단위로 프로그램을 나누고 페이지/세그먼트 테이블을 통해 가상/물리 메모리를 매핑, 연속적인 가상 주소공간을 사용할 수 있도록 합니다.</p>\n<h3 id=\"특징-및-연속-할당기법과의-차이\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9%EA%B8%B0%EB%B2%95%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"특징 및 연속 할당기법과의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징 및 연속 할당기법과의 차이</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093229-eeb1540a-35fd-4f8c-905a-e454c845160a.png\" alt=\"1\"></p>\n<p>여전히 명령어는 가상주소를 기반으로 실행됩니다.</p>\n<p><strong>Segmentation</strong></p>\n<p>프로그램을 의미있는 단위인 Heap, Stack, Code, Data등 프로그램을 구성하는 논리적 단위인 “세그먼트”로 분할해 메모리에 적재하는 방법입니다.</p>\n<p><strong>Paging</strong></p>\n<p>프로세스를 고정된 크기(intel x86의 경우 4kb)의 page block으로 프로그램을 나눠 물리 메모리에 할당하는 방법</p>\n<h2 id=\"물리메모리-매핑-과정\" style=\"position:relative;\"><a href=\"#%EB%AC%BC%EB%A6%AC%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A7%A4%ED%95%91-%EA%B3%BC%EC%A0%95\" aria-label=\"물리메모리 매핑 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>물리메모리 매핑 과정</h2>\n<p><strong>가상 주소 공간과 실제 메모리 주소의 매핑은 각각 페이지와 세그먼트 매핑 테이블 (PMT, SMT)가 담당합니다.</strong></p>\n<h3 id=\"페이징-기법에서-매핑과정-direct-mapping\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-direct-mapping\" aria-label=\"페이징 기법에서 매핑과정 direct mapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Direct Mapping</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093232-74c55ebc-45cb-4529-b1c9-5843031ed337.png\" alt=\"2\"></p>\n<p><strong>기본 가정</strong></p>\n<p>32bit 컴퓨터로 가정합니다 → 하나의 명령이 처리할 수 있는 데이터 양(word)가 32bit, 한 워드에 최대로 표시할 수 있는 메모리 주소는 2^32 byte이므로 최대 메모리가 4GB 입니다.</p>\n<p>이 때 페이지 크기를 설정해봅시다. 페이지 크기는 내부 단편화 및 로드 속도를 고려해 정하게 되는데, 윈도우 시스템에서는 4KB로 사용한다고 합니다.</p>\n<p>그렇다면 이론상으로는 4GB(2^32 Byte)의 메모리상에 4KB(2^12 Byte)의 페이지가  2^20개 존재할 수 있습니다.</p>\n<p><strong>(1) 명령어 실행</strong></p>\n<p>그렇기에 명령어 32bit는 그림 우측 상단처럼 <strong>20bit의 VPN과 12bit의 Offset</strong>(페이지 내 데이터 위치)로 구분할 수 있습니다. 이를 각각 P,D라고 칭합니다.</p>\n<p><strong>(2)PPN(Physical Page Number) 조회</strong></p>\n<p>1에서 얻은 가상 페이지 주소(P)는 페이지 테이블의 행 번호입니다. 페이지 테이블에서는 VPN(가상페이지번호)을 통해 PPN(물리메모리 페이지번호)을 얻을 수 있습니다.</p>\n<p><strong>(3) 물리 메모리 주소 반환</strong></p>\n<p>2과정에서 얻은 PPN(Z)과 1과정에서 얻은 페이지 내 변위 Offset(D)를 통해 물리 메모리 주소를 정확하게 알 수 있습니다 ( = Z + D ) 해당 주소의 명령은 CPU로 전달됩니다.</p>\n<p>가상/물리 메모리에서 Page Number는 바뀌기때문에 PPN, VPN으로 구분하지만 <strong>Offset은 Page 내에서 상대적인 위치이므로 물리메모리에서도 동일하게 사용할 수 있습니다.</strong></p>\n<p><strong>단점</strong></p>\n<p>Page Table은 프로세스별로 하나씩 가지고있으며 이는 <strong>커널 메모리(PCB)에 존재</strong>합니다.</p>\n<p><strong>따라서 메모리 데이터를 얻기 위해 메모리를 2회 접근하는 오버헤드가 발생합니다.</strong></p>\n<h3 id=\"페이징-기법에서-매핑과정-associate-mapping--tlb\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-associate-mapping--tlb\" aria-label=\"페이징 기법에서 매핑과정 associate mapping  tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Associate Mapping  (TLB)</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093235-7d5b2f89-6936-467f-a74b-5162bdae3305.png\" alt=\"3\"></p>\n<p>출처 : <a href=\"http://slideplayer.com/slide/5823226/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://slideplayer.com/slide/5823226/</a></p>\n<p>CPU칩셋 내부에 고속 하드웨어 서포트가 추가됩니다. TLB (Translation Lookaside Buffer)는 Page Table과 비슷한 구조를 띠지만, CPU 내에 위치해 병렬적으로 테이블을 탐색해 VPN → PPN 전환 속도를 더욱 빠르게 해줍니다.</p>\n<h3 id=\"페이징-기법에서-매핑과정-hybrid-small-tlb\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91%EA%B3%BC%EC%A0%95-hybrid-small-tlb\" aria-label=\"페이징 기법에서 매핑과정 hybrid small tlb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이징 기법에서 매핑과정: Hybrid (Small TLB)</h3>\n<p>TLB는 가격이 비싼 하드웨어이므로, 모든 페이지 테이블 정보를 담을만큼 충분한 크기를 가질 수 없습니다.</p>\n<p>시간 및 공간 지역성원리를 활용해, LRU로 교체되는 작은 TLB를 사용합니다.</p>\n<p>TLB 미스가 날 경우 TLB접근시간 + 메모리 접근 및 교체시간이 추가로 소요됩니다.</p>\n<h3 id=\"세그먼테이션-기법에서-매핑-과정\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95%EC%97%90%EC%84%9C-%EB%A7%A4%ED%95%91-%EA%B3%BC%EC%A0%95\" aria-label=\"세그먼테이션 기법에서 매핑 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그먼테이션 기법에서 매핑 과정</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093237-af52f4d4-1353-4652-a3e6-f48cb6951695.png\" alt=\"4\"></p>\n<p><strong>페이징 방법과의 차이</strong></p>\n<p>페이징에서 방법과 많은 부분이 유사합니다. 그러나 의미 단위인 “세그먼트”로 메모리를 나누었으므로 가상주소에서 최상위 N개 비트를 세그먼트 번호로 사용하면 됩니다.</p>\n<p>또한 페이징에서는 페이지가 고정 크기이므로 PPN을 통해 메모리에 접근할 수 있었지만 물리 메모리에서 세그먼트는 시작주소가 일정하지 않습니다. 그러므로 시작 주소를 직접 가지고있고, 세그먼트 길이도 제각각이므로 세그먼트 테이블에서 관리해 허용되지 않는 영역에 접근하는지 체크합니다. 즉, <strong>Offset이 세그먼트 길이보다 크면 Segmentation Fault를 발생시킵니다.</strong></p>\n<p><strong>세그먼트 크기</strong></p>\n<p>스택,힙,데이터, 코드의 대표적인 세그먼트 분류로 나누게 되면 최상위 2개 비트만으로 프로세스의 모든 세그먼트를 표현할 수 있습니다. 이를 <strong>대단위 세그먼트</strong> 라고 합니다.</p>\n<p>대단위 세그먼트에서는 외부 단편화 문제가 더 두드러지게 나타나고 세그먼트 로드 속도가 느리고 자주 사용되지 않는 데이터도 함께 로드되는 단점이 있습니다. 이를 위해 세그먼트를 더 세부적인 단위로 나누는 방법을 <strong>소단위 세그먼트</strong>라고 합니다.</p>\n<p>소단위 세그먼트는 프로세스당 세그먼트 수가 더 많으므로 세그먼트 테이블이 더 커진다는 단점이 있지만, 미사용 세그먼트를 구분해 메모리 사용률을 높일 수 있다는 장점이 있습니다.</p>\n<h3 id=\"전반적인-비교--segmentation-vs-paging\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EB%B0%98%EC%A0%81%EC%9D%B8-%EB%B9%84%EA%B5%90--segmentation-vs-paging\" aria-label=\"전반적인 비교  segmentation vs paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전반적인 비교 : Segmentation Vs Paging</h3>\n<p>세그멘테이션은 가변 길이의 세그먼트로 가상주소를 분리했으므로 외부 단편화가 발생할 수 있지만 논리 단위의 데이터 공유 및 보호가 용이합니다. 대단위 세그먼트로 분리하는 경우 메모리 사용률이 적어진다는 단점이 있지만, 소단위 세그먼트를 통해 극복할 수 있습니다. ( 세그먼트 테이블 크기와 Trade-Off )</p>\n<p>페이징은 고정 크기의 페이지로 가상 주소를 분리했으므로 내부 단편화가 발생할 수 있고 보호/공유 측면에서 복잡성이 존재하지만, 메모리 사용률 측면에서 높은 성능을 보이며 페이지 테이블</p>\n<h2 id=\"매핑-테이블로-알아보는-페이지세그먼트-변환\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%ED%95%91-%ED%85%8C%EC%9D%B4%EB%B8%94%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EB%B3%80%ED%99%98\" aria-label=\"매핑 테이블로 알아보는 페이지세그먼트 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매핑 테이블로 알아보는 페이지/세그먼트 변환</h2>\n<p>앞선 그림에서 확인한 세그먼트/페이지 매핑 테이블에는 주소 매핑을 위한 정보 말고도 각각을 설명하는 많은 정보를 담고있고 보호 및 효율을 위해 추가적인 동작을 합니다.</p>\n<p><strong>공통 구성요소</strong></p>\n<ul>\n<li>Present Bit : 물리메모리 상에 로드되어있는지 (Swap-in 여부, Swap Device에 존재할 경우 0 )</li>\n<li>Valid Bit : 스택 또는 힙의 미사용 공간은 invalid한 공간으로, 접근할 수 없음. 이를 마킹해 트랩을 통해 잘못된 영역으로의 접근을 막는다.</li>\n<li>Dirty Bit: 페이지/세그먼트가 메모리에 로드된 이후 변경되었는지 체킹해 이 비트가 세팅된 데이터는 주기적으로 메모리로 Flush작업을 한다.</li>\n<li>Protection Bit: 프로세스별로 해당 페이지에 RWX Access 권한을 마킹한 비트, 페이지 공유 및 보호를 가능하게 함.</li>\n<li>Swap Address: Swap device상에서 주소</li>\n</ul>\n<p><strong>페이지 테이블  구성요소</strong></p>\n<ul>\n<li>PPN: 물리메모리 페이지 번호</li>\n</ul>\n<p><strong>세그먼트 테이블 구성요소</strong></p>\n<ul>\n<li>Segment Address: 세그먼트 주소</li>\n<li>Segement Length: 세그먼트 크기</li>\n</ul>\n<h3 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h3>\n<p>세그멘테이션에서 가변 데이터인 스택, 힙에 대해 추가공간이 필요하면 어떻게할까?</p>\n<p>→ 런타임에서 길이가 증가/감소, 추가적인 빈 공간 리스트에 할당</p>\n<p>세그먼트 테이블은 프로세스별로 존재하는가?</p>\n<p>→Yes</p>\n<p>Valid bit가 Segmentation table 에서도 있는지 확인</p>\n<h3 id=\"\" style=\"position:relative;\"><a href=\"#\" aria-label=\" permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>\n<p><a href=\"https://talkingaboutme.tistory.com/entry/Memory-Sample-Memory-System\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://talkingaboutme.tistory.com/entry/Memory-Sample-Memory-System</a></p>","id":"e833f569-08c9-5577-a07b-57804ec11128","fields":{"slug":"세그멘테이션과-페이징-비교"},"frontmatter":{"date":"2023-02-27","title":"세그멘테이션과 페이징 (+ 비교 )","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},{"excerpt":"프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다. 주소공간 1 컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다. 이는 프로세스 하나가 실행될때 만들어지는 가상의 주소공간이고, 프로그램 코드 영역에서는…","html":"<p>프로세스에게 메모리를 할당해주는 방식의 발전과정과, CPU가 안전하게 메모리에 접근하기 위해 주소공간을 가상화하는 방법을 설명합니다.</p>\n<h1 id=\"주소공간\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EA%B3%B5%EA%B0%84\" aria-label=\"주소공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소공간</h1>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093193-30acf0ce-093c-41b6-aacd-b9b791c2ff85.png\" alt=\"1\"></p>\n<p>컴퓨터공학 수업들을 들으며 수없이 봐왔던 주소공간입니다.</p>\n<p>이는 프로세스 <strong>하나가 실행될때 만들어지는 가상의 주소공간</strong>이고, 프로그램 코드 영역에서는 <strong>0을 기준</strong>으로 주소를 참고합니다.  이같은 주소공간은 물리메모리상에 프로세스의 개수만큼 존재합니다.</p>\n<p>현대의 컴퓨터들은 메모리 영역을 가상화하기 위해 “주소공간”이라는 개념을 만들어 명령어를 실행할 때 명령어의 물리메모리상 실제 위치를 알고있지 않아도 되도록 구성했습니다.</p>\n<p>운영체제에서 프로세스를 실행할 때 <strong>주소변환을 통한 가상화</strong>로 다른 프로세스로부터 <strong>보호와 고립</strong>이 가능하도록 합니다.</p>\n<h2 id=\"주소변환-baselimit-방법-연속할당-방법에서-사용\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C%EB%B3%80%ED%99%98-baselimit-%EB%B0%A9%EB%B2%95-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"주소변환 baselimit 방법 연속할당 방법에서 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소변환: base/limit 방법 (연속할당 방법에서 사용)</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093194-a99d68fe-1d74-4b80-b0c5-6dc4006860e4.png\" alt=\"2\"></p>\n<p>주소변환을 통해 명령어를 실행할 때 물리메모리 주소에 대해 생각하지 않아도 되는 메모리 가상화가 가능해집니다.</p>\n<p>CPU는 base, limit레지스터를 가지고있어 <strong>가상주소가 limit을 넘어갈 경우</strong> 예외를 발생시켜 <strong>프로세스를 보호</strong>합니다. <strong>base레지스터는 physical address로 접근 시 주소를 변환</strong>하는데 사용합니다.</p>\n<p>또한 Context Switch시에는 base/limit을 PCB에서 불러와 갱신합니다.</p>\n<h1 id=\"연속-메모리-할당-방법\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95\" aria-label=\"연속 메모리 할당 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리 할당 방법</h1>\n<p>연속 메모리할당 방법이란: 프로세스가 필요로 하는 데이터를 메모리에 연속적으로 할당하는 방식으로, 이후에 배울 발전된 방식인 “불연속 메모리 할당”과 대비되는 개념입니다.</p>\n<p>(관계 정리)</p>\n<p>Continuous Memory Allocation: 연속 메모리 할당</p>\n<ul>\n<li>Uni Programming</li>\n<li>Multi Programming\n<ul>\n<li>Fixed Allocation: 고정 할당</li>\n<li>Variable Allocation: 가변 할당</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093195-92e059e3-2461-4979-92c9-60e0ebfb77a2.png\" alt=\"3\"></p>\n<h3 id=\"uni-programming\" style=\"position:relative;\"><a href=\"#uni-programming\" aria-label=\"uni programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uni Programming</h3>\n<p><strong>Uni Programming</strong>은 운영체제 개발 초기에 단일 사용자가 단일 프로그램을 사용하는 모델에서 개발된 할당방식입니다.</p>\n<p>하나의 PC에서 하나의 프로그램만 메모리를 할당받을 수 있었죠. 아래와 같은 문제점이 있습니다.</p>\n<ul>\n<li>CPU활용도 낮음</li>\n<li>메모리 활용도 낮음(공간의 낭비가 큼)</li>\n</ul>\n<h3 id=\"multi-programming\" style=\"position:relative;\"><a href=\"#multi-programming\" aria-label=\"multi programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi Programming</h3>\n<p>Uni Programming은 위같은 문제점들과 다중 사용자 니즈에 맞춰 점차 사라졌습니다.</p>\n<p>이후 여러 프로세스를 메모리에 할당할 수 있는 방법인 Multi Programming이 등장하고, CPU를 시분할 방식으로 사용해 다양한 프로세스를 동시에 사용하는것처럼 동작할 수 있게 되었습니다.</p>\n<p><strong>Multi Programming: Fixed Allocation (고정 할당 방법)</strong></p>\n<p>여러 프로세스가 사용할 수 있는 공간을 고정된 크기로 나누는 방법입니다.</p>\n<ul>\n<li><strong>내부 단편화가 발생합니다</strong>:  5kb만큼 필요한 프로세스가 있더라도 고정된 크기(예를 들어 10MB)를 할당받아, 파티션 내부에서 낭비하는공간이 발생합니다.</li>\n<li>프로세스가 고정 파티션 크기보다 클 수 있습니다.</li>\n</ul>\n<p><strong>Multi Programming: Variable Allocation (가변 할당 방법)</strong></p>\n<p>프로세스가 사용할 공간을 프로세스의 크기에 맞춰 나누는 방법입니다.  프로세스가 시작할때, 종료할때 Allocation Table을 변경하면서 파티션을 관리합니다.</p>\n<p><strong>가변 할당 정책</strong>에 따라 운영체제에서 관리하는 가용공간 리스트를 탐색해 메모리를 할당합니다.</p>\n<p>Best-fit: 가용 공간을 탐색 후 프로세스가 필요한메모리와 가장 차이가 적은 파티션에 할당</p>\n<p>First-fit: 메모리 크기만큼 할당할 수 있는 첫 파티션에 할당</p>\n<p>Worst-fit: 메모리 크기를 할당할 수 있는 가장 큰 파티션에 할당</p>\n<p>속도: First > Best, Worst</p>\n<p>공간효율: Best > First, Worst</p>\n<p>Fixed Allocation의 문제점들을 다소 극복했지만 아직 문제점이 남아있습니다.</p>\n<ul>\n<li><strong>외부 단편화가 발생합니다:</strong> 크기가 작은 프로세스가 종료해 메모리에서 해제되면 사용중인 파티션 사이에 사용하지 못하는 공간이 발생</li>\n<li>Allocation Table을 순회해야하는 오버헤드 발생</li>\n</ul>\n<h3 id=\"연속-메모리할당-방법의-문제점\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"연속 메모리할당 방법의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 메모리할당 방법의 문제점</h3>\n<p>앞서 설명한 여러 <strong>연속 메모리 할당 방법들에는 공통적인 문제</strong>가 남아있습니다.</p>\n<ul>\n<li>프로세스가 필요한 메모리를 시작하는 시점에 알 수 없음</li>\n<li>프로세스가 새로 시작할 때 프로그램 데이터를 모두 디스크 → 메모리로 데이터를 옮겨야하는데, 이는 상당히 느린 방법</li>\n<li>내/외부 단편화로 인한 메모리공간 낭비가 어떤 방식으로든 남아있음</li>\n</ul>\n<p>이런 문제점들은 이후 페이징, 세그멘테이션을 공부하며 해결할 수 있습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(</a></strong><a href=\"https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=es3WGii_7mc&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a><strong>)</strong></p>","id":"79df45f7-38b0-5842-9e5b-c64401618056","fields":{"slug":"연속메모리-할당과-주소-공간"},"frontmatter":{"date":"2023-02-20","title":"연속메모리 할당과 주소 공간","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},{"excerpt":"현대에는 4 또는…","html":"<p>현대에는 4 또는 8코어 등 멀티코어를 통해 성능을 극대화하는 시도들이 성공을 거두면서, 다중 코어 시스템을 쉽게 찾아볼 수 있게 되었습니다.</p>\n<p>명령어를 실행하는 코어가 여러개라니 다다익선이라고 생각할 수 있습니다.</p>\n<ul>\n<li>\n<p>병렬화의 한계: 병렬화 할 수 있는 작업이 한정적이고, 많은 수의 작업을 병렬화하더라도 이를 병합하는데 오버헤드가 발생합니다.</p>\n<p><strong>하지만  병렬화에도 한계가 존재합니다. (컴퓨터구조론에서 자세히 다룹니다)</strong></p>\n</li>\n<li>\n<p>캐시/메모리 병목: 공유자원인 캐시 및 메모리의 특정 자원에 여러 코어가 접근하면 Lock등을 사용해 동시성을 확보해야 합니다.</p>\n<p>Lock에 의해 프로세서가 대기하는것을 Blocking이라고 하는데, 코어 수가 높을수록 같은 자원에 접근할 확률이 높아져 Blocking시간이 길어집니다.</p>\n<p>잘못된 동기화 알고리즘을 사용할 경우 성능이 급격하게 안좋아질 수 있습니다.</p>\n</li>\n</ul>\n<h2 id=\"멀티프로세서의-문제점\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"멀티프로세서의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서의 문제점</h2>\n<p>앞서 언급한 병렬화의 한계에서는 코어가 늘어날수록 성능이 비례하지 않는 이유에 관한 내용이었습니다.</p>\n<p>아래의 멀티프로세서 구조를 참고해 어떤 치명적인 문제가 있을지 알아보겠습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093159-1d3965f3-a3fd-4b46-95b5-4b02559d09a0.png\" alt=\"1\"></p>\n<ul>\n<li>일반적인 Personal Computer에서는 L3캐시까지 사용되는게 일반적입니다.</li>\n<li>L2캐시까지만 존재하는 경우도 있으며 Intel칩셋 역시 몇몇 모델에 공유 캐시가 존재함을 확인할 수 있습니다.\n<ul>\n<li>(<a href=\"https://en.wikipedia.org/wiki/Intel_Core\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Intel_Core</a>)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"캐시-일관성-문제-cache-coherance-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-coherance-problem\" aria-label=\"캐시 일관성 문제 cache coherance problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>캐시 일관성 문제 (Cache coherance problem)</strong></h3>\n<p>캐시는  메인 메모리에서 자주 사용되는 정보를 저장해놓는 데이터의 복사본입니다.</p>\n<p>각각의 코어는 근처에 L1, L2코어가 있고 L3 코어부터는 메모리 주변에 위치해있습니다.</p>\n<p><strong>프로세서에서 데이터 조회</strong>는 L1캐시에서 데이터를 조회하고 존재하지 않을 시 L2 ~ Main Memory까지 조회하는 방법을 사용하고,</p>\n<p><strong>프로세서가 데이터를 저장</strong>할때는 위치가 가까운 L1, L2캐시에는 쉽게 데이터를 저장할 수 있지만 L3캐시나 메인 메모리에는 쓰기 비용이 많이 들어 한번에 작성합니다.</p>\n<p>만약 Core 1이 A라는 데이터를 A’로 수정했다면, L1,L2캐시에 반영될 것입니다. 그런데 이 때 Core2가 A의 위치에서 데이터를 가져오고자 한다면 수정된 A’이 아니라 이전 데이터인 A를 가져오게 됩니다.</p>\n<p>이를 <strong>캐시 일관성 문제</strong> 라고 합니다.</p>\n<p>이는 데이터 버스를 모니터링하는 MESI등의 프로토콜을 사용해 캐시 접근을 감시해 캐시 불일치를 잡아내고, 무효화(캐시에서 삭제)하거나 원본 캐시 플러시를 통해 해결합니다.</p>\n<p>이를 <strong>버스 스누핑이라고 합니다. (</strong><a href=\"https://en.wikipedia.org/wiki/Bus_snooping\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Bus_snooping</a>) ****</p>\n<h3 id=\"원자성-보장-문제-atomicity-problem\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%9E%90%EC%84%B1-%EB%B3%B4%EC%9E%A5-%EB%AC%B8%EC%A0%9C-atomicity-problem\" aria-label=\"원자성 보장 문제 atomicity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원자성 보장 문제 (Atomicity problem)</h3>\n<p>(캐시 일관성 문제가 해결되어, 캐시에 있는 정보는 믿을 수 있다고 가정합니다)</p>\n<p>CPU는 병렬적으로 실행되므로 같은 데이터에 대해 접근하는 스레드가 여러개일 수 있습니다.</p>\n<p>이로 인한 동시성 문제가 생길 수 있고, 이는 운영체제 레벨에서 Lock을 제공해야 해결할 수 있습니다.</p>\n<p>또한 앞서 말했듯 프로세서 수가 많아질수록 Lock의 Blocking으로 인한 오버헤드가 발생합니다.</p>\n<h3 id=\"캐시-친화성-문제-cache-affinity-problem\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C-%EC%B9%9C%ED%99%94%EC%84%B1-%EB%AC%B8%EC%A0%9C-cache-affinity-problem\" aria-label=\"캐시 친화성 문제 cache affinity problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시 친화성 문제 (Cache affinity problem)</h3>\n<p>캐시의 기본 원리는 “더 자주 사용하는 소수의 데이터를 더 가까이 둔다” 입니다.</p>\n<p>또한  다수의 일반적인 프로그램은 어떤 경향성을 보입니다.</p>\n<ul>\n<li><strong>시간 지역성: 최근에 사용한 데이터를 다시 참조할 가능성이 높음(예시:반복문에서 동일변수 참조)</strong></li>\n<li><strong>공간 지역성: 최근에 사용한 데이터의 주변에 있는 데이터를 참조할 가능성이 높음(예시: 배열 순회)</strong></li>\n</ul>\n<p>위 가정들 때문에 캐시에는 다음에 참조할 데이터가 존재할 확률이 높은것이죠.</p>\n<p>만약 다수의 프로세서(CPU)에게 레디 큐에 있는 프로세스를 무작위로 실행한다면,</p>\n<p>A프로세스를 실행하기 위해 로드한 캐시들이 B 프로세스를 사용한다면 또다시 B 프로세스를 위한 캐시들을 로드해야 할 것이고, 심각한 성능 하락으로 이어집니다. (이를 Cache warm up이라고 합니다)</p>\n<h2 id=\"멀티프로세서에서의-스케줄링\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"멀티프로세서에서의 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티프로세서에서의 스케줄링</h2>\n<h3 id=\"단일-큐-멀티프로세서-스케줄링-sqms\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%ED%81%90-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-sqms\" aria-label=\"단일 큐 멀티프로세서 스케줄링 sqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 큐 멀티프로세서 스케줄링 SQMS</h3>\n<p>단일 큐 멀티프로세서 스케줄링 SQMS ( Single Queue Multiprocessor Scheduling )은 이름 그대로 <strong>프로세서가 여러개더라도 하나의 스케줄링 큐를 사용하는 것입니다.</strong></p>\n<p>이는 간단하게 생각해도 여러가지 문제가 있습니다.</p>\n<ol>\n<li>Ready Queue도 공유자원입니다. 여러 프로세스가 동시에 하나의 프로세스를 실행하고자 큐에서 빼면, 실제로는 하나의 프로세서만 동작하게 되기에, <strong>락을 걸어서 Queue를 임계구역으로 설정</strong>해야 합니다.</li>\n<li>Ready Queue를 임계구역으로 설정해 Lock을 적용하면, 심각한 성능 저하가 발생합니다.</li>\n<li>캐시에 친화적이지 않습니다.</li>\n</ol>\n<h3 id=\"멀티-큐-스케줄링-mqms\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%81%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-mqms\" aria-label=\"멀티 큐 스케줄링 mqms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 큐 스케줄링 MQMS</h3>\n<p>멀티 큐 스케줄링 MQMS (Multi-Queue Multiprocessor Scheduling)은 <strong>CPU별로 Ready Queue를 두고, 프로세서별 스케줄링 큐에 작업을 균등하게 할당하는 방식입니다.</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093162-d1eed259-c233-4529-9df5-c59d8b7b740a.png\" alt=\"2\"></p>\n<p><strong>해결된 문제</strong></p>\n<ul>\n<li>SQMS에서는 Ready Queue가 공유자원이었는데, 이제 프로세서별로 하나의 큐가 있으므로 Lock에 의한 오버헤드가 사라졌습니다.</li>\n<li>프로세서는 무작위의 프로세스를 실행하지 않고 특정 프로세스만을 실행하므로 캐시 친화성이 떨어지는 문제가 해결되었습니다.</li>\n</ul>\n<p><strong>새로운 문제점과 해결방법</strong></p>\n<p><strong>워크로드 불균형</strong>: 만약 CPU 1에 할당된 프로세스 A가 엄청나게 오래 동작한다면? CPU1의 Ready Queue에는 많은 프로세스가 쌓이는 반면, CPU0은 큐에 프로세스가 없어 놀아버리는 사태가 발생합니다.</p>\n<h3 id=\"질문-목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"질문 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문 목록</h3>\n<p>(진짜 질문) 워크로드 불균형 문제는 작업 할당 시 할당된 작업이 적은 프로세서에게 할당하면 해결되는것 아닌가?</p>\n<p>(진짜질문) 데드락을 발생시키지 않는 Locking 방법이 있는지? ( 아직 진도 안나갔지만, Spin Lock이 멀티프로세서에서 어떻게 동작할지 생각해오기)</p>\n<p>싱글코어에서는 운영체제가 동기화를 위해 락을 사용하지 않아도 될까?</p>\n<ul>\n<li>\n<p>정답</p>\n<p>싱글코어 컨텍스트 스위칭 역시 인터럽트 기반으로 동작하고, 인터럽트는 실행중이던 마이크로 오퍼레이션까지만 실행한다. 마이크로 오퍼레이션이란, CPU Instruction이 포함하는 Fetch Decode Excecute Memory WriteBack보다 더 작은 단위이다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C_%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%EC%85%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/마이크로_오퍼레이션</a></p>\n<p>→ 당연히 동시성을 보장해주지 않는다</p>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"></a></strong>)**</p>\n<h3 id=\"sub-reference\" style=\"position:relative;\"><a href=\"#sub-reference\" aria-label=\"sub reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sub Reference</h3>\n<p>TLB <a href=\"https://wpaud16.tistory.com/304\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wpaud16.tistory.com/304</a></p>","id":"71591062-f239-5250-88e1-ff83b143ce00","fields":{"slug":"멀티프로세서-스케줄링과-동기화"},"frontmatter":{"date":"2023-02-15","title":"멀티프로세서 스케줄링과 동기화","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},{"excerpt":"OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다. 책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다. 인터럽트의 종류 Hardware Inturrupt : 외부 기기 또는 사용자, 입/출력에 의한 불특정 시간에 발생해 Asynchronous Interrupt라고도 불립니다. Clock…","html":"<p>OSTEP에서 본문에 해당하는 챕터 제목이 “Limited Directed Execution: 제한된 직접 실행 원리” 입니다.</p>\n<p>책에서는 인터럽트의 한 종류인 trap에 대해서만 다루지만, 인터럽트에 대해 포괄적으로 알기 위해 관련내용도 정리했습니다.</p>\n<h3 id=\"인터럽트의-종류\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인터럽트의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 종류</h3>\n<p><strong>Hardware Inturrupt : 외부 기기 또는 사용자, 입/출력에 의한 불특정 시간에 발생해 Asynchronous Interrupt라고도 불립니다.</strong></p>\n<ul>\n<li>Clock Interrupt: 한 스레드가 프로세스를 과도하게 점유하는것을 막기 위해 지정된 시간마다 발생하는 인터럽트</li>\n<li>I/O Interrupt: 사용자의 입/출력(또는 예상치못한 외부 이벤트)에 의한 인터럽트</li>\n<li>Machine Check Interrupt: 기기 결함이 발견되었을 때 발생하는 인터럽트</li>\n</ul>\n<p><strong>Software Interrupt (or Trap, Synchronous Interrupt): SW의 예외 핸들링 또는 제어권을 얻기 위해 발생시키는 인터럽트입니다.</strong></p>\n<ul>\n<li>Supervisor Call(System Call Interrupt): 사용자 프로그램이 하드웨어 자원을 사용하기 위해 유저모드에서 커널모드로 들어갈 때 발생시키는 인터럽트.</li>\n<li>Program Check Interrupt: 0으로 나누기, 스택오버플로/언더플로같은 S.W Exception처리하는 인터럽트.</li>\n</ul>\n<h2 id=\"제한된-직접실행-개요\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%ED%95%9C%EB%90%9C-%EC%A7%81%EC%A0%91%EC%8B%A4%ED%96%89-%EA%B0%9C%EC%9A%94\" aria-label=\"제한된 직접실행 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제한된 직접실행 개요</h2>\n<p>먼저 Limited가 없는 직접 실행이라는 부분에 대해 알아보자면 , 운영체제가 프로그램의 실행에 관여하지 않고 CPU는 사용자 코드에서 진입점을 찾아 직접 실행함을 의미합니다. 이 경우 몇가지 문제가 발생합니다.</p>\n<p>프로세서(CPU)가 프로세스로 자원을 나눠줄 때 고려해야할 부분으로 크게 세 가지 중요한 요소가 있습니다.</p>\n<ol>\n<li><strong>제어권</strong>: 운영체제가 <strong>CPU 및 자원에 대한 제어권을 가진 상태로 프로세스를 실행</strong>해야 합니다. 제어권을 상실할 경우 프로세스가 자원을 무기한 점유하는 상황이 발생할 수도 있기 때문이죠.</li>\n<li><strong>성능:</strong> CPU앞서 말했듯 CPU는 초당 처리속도가 다른 하드웨어 기기에 비해 월등히 빠릅니다. 메모리 또는 하드디스크에서 데이터를 가져오는동안 CPU는 정말 많은 시간을 기다려야하겠죠. <strong>운영체제가 이런 I/O작업을 하는 프로세스의 제어권을 뺏고 다른 프로세스를 실행해 CPU활용률을 극대화</strong>합니다.</li>\n<li><strong>자원 보호:</strong> 제한없이 실행되는 프로세스는 전체 디스크,메모리를 읽고 쓸 수 있으므로, 이 부분에 대한 제어가 꼭 필요하다 <strong>( System Call Interface를 통한 User/Kernal Mode 분기)</strong></li>\n</ol>\n<p>요약하자면, 다른 장치에 비해 빠른 CPU의 <strong>성능</strong>을 최대한 <strong>안전하게</strong> 활용하기 위해 운영체제가 CPU의 제어권을 갖는 개념을 Limited Directed Execution: 제한된 직접 실행이라고 합니다.</p>\n<h3 id=\"인터럽트의-실행과정\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95\" aria-label=\"인터럽트의 실행과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 실행과정</h3>\n<p>프로세스가 CPU의 제어권을 갖고있는 상태에서 제어권을 얻기 위해선 인터럽트를 통해 제어권을 뺏어와야 합니다.</p>\n<p>인터럽트 발생: MCU(또는 PIC)라는 장비에 IDT(인터럽트 종류, ISR위치, 우선순위)를 전달하면서 시작됩니다.</p>\n<p>→ <strong>(하드웨어)프로세스 중단</strong></p>\n<ul>\n<li>Context Saving 발생: CPU register를 <strong>커널 스택</strong>에 대피시킨다.</li>\n<li>커널모드로 이동.</li>\n</ul>\n<p>→ <strong>(운영체제)인터럽트 처리(Interrupt Handling)</strong></p>\n<ul>\n<li>인터럽트를 요청한 장치 또는 메모리 주소, 인터럽트의 원인을 확인하고 ISR 주소로 이동해 ISR을 실행한다.</li>\n</ul>\n<p><strong>인터럽트 서비스 루틴 실행</strong> : 예를들어 마우스로 음악 프로그램을 더블클릭 해 인터럽트가 발생했다면, 해당 프로그램을 프로세스 레디 큐에 등록하는 작업을 한다.</p>\n<p>→ <strong>(하드웨어)상태 복구: 커널 스택에 저장된 CPU레지스터들을 불러오고</strong>, 복구한 PC레지스터로 이동해 원래 프로세스 실행</p>\n<p>→ (프로그램): 복구한 PC레지스터부터 다시 실행하므로, 기존 실행시점에서 다시 동작합니다.</p>\n<h3 id=\"interrupt로-context-switch가일어나는-경우\" style=\"position:relative;\"><a href=\"#interrupt%EB%A1%9C-context-switch%EA%B0%80%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"interrupt로 context switch가일어나는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interrupt로 Context Switch가일어나는 경우</h3>\n<p>만약 Timer Interrupt가 발생하고 그로인해 ISR에서 스케쥴러로 분기 →  Process A의 버스트 시간이 끝나 Ready상태로 바꾸는 상황을 가정해보겠습니다.</p>\n<p>(아직 스케줄러에 대해 배우지 않았지만 참고로, 스케쥴러 알고리즘은 매 타임 퀀텀마다, I/O로 인한 블록마다 동작하도록 ISR에 정의되어있습니다.  새로운 프로세스가 등록될때에도 비교를 위해 동작합니다. )</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093145-c874af7d-2608-4373-97ec-94798ef0ea46.png\" alt=\"Interrupt_And_ContextSwitch drawio\"></p>\n<p>인터럽트가 동작하는 구조는 같지만, 내부에서 동작하는 스케쥴링 처리로 인해 ISR이후 Process(j)로 실행됩니다.</p>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(i)를 중단하고 Process(i)실행시점의 <strong>레지스터를 커널 스택으로 대피</strong>합니다.</li>\n<li>커널모드로 변경합니다.</li>\n</ul>\n<p><strong>(운영체제의 Timer Interrupt에 대한 ISR 동작)</strong></p>\n<ul>\n<li>커널 스택에 있는 Process(i)의 레지스터를 Process(i)의 PCB에 저장해줍니다.</li>\n<li>j의 PCB에 저장된 Process(j)의 레지스터를 커널스택으로 옮깁니다.</li>\n<li>j프로세스의 실행주소(PC)로 return from trap합니다.</li>\n</ul>\n<p><strong>(하드웨어)</strong></p>\n<ul>\n<li>Process(j)의 커널스택에 있는 레지스터를 CPU로 복구합니다.</li>\n<li>유저모드로 변경합니다.</li>\n</ul>\n<p><strong>(프로그램)</strong></p>\n<p>Process(j)를 실행</p>\n<h3 id=\"인터럽트의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"인터럽트의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터럽트의 우선순위</h3>\n<p><strong>전원 이상(Power fail) > 기계 착오(Machine Check) > 외부 신호(External) > 입출력(I/O) > 명령어 잘못 > 프로그램 검사(Program Check) > SVC(SuperVisor Call)</strong></p>\n<p>만약 우선순위가 낮은 인터럽트를 수행하는 중에 우선순위가 높은 인터럽트가 발생하면 우선적으로 처리한 뒤 다시 낮은 순위의 ISR로 돌아가 처리합니다. (재귀적 우선순위 처리)</p>\n<h3 id=\"질문목록\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8%EB%AA%A9%EB%A1%9D\" aria-label=\"질문목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문목록</h3>\n<p>Interrupt, Trap, Exception의 차이를 시스템 관점에서</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.4 Process Management](</strong><a href=\"https://www.youtube.com/watch?v=jZuTw2tRT7w\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <strong>)</strong></p>\n<p>(sub reference)</p>\n<p><a href=\"https://raisonde.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8Interrupt%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://raisonde.tistory.com/entry/인터럽트Interrupt의-개념과-종류</a></p>\n<p><a href=\"https://justzino.tistory.com/4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://justzino.tistory.com/4</a></p>\n<p><a href=\"https://wiki.osdev.org/Interrupt_Service_Routine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wiki.osdev.org/Interrupt_Service_Routine</a></p>\n<p>커널의 메모리구조 - <a href=\"https://kariskan.tistory.com/52\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kariskan.tistory.com/52</a></p>","id":"d18acb80-a184-5ffd-a668-8349d3729d5f","fields":{"slug":"인터럽트와-제한된-직접-실행"},"frontmatter":{"date":"2023-02-14","title":"인터럽트와 제한된 직접 실행","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":2},{"excerpt":"개요 스케쥴링이란, CPU 자원을 계획에 따라 여러 프로세스에게 나누어주는 방법입니다. 여러가지 스케쥴링 항목에 대해 공부하기 전에, 왜 스케쥴러를 사용하는지에 대해 생각하면 더 편하게 이해할 수 있습니다. 앞서 공부한 프로세스의 상태 중, CPU를 할당받기 위해 Ready → Running 상태의 전이를 담당하는것이 스케쥴링입니다. 그래서 기본적으로 Ready Queue…","html":"<h3 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h3>\n<p>스케쥴링이란, CPU 자원을 계획에 따라 여러 프로세스에게 나누어주는 방법입니다. 여러가지 스케쥴링 항목에 대해 공부하기 전에, 왜 스케쥴러를 사용하는지에 대해 생각하면 더 편하게 이해할 수 있습니다.</p>\n<p>앞서 공부한 프로세스의 상태 중, CPU를 할당받기 위해 <strong>Ready → Running</strong> 상태의 전이를 담당하는것이 스케쥴링입니다. 그래서 기본적으로 Ready Queue에 여러 프로세스가 대기중이고, 스케쥴링 정책은 이 큐에 있는 프로세스를 어떻게 실행할지에 대한 이야기라고 생각하면 됩니다.</p>\n<p>운영체제는 목적에 따라 여러 종류가 있습니다. 대화형 시스템, 배치 시스템 등..</p>\n<p>대화형 시스템에서는 CPU의 활용성이 조금 떨어지더라도 유저의 요청에 <strong>반응하는 시간</strong>이 빨라야하고,</p>\n<p>대규모 데이터를 처리하는 배치 시스템에서는 응답시간보다는 <strong>처리량</strong>이 우선일 것입니다.</p>\n<p>응답시간, 처리량같이 운영체제별로 스케쥴링의 목적이 있고, 이외에도 공평성, 무한대기 방지, 활용률 등 다양한 평가항목이 있어, 스케쥴링 알고리즘을 선택할 때 고려해야 합니다.</p>\n<h3 id=\"스케쥴링-성능평가-용어-정리\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%84%B1%EB%8A%A5%ED%8F%89%EA%B0%80-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC\" aria-label=\"스케쥴링 성능평가 용어 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 성능평가 용어 정리</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093035-ef33201e-3ca0-4f2b-b94a-d3414eb4bc3c.png\" alt=\"1\"></p>\n<ul>\n<li><strong>Response Time, 응답시간 / T(response) - T(arrival) :</strong> 레디큐에 도착해 처음으로 스케쥴될때까지 걸린 시간</li>\n<li><strong>Waiting Time, 대기시간 / T(sum of waiting) :</strong> 레디큐에 도착해 running이 되기까지 걸린 시간의 합\n<ul>\n<li><strong>응답시간은 Ready Queue도착에서 첫 스케쥴까지 걸린시간, 대기시간은 프로세스가 종료되기까지 Ready Queue에 있는 시간의 총 합을 의미합니다.</strong></li>\n</ul>\n</li>\n<li><strong>Burst Time, 실행시간 / T(completion) - T(start)</strong> : CPU를 할당받아 실행한 시간</li>\n<li><strong>Turnaround Time, 반환시간 / T(completion)- T(arrival) :</strong> 레디큐에 도착해 작업을 완료하기까지 걸린 시간</li>\n</ul>\n<p>위와 같은 기준들로 <strong>“성능”</strong> 을 평가할 수 있으며, 여러 프로세스가 번갈아가며 실행하므로, 일반적으로는 반환시간 또는 대기시간의 <strong>평균</strong>을통해 스케쥴링의 적합성을 판단합니다.</p>\n<p>또한, <strong>공정성</strong>도 중요한 평가요소 중 하나입니다. 스케쥴링 방법을 공부하다보면 알겠지만, 일반적인 경우 처리량과 공정성은 등가교환 관계이기 때문에 주의해야 합니다.</p>\n<h2 id=\"스케쥴링-방법들\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EB%B0%A9%EB%B2%95%EB%93%A4\" aria-label=\"스케쥴링 방법들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케쥴링 방법들</h2>\n<p><strong>먼저 알고가야 할것. 선점형 vs 비선점형</strong></p>\n<p>유저 이벤트로 인한 프로세스 시작이나 I/O 종료 인터럽트로 인해 Ready Queue에 다양한 프로세스들이 들어옵니다.</p>\n<p>이 때, 새로운 프로세스가 즉시 CPU 할당을 받아서(뺏어와서) 실행할 수 있는 스케쥴링 종류를 선점형(Preemitive), 그렇지 않고 해당 프로세스의 Burst Time이 끝나는것을 기다려하는 스케쥴링 종류를 비선점형(Non-Preemitive)라고 합니다</p>\n<h3 id=\"fcfs-또는-fifo-알고리즘\" style=\"position:relative;\"><a href=\"#fcfs-%EB%98%90%EB%8A%94-fifo-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"fcfs 또는 fifo 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FCFS (또는 FIFO) 알고리즘</h3>\n<p>First Come First Service (First In First Out) 즉, 선착순/선입선출 알고리즘입니다. Ready Queue에 들어온 순서대로 CPU를 할당해줍니다. 비선점형 스케쥴링 알고리즘입니다</p>\n<p>일상생활에서는 공평하게 처리하기 위해 자주 사용되는 알고리즘입니다. 매우 간단하고 얼핏보면 공평해보이지만, 아래의 경우를 확인해보면 비효율적인 알고리즘인걸 알 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>70</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>만약 A,B,C가 거의 동시에 도착해 A,B,C순으로 처리한다고 할 때, 평균 반환시간을 체크해보면</p>\n<p><strong>Average Turnaround Time : (60 + 70 + 80) /3  = 70</strong>  으로, 굉장히 비효율적입니다.</p>\n<p>라면 하나를 사려고 계산대에 줄을 섰는데, 앞에서 엄청 많은 물건을 계산하고있는 상황을 생각해보면 편할겁니다.</p>\n<p>이처럼 짧은 시간동안 자원을 사용하는 프로세스가 오랜 시간동안 할당을 기다려야 하는 현상을 <strong>Convoy Effect</strong>라고 합니다.</p>\n<h3 id=\"sjf-알고리즘--non-preemitive\" style=\"position:relative;\"><a href=\"#sjf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98--non-preemitive\" aria-label=\"sjf 알고리즘  non preemitive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF 알고리즘 / Non Preemitive</h3>\n<p>Shortest Job First 즉, 짧은 작업을 우선해서 처리하는 알고리즘입니다.</p>\n<p>비선점형으로 동작하는 경우부터 살펴보겠습니다.</p>\n<p>FCFS에서는 실행시간이 짧은 프로세스가 앞서 실행되는 긴 프로세스의 실행을 기다려하는 Convoy Effect가 문제였습니다.</p>\n<p>SJF에서는 레디큐에 있는 Job들 중, <strong>짧은것을 우선적으로 실행</strong>합니다.</p>\n<p>마트에서 줄이 짧은 사람을 먼저 계산하게 해줍니다!</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>B</th>\n<th>C</th>\n<th>A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>10</td>\n<td>10</td>\n<td>60</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>10</td>\n<td>20</td>\n<td>80</td>\n</tr>\n</tbody>\n</table>\n<p>앞선 FIFO의 예시입니다. A,B,C가 동시에 도착하면  B,C가 먼저 스케쥴되어 반환시간을 계산하면</p>\n<p><strong>Average Turnaround Time :(10+20+80) / 3  = 36.6</strong> , 반환시간이 절반정도로 줄어든걸 확인할 수 있습니다.</p>\n<p><strong>SJF 문제점</strong></p>\n<p>비선점형이라는 것을 고려하면 아래와 같이 동작합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093037-73ffbddf-8875-4583-81d7-03c9aaf5c377.png\" alt=\"2\"></p>\n<p>B,C는 time:10에 도착했으므로 이미 실행중인 A를 종료시키지 못하고, time:60까지 기다립니다. 이 경우 반환시간은</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>60</td>\n<td>60</td>\n<td>70</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (60+60+70)/3 = 63.3으로, 앞선 FSFS와 큰 차이가 없습니다.</strong></p>\n<h3 id=\"srtf또는-sctf-알고리즘\" style=\"position:relative;\"><a href=\"#srtf%EB%98%90%EB%8A%94-sctf-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"srtf또는 sctf 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRTF(또는 SCTF) 알고리즘</h3>\n<p>SRTF: Shortes Remaining Time First (= SCTF: Shortest Time to Completion First)는 <strong>최소 잔여시간이 적은 프로세스를 선점형으로 실행</strong>하는 알고리즘입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093039-804b66a5-2dee-48b4-985d-ad66c1171e54.png\" alt=\"3\"></p>\n<p>앞선 SJF와 비교해보면 B,C가 도착한 time: 10시점에 <strong>더 짧게 남은 잡을 계산해 CPU를 선점한다는걸 확인할 수 있습니다</strong>.</p>\n<p>이 경우 반환시간을 계산해보겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th>프로세스</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행시간</td>\n<td>60</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>도착시간</td>\n<td>0</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>반환시간</td>\n<td>80</td>\n<td>20</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Average TurnAround Time =  (80+20+30)/3 = 43.3으로, B,C가 늦게 도착한 경우에 평균 반환시간을 개선할 수 있었습니다.</strong></p>\n<p><strong>SRTF 문제점</strong></p>\n<p><strong>SRTF에도 공정성, 응답시간 측면에서 문제점이 있습니다.</strong></p>\n<p>만약 실행시간이 10인 프로세스가 레디 큐에 계속 들어온다면, 남은 실행시간이 20인 프로세스는 CPU를 할당받지 못하는 상태가 되고(Starvation), 응답시간이 계속 늘어납니다.</p>\n<p>또한 <strong>운영체제는 Ready Queue에 있는 프로세스의 실행시간을 알지 못합니다.</strong></p>\n<h3 id=\"round-robin-알고리즘\" style=\"position:relative;\"><a href=\"#round-robin-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"round robin 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Round Robin 알고리즘</h3>\n<p>Round Robin알고리즘은 일정 Time Quantum을 기점으로 Ready Queue에 있는 모든 프로세스들에게 공정하게 실행시간을 배분해주는 알고리즘을 말합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226093040-38af8a4a-e01d-4f0b-a85e-62aa5b91541e.png\" alt=\"4\"></p>\n<p><strong>문제점 해결</strong></p>\n<p>해당 방식으로 실행하면 SRTF에서 실행시간이 많이 남은 프로세스가 CPU를 계속 할당받지 못하는 공평성 문제가 해결되고, 응답시간이 대폭 개선됩니다.</p>\n<p><strong>특징</strong></p>\n<p>대화형 시스템에 적합합니다.</p>\n<p>새로 Ready상태가 되거나 실행시간을 마친 Job은  Ready Queue의 <strong>맨 뒤로</strong> 갑니다.</p>\n<ul>\n<li>A가 실행되고 나서 C가 Ready상태가 되었다면,  …. → A → C 순으로 실행됩니다.</li>\n<li>반대로 C가 Ready Queue에 도착하고 A의 실행이 끝난다면, …→ C → A 순으로 실행됩니다.</li>\n</ul>\n<p><strong>새로운 문제점</strong></p>\n<p>평균 반환시간 관점으로 보았을 때, 최악의 알고리즘입니다.</p>\n<p>또한 적절한 Time Quantum을 설정해야합니다. 잦은 Context Switch는 성능 저하를 불러옵니다.</p>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>반환시간, 응답시간, 공평성은 등가교환 관계입니다.</p>\n<p>SJF, SRTF는 반환시간이 개선되지만 응답시간, 공정성 측면에서는 비효율적이고</p>\n<p>RR의 경우 응답시간과 공평성은 해결했지만 반환시간이 비효율적입니다.</p>\n<p>뒤이어 배울 MLFQ등을 통해 각각의 장점을 절충하는 스케쥴러의 동작을 공부해보겠습니다.</p>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.5 Lecture 5. Process Scheduling]<a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(**https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <a href=\"https://www.youtube.com/watch?v=r1JVA7yOPAM&#x26;list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&#x26;index=9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"></a></strong>)**</p>","id":"90477195-e249-580a-9f20-cf0887f0663b","fields":{"slug":"기본-cpu-스케쥴링-fcfs-sjf-srtf-rr"},"frontmatter":{"date":"2023-02-14","title":"기본 CPU 스케쥴링 [ FCFS, SJF, SRTF, RR]","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},{"excerpt":"프로세스의 개념 프로세스는 프로그램이 실행중인 상태 라고 정의합니다. 프로그램 자체는 디스크에 적재되어있는 상태로, 아무런 동작을 하지 않습니다. 프로그램이 메모리에 적재되고, CPU를 점유해 사용하는 주체를 “프로세스”라고 합니다. 조금 더 구체적으로는 아래와 같이 정의할 수 있습니다. 커널에 등록되고 커널의 관리 하에 있는 작업 → 프로세스 관리 블록(PCB)을 할당받은 프로그램 각종 자원을 요청하고 할당받을 수 있는 개체 CPU…","html":"<h3 id=\"프로세스의-개념\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\"프로세스의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 개념</h3>\n<p>프로세스는 <strong>프로그램이 실행중인 상태 라고 정의합니다.</strong></p>\n<p>프로그램 자체는 디스크에 적재되어있는 상태로, 아무런 동작을 하지 않습니다. 프로그램이 메모리에 적재되고, CPU를 점유해 사용하는 주체를 “프로세스”라고 합니다.</p>\n<p>조금 더 구체적으로는 아래와 같이 정의할 수 있습니다.</p>\n<ul>\n<li>커널에 등록되고 커널의 관리 하에 있는 작업\n<ul>\n<li>→ <strong>프로세스 관리 블록(PCB)을 할당받은 프로그램</strong></li>\n</ul>\n</li>\n<li>각종 자원을 요청하고 할당받을 수 있는 개체</li>\n</ul>\n<h3 id=\"cpu-가상화와-프로세스--이건-cpu-가상화에-대한-설명\" style=\"position:relative;\"><a href=\"#cpu-%EA%B0%80%EC%83%81%ED%99%94%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4--%EC%9D%B4%EA%B1%B4-cpu-%EA%B0%80%EC%83%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85\" aria-label=\"cpu 가상화와 프로세스  이건 cpu 가상화에 대한 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 가상화와 프로세스 → 이건 CPU 가상화에 대한 설명..</h3>\n<p>이런 “프로세스”는 실제 맥이나 윈도우같은 운영체제를 사용하면서 확인할 수 있는데, 한눈에 봐도 우리는 수십개의 프로그램을 동시에 사용할 수 있다는것을 알 수 있습니다. 마치 <strong>프로그램 하나가 CPU하나를 점유하듯</strong>, 노래를 들으며 워드를 사용하고, 백신 프로그램을 돌리는 등, 여러가지 작업을 한번에 수행 할 수 있죠.</p>\n<p>이것은 모두 “<strong>CPU 가상화</strong>”에 기초합니다. 운영체제는 “<strong>시분할</strong>”을 통해 여러 프로세스가 하나의 CPU를 나눠 사용할 수 있도록 합니다.</p>\n<p>또한 운영체제는 **과거 정보( 자주 실행된 프로그램, 실행된 프로그램의 유형)**과 **목적(처리량, 응답시간)**을 바탕으로 어떤 프로세스가 언제 CPU를 사용할지에 대한 “<strong>스케쥴링 정책</strong>”을 가지고있습니다.</p>\n<p>위같은 정책이나 시분할 기법은 프로세스가 온전히 하나의 CPU를 사용하는것”처럼” 하게 해주며, 이를 가상화 라고 부릅니다.</p>\n<h3 id=\"컴퓨터-구조와-프로세스\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"컴퓨터 구조와 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴퓨터 구조와 프로세스</h3>\n<p>프로세스의 실행을 조금 더 가까이에서 살펴보겠습니다. 메모리와 CPU사이에 캐시, MMU, 레지스터 등 다양한 주변기기가 있지만, 설명에서는 생략합니다.</p>\n<p>앞서 프로세스의 “실행”은 시분할과 이를 제어하는 스케쥴링 기법을 통한 CPU 가상화를 통해 이뤄진다고 말씀드렸습니다. 우리가 program.c로 작성해 program.exe파일로  컴파일된 <strong>“파일” 이 어떻게 실행중인 “프로세스”로 변경</strong>되는지 이해하기 위해서는 아래 그림에 대한 설명이 필요합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226092562-a562242a-d948-46cd-8b5e-d68edcd3d0c0.png\" alt=\"1\"></p>\n<p>프로그래머가 작성한 소스코드는 파일로 저장되며, 언어에 따라 컴파일을 통해 실행 프로그램으로 변경됩니다.</p>\n<p>변경된 프로그램은 실행 시 메인 메모리에 적재되고, 프로그램 코드와 정적 데이터를 저장하며 <strong>실행중 사용할 수 있는 공간인 스택과 힙을 할당</strong>받아 명령어에 필요한 데이터를 사용하거나 명령어를 수행한 결과를 저장합니다.</p>\n<p>사실. 밑에서 공부할 프로세스의 상태에서는 CPU,Memory등을 할당받지 못한(Swap된) 상태도 있기때문에, 메모리에 적재된 프로그램만 프로세스라고 부르기에는 애매합니다. PCB도 조금 이따 볼거지만, “<strong>커널에 PCB가 저장된 프로그램</strong>”을 프로세스로 보시는게 더 정확합니다.</p>\n<p>여기서 중요한 개념 중 하나인 <strong>메모리 가상화</strong>가 등장합니다.</p>\n<p>메모리 가상화는 많은 역시 “<strong>많은프로세스가 자신의 독립된 주소 공간을 갖는것처럼 행동</strong>\"할 수 있도록 해주며, MMU가 실제 주소와 가상 주소를 저장한 테이블을 통해 변환해 각각의 프로세스가 주소공간을 서로 침범하지 않고 독립적으로 실행됩니다.</p>\n<p>(컴퓨터구조 여담)</p>\n<p>위 그림에서 왼쪽이 CPU와 고속처리장치(메모리컨트롤러, GPU, PCI 16x)들을 담당하는 노스브릿지(North Bridge), 오른쪽에서 메모리 아랫쪽이 저속처리장치(디스크, PCI 1x, USB, SATA 등)를 담당하는 사우스브릿지(South Bridge)인데, 주변장치와 데이터 버스를 통해 처리되던 노스브릿지 장치들이 CPU로 통합되면서 최신 CPU에는 노스브릿지 영역이 없는 형태의 CPU가 대부분이라고 합니다.</p>\n<h2 id=\"프로세스-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C\" aria-label=\"프로세스 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 상태</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226092567-88d743d6-7d8e-483b-b183-c352a67b440b.png\" alt=\"2\"></p>\n<p>프로세스는 “스케쥴링 정책”을 통해 CPU와 메모리를 할당받는지 여부에 따라 아래와 같은 상태를 갖습니다.</p>\n<ul>\n<li><strong>Created:</strong> 커널에 PCB가 할당되고, <strong>가용 메모리공간을 체크해 Ready상태 또는 Suspend-Ready상태로 전이</strong>합니다.</li>\n<li><strong>Ready</strong>: 프로세서(CPU) 할당을 대기하는 상태로, 즉시 실행 가능한 상태입니다.\n<ul>\n<li><strong>Schedule(또는 dispatch)</strong>: 스케쥴링 정책에 의해 Running상태로 전이합니다.</li>\n</ul>\n</li>\n<li><strong>Running</strong>:  프로세서를 포함해 필요한 자원을 모두 할당받아 동작하는 상태입니다.\n<ul>\n<li>timer run-out: Running상태의 프로세스가 스케쥴 계획에 있던 시간을 모두 버스트해 종료합니다.</li>\n<li><strong>Block/sleep:</strong> I/O자원할당을 위해 잠시 대기합니다.</li>\n</ul>\n</li>\n<li><strong>Asleep(Block)</strong>: I/O가 끝나기를 기다리는 상태입니다. 자원별로 Block-Queue를 가지며, 할당이 끝나기를 기다리는 프로세스가 큐에 있습니다.\n<ul>\n<li><strong>Wake up</strong>: 자원할당을 마치고 ready queue로 들어갑니다.</li>\n</ul>\n</li>\n<li><strong>Suspended State: 메모리를 할당받지 못하고, 디스크(Swap device)에 메모리 이미지를 저장한 상태</strong>\n<ul>\n<li>Swap in: 스왑 이미지를 메모리에 적재해 Ready 또는 Asleep 상태로 변경</li>\n<li>Swap out: 적재된 메모리  영역을 스왑 디바이스에 이미지로 저장</li>\n</ul>\n</li>\n<li><strong>Terminate:</strong> 프로세스 수행이 끝나 모든 자원 반납 후 PCB만 커널 내에 남아있는 상태입니다.\n<ul>\n<li>커널이 이후 비슷한 프로세스를 실행할 때, PCB정보를 참고한다고 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pcb를-통한-프로세스의-관리\" style=\"position:relative;\"><a href=\"#pcb%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B4%80%EB%A6%AC\" aria-label=\"pcb를 통한 프로세스의 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB를 통한 프로세스의 관리</h3>\n<p>PCB: Process Control Block - <strong>실행중인 프로그램(프로세스)들을 제어하는데 필요한 정보</strong>를 가지고있는 자료구조 입니다.</p>\n<p>시작/종료가 많은 프로세스의 특성 상 PCB 리스트 역시 삽입/삭제가 많은 데이터이므로,  <strong>커널 영역에서 LinkedList를 통해 관리됩니다.</strong></p>\n<ul>\n<li>PCB의 구성요소: 운영체제별로 다릅니다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>구성요소</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PID: Process Identification Number</td>\n<td>프로세스를 고유하게 식별하는 번호</td>\n</tr>\n<tr>\n<td>스케쥴링 정보</td>\n<td>우선순위 등 스케쥴링을 위해 필요한 정보</td>\n</tr>\n<tr>\n<td>메모리 관리 정보</td>\n<td>할당된 페이지, 세그먼트에 대한 정보</td>\n</tr>\n<tr>\n<td>입출력상태 정보</td>\n<td>할당받은 입출력 장치</td>\n</tr>\n<tr>\n<td>문맥 저장 영역</td>\n<td>CPU 레지스터 저장, 문맥 교환 시 load/store하는 부분</td>\n</tr>\n<tr>\n<td>계정정보</td>\n<td>프로세스의 소유자</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>멀티프로세스보다 멀티스레드가 빠른 “실질적인” 이유</p>\n</blockquote>\n<p>프로세스 A의 실행정보라고 불리는 <strong>스택과 힙</strong>에 대해 이야기해봅시다. <strong>컴파일타임에 메모리를 할당받는 스택</strong>의 경우, 일반적으로 1MB를 사용하고 최대 10MB정도인 반면, <strong>힙영역은 런타임에 할당되고 최대 256MB</strong>또는 설정에 따라 메모리의 최대크기에 따라 더 커질수도 있습니다.</p>\n<p>프로세스 A의 PCB에는 A가 실행될 때의 레지스터 정보들을 가지고있습니다. 또한, CPU와 근접해있는 L1, L2캐시에도 프로세스 A의 실행정보들이 <strong>캐싱</strong>되어있습니다. 만약 프로세스 A가 B로 Context Switch할때는 레지스터 정보를 교체하겠지만, <strong>이후에는 L1,L2뿐만아니라 다른 캐시, 심지에 페이지 교체까지 일어납니다.</strong></p>\n<p>스레드의 경우는 어떨까요~? 스레드는 프로세스 내에서 독립적인 스택포인터(스택)을 갖지만, <strong>실행정보에 대부분을 차지하는 힙,코드,데이터영역을 공유합니다</strong>. 스레드의 정보를 저장한 TCB의 정보를 레지스터에 옮기는 시간은 있겠지만, 캐시,페이지 미스가 많이 일어나지 않기때문에, 훨씬 더 빠릅니다.</p>\n<p>+) 멀티스레드는 공유자원인 힙, 데이터에 대해 동시성 문제가 발생하므로, 동기화 문제를 꼭 핸들링해주어야 합니다!</p>\n<h3 id=\"키워드--질문-목록\" style=\"position:relative;\"><a href=\"#%ED%82%A4%EC%9B%8C%EB%93%9C--%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"키워드  질문 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>키워드 &#x26; 질문 목록</h3>\n<p>PCB어떤 자료구조로 관리되며, 왜 해당 자료구조를 사용하는지 설명해주세요</p>\n<p>프로세스의 상태와 각 상태별로 사용하고있는 자원의 종류에 대해 설명해주세요</p>\n<p>멀티프로세스보다 멀티스레드가 빠른 이유를 설명해주세요</p>\n<p>문맥교환영역에 저장되는 CPU 레지스터 종류?</p>\n<p>PC (Program Counter) : 다음 인출(Fetch) 될 명령어의 주소를 가지고 있는 레지스터</p>\n<p>AC (Accumulator) : 연산 결과 데이터를 일시적으로 저장하는 레지스터</p>\n<p>IR (Instruction Register) : 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터</p>\n<p>SR (Status Register) : 현재 CPU 의 상태를 가지고 있는 레지스터</p>\n<p>MAR (Memory Address Register) : PC 에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터</p>\n<p>MBR (Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>[<strong>HPC Lab. KOREATECH, OS Lecture CH.3 Process](</strong><a href=\"https://www.youtube.com/watch?v=jZuTw2tRT7w\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=jZuTw2tRT7w</a> <strong>)</strong></p>\n<p><a href=\"%5Bhttps://pages.cs.wisc.edu/~remzi/OSTEP/%5D(https://pages.cs.wisc.edu/~remzi/OSTEP/)\">OSTEP: Operating Systems: Three Easy Pieces</a></p>\n<p>이글은 꼭 이해하면 좋을것같다. 까먹으면 다시보자! → <a href=\"https://quasarzone.com/bbs/qn_hardware/views/818208\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://quasarzone.com/bbs/qn_hardware/views/818208</a></p>","id":"96b52839-d38a-577a-a1f1-5a12ac062586","fields":{"slug":"프로세스의-개념과-상태-변화"},"frontmatter":{"date":"2023-02-06","title":"프로세스의 개념과 상태 변화","category":"tech","tags":["운영체제","운영체제 스터디"],"banner":null},"timeToRead":3},{"excerpt":"프로토콜 버퍼(Protocol Buffer)는 gRPC에서 데이터의 스키마를 정의하고 직렬화할때 사용하는 메커니즘입니다. google에서 개발했으며, *.proto형식의 메시지 뿐만 아니라, JSON등의 데이터를 직렬화할때도 사용되는 방식이고, gRPC에서 직렬화 방식으로 사용되고 있습니다. 프로토콜 버퍼가 gRPC에서 어떻게 동작하는지는 링크:이전 글을 참조해주세요 이 글에서는 Protocol Buffer3(Proto…","html":"<p>프로토콜 버퍼(Protocol Buffer)는 gRPC에서 데이터의 스키마를 정의하고 직렬화할때 사용하는 메커니즘입니다. google에서 개발했으며, *.proto형식의 메시지 뿐만 아니라, JSON등의 데이터를 직렬화할때도 사용되는 방식이고, gRPC에서 직렬화 방식으로 사용되고 있습니다.</p>\n<p>프로토콜 버퍼가 gRPC에서 어떻게 동작하는지는 링크:이전 글을 참조해주세요</p>\n<p>이 글에서는 Protocol Buffer3(Proto3)에서 스키마를 정의하는 방법들 중, 기본적인 내용에 대해 다룹니다.</p>\n<h2 id=\"메시지를-정의하는-방법\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"메시지를 정의하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지를 정의하는 방법</h2>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">syntax</span><span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchRequest</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">string</span> query<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token builtin\">int32</span> page_number<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token builtin\">int32</span> result_per_page<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/*\nC/C++ Style Comment\n*/</span>\n<span class=\"token comment\">//C/C++ Style Comment</span></code></pre></div>\n<p>위의 프로토콜 버퍼는 아래와 같은 특징을 가지고 있습니다.</p>\n<ul>\n<li><strong>확장자:</strong> .proto 입니다.</li>\n<li><strong>버전 명시:</strong> 주석, 빈 라인을 제외한 첫 번째 라인에  Proto3 임을 명시해주어야 합니다.  (아니면 기본값 proto2로 지정)</li>\n<li><strong>필드 정의 :</strong> string,int32/64와 같은 타입과 , query, page_number같은 이름의 쌍으로 필드를 정의합니다. (참고로, 필드명은 snake case, 메시지명은 cammel case를 권장하고있습니다)</li>\n<li><strong>주석</strong> : C/C++스타일 주석으로, “//” 와 “/**/” 를 사용할 수 잇습니다.</li>\n<li><strong>필드번호 정의:</strong> 필드번호는 메시지 내 유일한 숫자로 지정해줍니다.\n<ul>\n<li>필드번호를 통해 이진 포멧에서 필드를 식별할 수 있고, 메시지 유형이 사용된경우 변경하면 안됩니다.</li>\n<li>1-15 까지의 번호는 1바이트만 사용하지만, 16~2047은 2바이트, 번호가 커질수록 사용하는 바이트 수가 늘어납니다. 또한, 19000 ~19999까지는 예약된 필드번호로, 사용이 불가능합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"필드-규칙\" style=\"position:relative;\"><a href=\"#%ED%95%84%EB%93%9C-%EA%B7%9C%EC%B9%99\" aria-label=\"필드 규칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>필드 규칙</h3>\n<p>메시지의 필드는 아래 4개중 하나의 타입에 해당합니다.</p>\n<p>Proto3에서는 <strong>field presence</strong>라는 개념이 존재합니다. 자세한 내용은 링크(<a href=\"https://protobuf.dev/programming-guides/field_presence/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/programming-guides/field_presence/</a>)를 참고하시면 되고, 필드 규칙을 이해하기 위해서는 [ explicit, no ] present의 개념에 대해서만 이해하면 됩니다.</p>\n<p><strong>explicit present</strong>: 명시적으로 값이 존재하는지를 저장하는 값 체계</p>\n<p><strong>no present</strong>: 값이 존재하는지 아닌지를 노출하지 않고, 기본값을 통해 대치하는 방식</p>\n<p><a href=\"https://protobuf.dev/programming-guides/field_presence/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/programming-guides/field_presence/</a></p>\n<ul>\n<li>singular: proto3에서 규칙을 지정하지 않으면 기본값으로 사용됩니다. no-present방식의 값 체계를 따릅니다.</li>\n<li>optional: proto2에서 기본으로 사용되었으며, 직렬화 시 explicit present방식을 사용합니다.</li>\n<li>repeated : 반복되는 값에 대해 사용합니다. key-value로 매핑되지만, packed옵션을 통해 값만 반복하도록 설정할 수 있습니다.</li>\n<li>map: key-value형태의 값에 대해 사용합니다.</li>\n</ul>\n<h3 id=\"기본값\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%EA%B0%92\" aria-label=\"기본값 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본값</h3>\n<p><strong>메시지 파싱 시, 특정 필드가 지정되어있지 않으면 필드는 기본값으로 설정됩니다!</strong> 그러므로, <strong>메시지 필드가 직렬화 이후 파싱되었을 때, 필드의 값이 기본값인지 지정되지 않았던것인지 판단할 수 없습니다.  주의해야합니다.</strong></p>\n<p>각 타입별 기본값입니다.</p>\n<ul>\n<li>string- 빈 문자열</li>\n<li>bool - false</li>\n<li>숫자타입 - 0</li>\n<li>enum- 첫 번째로 정의된 열거형 값이고, 0 이어야 함.</li>\n<li>repeated - 빈 배열(언어에 따라 다릅니다)</li>\n</ul>\n<h2 id=\"proto3-필드-타입과-각-언어별-자료형-매핑\" style=\"position:relative;\"><a href=\"#proto3-%ED%95%84%EB%93%9C-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B0%81-%EC%96%B8%EC%96%B4%EB%B3%84-%EC%9E%90%EB%A3%8C%ED%98%95-%EB%A7%A4%ED%95%91\" aria-label=\"proto3 필드 타입과 각 언어별 자료형 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>proto3 필드 타입과 각 언어별 자료형 매핑</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088289-7eabb332-4681-44f1-9ffd-5a67e0906b0d.png\" alt=\"프로토콜버\"></p>\n<p>출처: <a href=\"https://protobuf.dev\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev</a></p>\n<h3 id=\"메시지-정의-유형\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%95%EC%9D%98-%EC%9C%A0%ED%98%95\" aria-label=\"메시지 정의 유형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 정의 유형</h3>\n<p>하나의 파일에서 여러개의 메시지를 정의할 수 있으며, 정의한 메시지를 다른 메시지에서 타입으로 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchResponse</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token positional-class-name class-name\">Result</span> results <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">Result</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">string</span> url <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">string</span> title <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token builtin\">string</span> snippets <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>메시지를 원하는만큼 중첩해 정의할 수 있으며, 메시지 내부에 정의된 메시지는 부모  메시지로부터 참조해야합니다</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SearchResponse</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">message</span> <span class=\"token class-name\">Result</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> url <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> title <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">repeated</span> <span class=\"token builtin\">string</span> snippets <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">repeated</span> <span class=\"token positional-class-name class-name\">Result</span> results <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">SomeOtherMessage</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token positional-class-name class-name\">SearchResponse<span class=\"token punctuation\">.</span>Result</span> result <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"여러가지-타입들\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%ED%83%80%EC%9E%85%EB%93%A4\" aria-label=\"여러가지 타입들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러가지 타입들</h2>\n<h3 id=\"map\" style=\"position:relative;\"><a href=\"#map\" aria-label=\"map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Map</h3>\n<p>Map을 통해 키와 값을 매핑시킬 수 있으며, 기본 형식은 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token map class-name\">map<span class=\"token punctuation\">&lt;</span>key_type<span class=\"token punctuation\">,</span> value_type<span class=\"token punctuation\">></span></span> map_field <span class=\"token operator\">=</span> N<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>키 타입으로는 Integer, String과 관련된 scalar type이 가능하며, byte, float타입은 불가능합니다.</li>\n<li>Map타입은 repeated를 적용할 수 없습니다.</li>\n</ul>\n<h3 id=\"oneof\" style=\"position:relative;\"><a href=\"#oneof\" aria-label=\"oneof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OneOf</h3>\n<p>OneOf타입은 상수형 값을 매핑시키는 enum과 다릅니다! 실제 자료형을 통해 선언된 여러 필드들 중, 하나의 값을 가질 수 있습니다. (map과 repeated는 사용할 수 없습니다)</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">SampleMessage</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">oneof</span> test_oneof<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token builtin\">string</span> name<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token positional-class-name class-name\">SubMessage</span> sub_message<span class=\"token operator\">=</span><span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>메모리를 공유하기때문에 OneOf필드를 세팅하면 기존에 가지고있던 값이 사라집니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\">SampleMessage <span class=\"token keyword\">message</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">set_name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">CHECK_EQ</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// sub_messgae필드를 없애고, name값을 할당합니다. </span>\n<span class=\"token comment\">// sub_message to a new instance of SubMessage with none of its fields set.</span>\n<span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">mutable_sub_message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">CHECK</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">message</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>언어별로 WhichOf, Case 등, 내부에 있는 값을 확인하는 로직을 통해 사용합니다.</p>\n<h3 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h3>\n<ul>\n<li>Map타입에서 float타입이 안되면, string으로 대체하는건가?</li>\n<li>reserved : 다시 쓸  수 있나?</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://protobuf.dev/programming-guides/proto3/#simple\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/programming-guides/proto3/#simple</a></p>\n<p><a href=\"https://protobuf.dev/reference/protobuf/proto3-spec/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/reference/protobuf/proto3-spec/</a></p>\n<p><a href=\"https://medium.com/naver-cloud-platform/nbp-%EA%B8%B0%EC%88%A0-%EA%B2%BD%ED%97%98-%EC%8B%9C%EB%8C%80%EC%9D%98-%ED%9D%90%EB%A6%84-grpc-%EA%B9%8A%EA%B2%8C-%ED%8C%8C%EA%B3%A0%EB%93%A4%EA%B8%B0-1-39e97cb3460\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460</a></p>\n<p><a href=\"https://protobuf.dev/programming-guides/encoding\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/programming-guides/encoding</a></p>","id":"2906e18a-afe6-5891-a776-cbea6f00b4bb","fields":{"slug":"protocol-buffer-3-spec정리"},"frontmatter":{"date":"2023-02-01","title":"Protocol Buffer 3 Spec정리","category":"tech","tags":["protobuf3","gRPC","gRPC 스터디"],"banner":null},"timeToRead":2},{"excerpt":"…","html":"<h2 id=\"일대일-매핑\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EC%9D%BC-%EB%A7%A4%ED%95%91\" aria-label=\"일대일 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대일 매핑</h2>\n<p>일대일 매핑의 경우, 반대방향도 일대일이므로 일대다/다대일에서 연관관계의 주인이 항상 “다”쪽이었던것과 달리 연관관계의 주인이 어느 쪽이든 가능하다.</p>\n<p>하지만 주/대상 관계에 따라 장단점이 존재한다.</p>\n<p>주 테이블이란? 아래 그림에서 멤버처럼 라커를 참조하거나 사용하는 테이블이다.</p>\n<p>대상 테이블은 반대로, 멤버에 의해 불려지거나 참조를 당하는 테이블을 말한다.</p>\n<ul>\n<li>주 테이블에 외래키를 두는 경우: 외래키를 참조와 같이 사용할 수 있어 멤버 <strong>객체만 확인해도 라커를 확인할 수 있는 간편함이 있음. → select with join</strong></li>\n<li>대상 테이블에 외래키를 두는 경우: <strong>멤버:라커가 일대다 관계로 변화했을 때</strong>, 앞선 방법과 달리 <strong>외래키의 위치를 수정하지 않아도 되는 확장성 면에서 장점이 있음 → select + select</strong></li>\n</ul>\n<h2 id=\"일대일-매핑-주-테이블에-외래키를-두는-경우\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EC%9D%BC-%EB%A7%A4%ED%95%91-%EC%A3%BC-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EC%99%B8%EB%9E%98%ED%82%A4%EB%A5%BC-%EB%91%90%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"일대일 매핑 주 테이블에 외래키를 두는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대일 매핑: 주 테이블에 외래키를 두는 경우</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089963-dabd6db8-8bde-4f63-8441-821a583821f3.png\" alt=\"1\"></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"LOCKER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Locker</span> locker\n\t<span class=\"token comment\">//,,,편의메서드 작성</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Locker</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToOne</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"locker\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Member</span> member\n\t<span class=\"token comment\">//...편의메서드 작성</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>단방향매핑과 양방향 매핑에 큰 차이가 없어 같이 설명한다. 양방향에서는 앞 챕터에서 살펴본 편의메서드만 주의해서 작성해주면 된다.</p>\n</blockquote>\n<p>mappedBy를 통해 연관관계의 주인을 명시하고(Member), Member를 통해 연관관계를 관리하고, 참조합니다.</p>\n<h3 id=\"대상-테이블에-외래키를-두는-경우\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%83%81-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EC%99%B8%EB%9E%98%ED%82%A4%EB%A5%BC-%EB%91%90%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"대상 테이블에 외래키를 두는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대상 테이블에 외래키를 두는 경우</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToOne</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"member_id\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Locker</span> locker\n\n\t<span class=\"token comment\">//,,,편의메서드 작성</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Locker</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToOne</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Member</span> member\n\t<span class=\"token comment\">//...편의메서드 작성</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089965-93f9ed04-3e4f-49ce-998d-894890f58921.png\" alt=\"2\"></p>\n<p>대상 엔티티인 Locker를 연관관계의 주인으로 만들어 Locker 테이블이 외래키를 관리하도록 하였다.</p>\n<blockquote>\n<p>OneToOne 양방향 관계에서는 연관관계의 주인이 아닌쪽에서 FetchType=Lazy로 설정할 수 없다.</p>\n</blockquote>\n<p><a href=\"https://loosie.tistory.com/788#@OneToOne_%EC%96%91%EB%B0%A9%ED%96%A5_%EB%A7%A4%ED%95%91_%EC%A4%91_LAZY%EA%B0%80_%EB%A8%B9%ED%9E%88%EC%A7%80_%EC%95%8A%EB%8A%94_%EA%B2%BD%EC%9A%B0_\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://loosie.tistory.com/788#@OneToOne_양방향_매핑_중_LAZY가_먹히지_않는_경우_</a></p>\n<h3 id=\"다대다-관계\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4-%EA%B4%80%EA%B3%84\" aria-label=\"다대다 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대다 관계</h3>\n<p>다대다 관계는, 회원이 상품을 주문하는 시나리오에서 회원과 상품에 해당합니다. 회원은 여러 종류의 상품을 구입하지만 상품 입장에서도 여러명의 멤버가 구매하므로, 구매자 목록에는 여러 멤버가 있습니다.</p>\n<p>하지만 테이블에는 여러개의 값이 들어할 수 없습니다.(데이터베이스 1정규화 원자성 보장)</p>\n<p>그러므로 공통의 연결테이블을 통해 다대다 테이블의 관계를 표현할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089962-98701d15-de8d-4c88-a57c-2f5849b604eb.png\" alt=\"3\"></p>\n<p>다대다 관계에서 엔티티를 구성할때는, 각각의 엔티티에 @ManyToMany를 설정하면 <strong>자동으로 위와 같이 연결 테이블을 설정해줍니다.</strong></p>\n<p>아래는 단방향 ManyToMany 매핑 예시입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@JoinTable</span><span class=\"token punctuation\">(</span>\n\t\tjoinColumns <span class=\"token operator\">=</span> <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t\tinverseJoinColumns <span class=\"token operator\">=</span> <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token annotation punctuation\">@ManyToMany</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Product</span><span class=\"token punctuation\">></span></span> products<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Product</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"jointable설정\" style=\"position:relative;\"><a href=\"#jointable%EC%84%A4%EC%A0%95\" aria-label=\"jointable설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JoinTable설정</h3>\n<p>위같이 단방향에서도 ManyToMany매핑을 하면 자동적으로 연결테이블이 생성됩니다. JoinTable 애너테이션에서는 연결테이블이 어느 컬럼에 매핑할것인지에 대한 설정을 합니다.</p>\n<ul>\n<li>JoinTable.joinColumns: 현재 엔티티인 멤버와 매핑할 컬럼 지정</li>\n<li>JoinTable.inverseJoinColumns: 반대측 엔티티인 상품과 매핑할 컬럼 지정</li>\n<li>JoinTable.name: 연결테이블의 이름</li>\n</ul>\n<h3 id=\"연결엔티티-사용\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%82%AC%EC%9A%A9\" aria-label=\"연결엔티티 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결엔티티 사용</h3>\n<p><strong>멤버와 상품 사이에 주문일자 또는 주문수량을 적고싶다면 어디에 저장할까요?</strong> 멤버, 상품 모두 아닌 해당 엔티티들이 연관관계를 맺는 <strong>연결 테이블이</strong> 가장 적절할 것입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089959-fb12f10e-ae72-40ee-ac04-47ac0526469e.png\" alt=\"4\"></p>\n<p>앞서 작성한 <strong>연결엔티티를 생략해 단방향 +  외래키만 저장</strong>하는 엔티티와 달리, 이번에는 <strong>연결엔티티를 사용</strong>해서 다대다관계를 정의하고, <strong>연결 엔티티에 연결정보(주문일자, 주문수량)까지 저장하는 양방향 관계 엔티티</strong>를 작성해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy <span class=\"token operator\">=</span> <span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">></span></span> memberProduct<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Product</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">></span></span> memberProduct<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>회원과 상품 엔티티를 각각 생성했고, mappedBy를 통해 MemberProduct를 연관관계의 주인으로 설정해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@IdClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberProductId</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Member</span> product<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> orderAmount<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> orderDate<span class=\"token punctuation\">;</span>\n\n\t\n<span class=\"token punctuation\">}</span>\n\t\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@IdClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberProductId</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberProductId</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> member<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> product<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>MemberProduct에서는 단순히 @ManyToMany를 통해 저장할 수 없던 주문수량, 주문일자를 저장할 수 있게됩니다. 테이블 구조는 앞선 구조와 동일합니다. (엔티티 구조만 변경)</p>\n<p>연결테이블 생성 시, 하나의 <strong>엔티티에서 두 개의 키를 가지는  “복합키”</strong> 개념이 새로 등장합니다. 이 개념은 뒤따라 소개할 방법에 비해 식별자 관리방법이 복잡하고 생성규칙이 많습니다.</p>\n<p>( Serializable 구현, 복합키 클래스는 별도의 클래스로 생성, equals, hashCode 오버라이드, 기본 생성자 필요 등등)</p>\n<p>또한 사용하기 용이하지 않습니다. 아래는 복합키를 통한 연관엔티티 <strong>생성</strong>입니다.</p>\n<p>복합키 아이디클래스 생성 → 연관엔티티 생성 → 연관관계 설정 → 영속</p>\n<p><strong>조회 역시 복합키 아이디 클래스를 통해 조회해야합니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberProductId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇기에 실제로는 새로운 기본키를 생성해 연관엔티티를 관리합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089960-e887cded-3577-485a-b2f4-29aa04a214c9.png\" alt=\"5\"></p>\n<p>위의 테이블 구조와 달리, Member, Product_ID에서 기본키 제약조건이 빠지고, 테이블명이 새로운 의미를 갖는 “Order”라는 적절한 이름으로 변경되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Order</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Product</span> product<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> orderAmount<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> orderDate<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy <span class=\"token operator\">=</span> <span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">></span></span> memberProduct<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Product</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"PRODUCT_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">MemberProduct</span><span class=\"token punctuation\">></span></span> memberProduct<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//member, product엔티티에 @OneToMany(mappedBy=\"___\")가 붙음</span>\n</code></pre></div>\n<h3 id=\"추가질문\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8\" aria-label=\"추가질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가질문</h3>\n<ul>\n<li>\n<p>다대일 관계에서도 연관테이블을 만들어서 Order처럼 관리해도 괜찮은가?</p>\n</li>\n<li>\n<p>private int orderAmount 책에 int로 적혀있는데, Integer가 적절하지 않은가?</p>\n</li>\n<li>\n<p>232쪽, orders = new ArrayList로 초기화해주는데, 안해주는것과 무슨 차이인가?</p>\n</li>\n<li>\n<p>주테이블 외래키해서 select+join이 성능이 좋나, 대상테이블 외래키해서 select + select가 성능이 좋나?</p>\n</li>\n<li>\n<p>복합키 다대다 테이블에서, 한 회원이 같은 상품 여러번 구매하면, PK의 Unique 제약조건 위반인가? [실험 필요]</p>\n</li>\n<li>\n<p>Nullable하지 않은값은 int(primitive type)가 좋다.</p>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>책 -  김영한 저 Java ORM 표준 JPA 프로그래밍 (에이콘 출판, 2015)</p>","id":"5773c085-20fd-5ad3-b0ef-c4fc83c64222","fields":{"slug":"jpa-일대일-다대다-매핑"},"frontmatter":{"date":"2023-01-30","title":"JPA 일대일, 다대다 매핑","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":4},{"excerpt":"gRPC 개요 gRPC 소개, Pros & Cons MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다. [+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다. [+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다. Binary framing layer…","html":"<h1 id=\"grpc-개요\" style=\"position:relative;\"><a href=\"#grpc-%EA%B0%9C%EC%9A%94\" aria-label=\"grpc 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 개요</h1>\n<h2 id=\"grpc-소개-pros--cons\" style=\"position:relative;\"><a href=\"#grpc-%EC%86%8C%EA%B0%9C-pros--cons\" aria-label=\"grpc 소개 pros  cons permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 소개, Pros &#x26; Cons</h2>\n<p>MSA와 같은 분산 서비스 시스템에서 느슨한 결합과 효율적인통신을 위해 고안된 방법입니다.</p>\n<ul>\n<li>[+]gRPC는 Protocol Buffer 기반 바이너리 프로토콜을 사용해 기존 REST등에서 사용된 JSON,XML포맷의 text기반 통신 비효율을 해결합니다.</li>\n<li>[+] 아래의 HTTP/2 특징 위에서 구현되어 통신속도가 빠릅니다.\n<ul>\n<li><strong>Binary framing layer</strong>: 데이터를 <strong>바이너리로 이뤄진 프레임으로 전달, 송/수신 레이어에서 다시 재조립</strong>하는 기능을 제공하는 HTTP2에서 도입된 계층</li>\n<li><strong>Multiflexing</strong>지원: Binary framing을 통해 가능해짐. 여러 스트림에서 양방향으로 frame을 통신. <strong>비동기, 양방향 데이터 통신</strong></li>\n<li>이외에도 서버 푸시, 스트림 우선순위 등의 특징과 함께 성능이 대폭 개선됨.</li>\n</ul>\n</li>\n<li>[-] 데이터 스키마 수정 시 서버 및 클라이언트 코드를 모두 변경해야합니다.</li>\n<li>[-] human readable하지 않습니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021105-c50f8ef0-6537-4060-98dc-f42dd517319c.png\" alt=\"1\">\n[그림] - Soap, REST, gRPC의 기본 데이터 전송 포멧의 장단점 비교</p>\n<h2 id=\"간단하게-요약해보는-grpc-매커니즘\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9A%94%EC%95%BD%ED%95%B4%EB%B3%B4%EB%8A%94-grpc-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98\" aria-label=\"간단하게 요약해보는 grpc 매커니즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 요약해보는 gRPC 매커니즘</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021110-d92e6249-993d-4055-a541-de3e9bdf957d.png\" alt=\"2\"></p>\n<ul>\n<li>서버는 클라이언트 호출을 핸들링하고, 클라이언트는 서버와 같은 메서드를 실행하는 Stub을 작성한다.</li>\n<li>gRPC는 서로 다른 <strong>다양한 언어</strong>로 작성된 서버/클라이언트 사이에서 통신할 수 있다.</li>\n<li>gRPC는 <strong>서버의 메서드를 로컬 객체인것처럼 호출한다.</strong></li>\n</ul>\n<h2 id=\"protocol-buffer를-통해-동작\" style=\"position:relative;\"><a href=\"#protocol-buffer%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8F%99%EC%9E%91\" aria-label=\"protocol buffer를 통해 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protocol Buffer를 통해 동작</h2>\n<p>Protocol Buffer란, gRPC에서 구조화된 데이터를 직렬화하기 위한 오픈소스 메커니즘입니다. 언어와 플랫폼에 중립적으로 동작합니다. (영향을 받지 않습니다)</p>\n<p>자세한 스펙은 <a href=\"https://protobuf.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://protobuf.dev/</a> 를 참고해주세요!</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int32</span> id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bool</span> has_ponycopter <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>gRPC는 서버와 클라이언간 이진 바이트 통신을 하기 위해 Protocol Buffer를 기본 전략으로 사용합니다.</p>\n<p>*.proto파일에 데이터 구조를 정의합니다. 직렬화하고싶은 데이터를 위와 같이 key-value필드로 매핑해 *.proto 파일로 작성합니다.</p>\n<h2 id=\"컴파일-및-메시지-인코딩\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%9D%B8%EC%BD%94%EB%94%A9\" aria-label=\"컴파일 및 메시지 인코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일 및 메시지 인코딩</h2>\n<p><strong>protoc</strong>은 프로토콜 버퍼 컴파일러입니다.</p>\n<p>이는 *.proto 파일에서 정의한 내용으로 <strong>특정 언어가 데이터에 접근할 수 있는 클래스파일을 생성</strong>합니다.</p>\n<p>name(), set_name()과 같은 메서드를 통해 <strong>raw bytes에서 메시지로 직렬화하거나 그 반대로 파싱</strong>할 수 있습니다.</p>\n<h2 id=\"동작\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91\" aria-label=\"동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작</h2>\n<ul>\n<li>서버 측에서 서버는 서비스에서 선언한 메서드를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리합니다. gRPC 인프라는 들어오는 요청을 디코딩하고 서비스 메서드를 실행하며 서비스 응답을 인코딩합니다.</li>\n<li>클라이언트에는 메시지를 서버와 동일한 방식으로 바라보는 <strong>stub</strong>이라는 객체를 통해 메시지와 파라미터를 인코딩해 rpc를 수행하고, 서버가 처리한 결과를 디코딩해 처리합니다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021107-2b48721b-bd09-421a-bd36-72ea21d11cc0.png\" alt=\"3\"></p>\n<blockquote>\n<p>출처 Geeks for geeks</p>\n</blockquote>\n<h2 id=\"grpc-요청-타입\" style=\"position:relative;\"><a href=\"#grpc-%EC%9A%94%EC%B2%AD-%ED%83%80%EC%9E%85\" aria-label=\"grpc 요청 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gRPC 요청 타입</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/215021109-7b7dacd0-f65d-45cc-b5b0-af7188288e7e.png\" alt=\"4\"></p>\n<p>stream을 통해 대량 데이터가 전달될 수도 있습니다. 그래도 gRPC의 프로그래밍 API에서는 대부분 비동기 처리를 지원하므로, stream data 및 단일 요청에 대해서도 Blocking없이 비동기적으로 처리 가능합니다.</p>\n<p><strong>Unary RPC</strong></p>\n<p>클라이언트에서 단일 요청을 보내고, 서버가 단일 응답을 보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Server Streaming RPC</strong></p>\n<p>클라이언트가 단일 요청을 보내고, 서버가 스트림을 통해 여러개의 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfReplies</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Clinet Streaming RPC</strong></p>\n<p>클라이언트가 스트림을 통해 여러게의 메시지를 보내고, 서버가 단일 메시지로 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">LotsOfGreetings</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Bidrectional Streaming RPC</strong></p>\n<p>클라이언트와 서버가 독립적인 스트림을 주고받으며</p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">rpc</span> <span class=\"token function\">BidiHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloRequest</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">stream</span> <span class=\"token class-name\">HelloResponse</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"질문\" style=\"position:relative;\"><a href=\"#%EC%A7%88%EB%AC%B8\" aria-label=\"질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>질문</h2>\n<ul>\n<li>server와 client의 stub간 동기화가 필요하지 않나?\n<ul>\n<li>→ 그렇다. protocol buffer를 사용하는 경우, 스키마를 공유하기 위해 스키마 정보를 가진 proto파일을 동기화해 컴파일하거나, 컴파일된 protob파일을 동기화해서 사용해야 한다.</li>\n</ul>\n</li>\n<li>stub을 웹 브라우저에 올릴 수 없는 이유?\n<ul>\n<li>→ 기술적으로는 가능하다. but 엄격한 타입 정의를 통해 통신이 이뤄지는데,만약 스키마 변경 시 end-user에게는 전달되지 않아 장애가 발생할 수 있음.</li>\n</ul>\n</li>\n<li>기존 RPC와는 어떤 차이가 있나?\n<ul>\n<li>gRPC의 경우 HTTP2을 통해 통신한다고 가정하고 구현했으므로, protocol buffer를 통해 binary data로 컴파일하고, binary frame으로 통신해 오버헤드가 적다. (기존 RPC에서는 주로 XML같은 text 기반으로 통신했으므로, 비효율적이다)</li>\n</ul>\n</li>\n<li>text기반 통신이 binary기반 통신에 비해 비효율적인 이유는 무엇인가?\n<ul>\n<li>문자를 제외한 number, boolean을 표현할 때, 사용하는 데이터 공간이 더 크고, 이는 통신 속도에도 영향을 미친다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"keyword\" style=\"position:relative;\"><a href=\"#keyword\" aria-label=\"keyword permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>keyword</h2>\n<p>gRPC, Protocol Buffer, Multiflex, Data access object, Binary framing, Async</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://grpc.io/docs/what-is-grpc/introduction/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://grpc.io/docs/what-is-grpc/introduction/</a></p>\n<p><a href=\"https://web.dev/performance-http2/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://web.dev/performance-http2/</a> - (Refer:HTTP2 spec, binary framing, multiflexing)</p>\n<p><a href=\"https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ko-kr/aspnet/core/grpc/comparison?view=aspnetcore-7.0</a> (refer: pros&#x26;cons of gRPC)</p>\n<p><a href=\"https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/</a></p>\n<p><a href=\"https://codingffler.tistory.com/28\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://codingffler.tistory.com/28</a></p>","id":"b1635c4c-bdab-51e6-94d5-c0de80c48403","fields":{"slug":"g-rpc의-동작원리와-기본-개념"},"frontmatter":{"date":"2023-01-23","title":"gRPC의 동작원리와 기본 개념","category":"tech","tags":["gRPC","gRPC 스터디"],"banner":null},"timeToRead":2},{"excerpt":"이글에서는 다대일, 일대다 매핑과 연관관계의 주인에 대해 알아보겠습니다. 일대다, 다대일 관계 JPA의 일대다, 다대일에서는 항상 연관관계의 주인이 “다” 쪽이고, 외래키 역시 “다”쪽에서 관리합니다. 예를들어 Member와 Team이 있다면, 항상 Member가 Team을 참조할 수 있는 외래키를 가지고있는 것이죠. RDBMS…","html":"<p>이글에서는 <strong>다대일, 일대다 매핑</strong>과 <strong>연관관계의 주인</strong>에 대해 알아보겠습니다.</p>\n<h3 id=\"일대다-다대일-관계\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A4%EB%8C%80%EC%9D%BC-%EA%B4%80%EA%B3%84\" aria-label=\"일대다 다대일 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다, 다대일 관계</h3>\n<p>JPA의 일대다, 다대일에서는 항상 연관관계의 주인이 “다” 쪽이고, 외래키 역시 “다”쪽에서 관리합니다. 예를들어 Member와 Team이 있다면, 항상 Member가 Team을 참조할 수 있는 외래키를 가지고있는 것이죠.</p>\n<p>RDBMS의 레코드는 컬럼에 하나의 값만 들어가는 <a href=\"%5Bhttps://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity)%5D(https://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95#%EC%9B%90%EC%9E%90%EC%84%B1(Atomicity))\">원자성</a>을 가지고있으므로, 일대다 관계에서 “일” 쪽이 “다”의 외래키를 들고있을 수 없기 때문이죠.</p>\n<p>하지만 객체는 다릅니다. 하나의 객체가 List를 가지고있을 수도 있기때문에, “일”쪽에서 연관관계의 주인이 되고싶어할 수 도 있습니다. 이런 경우, JoinTable을 통해 제 3의 테이블이 Member와 Team의 연관관계를 관리하게되고, Team객체에서도 외래키를 수정할 수 있게 되죠. 하지만, 이는 잘 사용하지 않습니다.</p>\n<h2 id=\"연관관계의-주인\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8\" aria-label=\"연관관계의 주인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인</h2>\n<p>연관관계의 주인이란, 연관관계에서 외래키의 등록/수정/삭제 권한을 갖는 엔티티를 의미합니다.</p>\n<p>외래키를 통한 양방향 관계인 데이터베이스 테이블과 달리, <strong>양방향 매핑 관계</strong>에서 객체는 두 개의 단방향 참조로 이루어져있으므로 <strong>외래 키를 관리할 주체를 mappedby를 통해 설정</strong>해야 합니다. (연관관계의 주인이 아닌 쪽에 mappedBy를 설정한다)</p>\n<h2 id=\"다대일-단방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089333-f4316b73-a8d9-4317-b6a1-0378f10bc01e.png\" alt=\"2\"></p>\n<p><strong>다대일 단방향관계에서는 항상 연관관계의 주인은 “다” 쪽</strong>입니다. 아래 예시에서도 멤버와 팀의 경우, 멤버에서 외래키를 들고있으며, 테이블에서도 외래키를 가지고있는것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team객체에서는 Member로의 참조가 없습니다.하지만 Member는 Team의 id 컬럼을 TEAM_ID로 매핑해 사용합니다.</p>\n<p>또한, ManyToOne같은 다대일, 일대다 관계에서는 “다”측이 자동으로 연관관계의 주인이 되어 외래키를 관리합니다.</p>\n<h2 id=\"일대다-단방향\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5\" aria-label=\"일대다 단방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일대다 단방향</h2>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226089331-adbb4ebb-c020-42ca-9fd3-2daa425141af.png\" alt=\"1\"></p>\n<p>일대다 단방향 매핑은 많이 사용되지 않는 매핑입니다. Team, Member관계에서 Team이 연관관계를 가지고있기 위해서는 JoinTable이라는 제 3의 테이블이 등장합니다. 이를 통해 Team에서 JoinTable에 있는 외래키를 관리해, Team이 외래키를 관리하는것 “처럼” 보이게 해주죠.</p>\n<p>보통은 일대다 단방향 관계에서도 JoinColumn을 통해 “다”쪽에서 외래키를 관리합니다.</p>\n<p>일대다 단방향 관계에서 JoinColumn, JoinTable이 어떻게 생성되는지 실험해봤으니, 궁금하다면 <a href=\"%5Bhttps://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md%5D(https://github.com/lee95292/jpa-tests/blob/main/documents/AsscociateTest.md)\">실험 리포지토리</a>에서 확인해보시길 바랍니다.</p>\n<h2 id=\"다대일-일대다-양방향\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EC%96%91%EB%B0%A9%ED%96%A5\" aria-label=\"다대일 일대다 양방향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다대일, 일대다 양방향</h2>\n<p>앞선 단방향 관계에서 점선 하나가 추가되었습니다. (연관관계의 주인이 아닌 방향 참조) 다대일 양방향 연관관계는 신경쓸 것이 많습니다. 두 객체가 서로에 대한 참조를 가지고있기에**, 데이터의 불일치가 발생**할 수 있습니다.</p>\n<p>먼저 코드를 살펴보고, 고려해야할 사항을 뒤따라 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>team <span class=\"token operator\">=</span> team<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//중복, 무한루프에 빠지지 않도록 체크</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span>team<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">contain</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\t\t\tteam<span class=\"token punctuation\">.</span>members<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>mappedBy<span class=\"token operator\">=</span><span class=\"token string\">\"team\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addMember</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tmembers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞선 다대일 단방향 관계와 달라진 점들이 있습니다. 양방향 관계에서 특히 주의해야할 부분입니다.</p>\n<h3 id=\"편의-메서드-작성-중복-불일치-및-무한루프--방지\" style=\"position:relative;\"><a href=\"#%ED%8E%B8%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%A4%91%EB%B3%B5-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%B0%8F-%EB%AC%B4%ED%95%9C%EB%A3%A8%ED%94%84--%EB%B0%A9%EC%A7%80\" aria-label=\"편의 메서드 작성 중복 불일치 및 무한루프  방지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>편의 메서드 작성 (중복, 불일치 및 무한루프  방지)</h3>\n<p>위에서 연관관계를 설정할 때, 기본 setter를 사용하는것이 아닌, 편의 메서드를 작성한 부분을 확인할 수 있습니다. (addMember, setTeam에 해당)</p>\n<p>앞서 말했듯 객체의 양방향은 두 개의 단방향이므로, 팀이 멤버를 추가했어도 멤버는 팀을 설정하지 않아 데이터 불일치가 발생하므로, 팀 → 멤버 추가, 멤버 → 팀 추가에 대한 코드를 함께 작성하고, 이를 팀,멤버 엔티티 모두에 작성하는것이 좋습니다. 이를 통해서 데이터의 불일치를 방지할 수 있습니다.</p>\n<ul>\n<li>데이터 삽입 시에는 중복삽입이 발생할 수 있습니다.</li>\n<li>toString문에서는 무한루프가 발생합니다. 이를 순환참조라고 합니다.\n<ul>\n<li>member. toStirng → member.Team.toString→ member.Team.members.toString() ….</li>\n<li>이를 방지하기 위해, DTO를 사용하거나, Mapper, Json관련 애너테이션을 사용합니다.</li>\n<li><a href=\"%5Bhttps://dev-coco.tistory.com/133%5D(https://dev-coco.tistory.com/133)\">순환참조 문제 해결 방법들</a>을 참고해주세요. 저는 mapper 라이브러리를 사용해 DTO에서 데이터를 관리하는 방법을 사용합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"연관관계의-주인-설정\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B8-%EC%84%A4%EC%A0%95\" aria-label=\"연관관계의 주인 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계의 주인 설정</h3>\n<p><strong>앞선 단방향 관계에서는 연관관계를 매핑하는 필드가 멤버에 존재했으므로 외래키의 관리하는 쪽(=연관관계의 주인)은 멤버였습니다.</strong></p>\n<p>하지만 양방향 연관관계는 멤버, 팀 모두가 참조를 가지고있으므로, 연관관계의 주인을 <strong>직접 설정</strong>해야합니다.</p>\n<p><strong>mappedBy속성은 연관관계의 주인을 어디로할지(외래키를 어디서 수정할지)에 대해서 명시합니다. (@OneToMany(mappedBy=\"team\")에 해당)</strong></p>\n<p>참고로, ManyToOne은 연관관계의 주인인 Many쪽에서 외래키 필드를 관리하므로,  mappedBy속성이 없습니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul>\n<li>mappedBy속성은 어느 경우에 어디에 사용하는가?</li>\n<li>편의메서드를 작성하는 이유는?</li>\n<li><a href=\"%5Bhttps://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s%5D(https://www.youtube.com/watch?v=brE0tYOV9jQ&#x26;t=135s)\">백기선님의 “이것도 모르면 JPA쓰지마라(다시 공부하거나) ”</a></li>\n</ul>\n<h3 id=\"추가질문\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8\" aria-label=\"추가질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가질문</h3>\n<ul>\n<li>OneToMany 단방향 관계에서 외래키 관리는 어떻게 동작하는가?</li>\n</ul>\n<h3 id=\"복습-및-추가질문-정답\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5-%EB%B0%8F-%EC%B6%94%EA%B0%80%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%8B%B5\" aria-label=\"복습 및 추가질문 정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습 및 추가질문 정답</h3>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>책 -  김영한 저 Java ORM 표준 JPA 프로그래밍 (에이콘 출판, 2015)</p>","id":"b08e891d-8149-5376-a6a4-18f0bce3c1d1","fields":{"slug":"jpa-다대일-일대다-매핑"},"frontmatter":{"date":"2023-01-18","title":"JPA 다대일, 일대다 매핑","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":3},{"excerpt":"테이블과 객체 사이에는 많은 패러다임 불일치가 있다고 앞선 챕터에서 설명했습니다. 그 중 가장 간극이 크다고 여겨지는 불일치중 하나는 연관관계의 참조에 대한 불일치 문제입니다. JPA가 이런 연관관계 참조 불일치 문제를 어떤 방식으로 해결하는지 살펴보겠습니다. 이번 챕터에서는 객체 연관관계 매핑의 기초적이고 개념적인 부분을 체크합니다. 실제 프로덕트에 개발을 고려하고있다면, [다음 글 링크] 를 확인하세요! JPA…","html":"<p>테이블과 객체 사이에는 많은 패러다임 불일치가 있다고 앞선 챕터에서 설명했습니다. 그 중 가장 간극이 크다고 여겨지는 불일치중 하나는 <strong>연관관계의 참조</strong>에 대한 불일치 문제입니다.</p>\n<p>JPA가 이런 연관관계 참조 불일치 문제를 어떤 방식으로 해결하는지 살펴보겠습니다.</p>\n<p>이번 챕터에서는 객체 연관관계 매핑의 기초적이고 개념적인 부분을 체크합니다. 실제 프로덕트에 개발을 고려하고있다면, [다음 글 링크] 를 확인하세요!</p>\n<p><strong>JPA의</strong> <strong>연관관계 매핑을 공부하기 전, 알아야할 내용!</strong></p>\n<ul>\n<li>방향성: 양방향, 단방향이 있습니다. [팀 → 멤버] 참조 [멤버 → 팀]으로참조하는 하나의 방향만 있는 경우 단방향, 두 방향 모두 참조가 가능하다면 양방향이라고 합니다. <strong>단방향 관계는 객체에만 존재하고, 테이블은 항상 양방향 관계이므로 단방향 관계가 존재하지 않습니다.</strong> Foreign key와  Join을 통해 양쪽 테이블을 참조할 수 있기 때문입니다.</li>\n<li>다중성: [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)] 관계가 있습니다. 여러 회원이 하나의 팀에 속하므로 다대일 관계이고, 팀은 여러 회원이 소속될 수 있으므로 일대다 관계입니다.</li>\n<li>연관관계의 주인: 객체는 단방향 참조 두 개를 통해 양방향 관계를 만듭니다. 따라서, 연관관계의 주인을 정하고 이를 통해서 연관관계를 관리해야 합니다. ( 추후 설명 )</li>\n</ul>\n<p><strong>RDBMS의 외래 키</strong></p>\n<p>RDBMS에서는 외래 키는 다른 테이블의 Primary Key를 참조하는 컬럼을 말합니다. 여기에 RDBMS에서 제공하는 외래 키 제약조건(Foreign Key Constraint) DDL을 선언해주면 , <strong>참조 무결성을 보장합니다.</strong></p>\n<p>참조 무결성은 보통 삭제동작에서 검증하며, 부모 레코드가 삭제되어 고아 레코드가 되는것을 방지하고,</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088579-d6d0d2ee-1508-4fee-8f78-6179a0462961.png\" alt=\"1\"></p>\n<p>먼저 팀과 멤버가 갖는 <strong>객체, 테이블</strong> 각각에서의 연관관계를 확인하며 연관관계가 갖는 특성을 살펴보겠습니다.</p>\n<ul>\n<li>\n<p>객체에서의 연관관계</p>\n<ul>\n<li>Member.team필드로 참조를 통한 연관관계를 갖습니다.</li>\n<li>이는 <strong>단방향 관계</strong>입니다. member.getTeam()을 통해 팀을 알 수 있지만, team.getMembers()를 통해 멤버 정보를 알 수 없기 때문입니다.</li>\n</ul>\n</li>\n<li>\n<p>테이블에서의 연관관계</p>\n<ul>\n<li>TEAM_ID라는 외래 키를 통해 연관관계를 맺습니다.</li>\n<li>TEAM_ID를 통해 Member를 기준으로 Join할 수도 있고, Team을 기준으로 Join할수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p>객체와 테이블 연관관계의 가장 큰 차이점: 객체는 [member → team], [team → member] 로 참조를 두 개 만들어도, 양방향 관계가 아니다!</p>\n<ul>\n<li>만약 두 방향의 참조가 모두 있다고 가정해보자.  team에 member들이 소속되어있고, member도 team 필드를 가지고있다.</li>\n<li>만약 멤버가 팀을 옮겨서 member.setTeam(anotherTeam); 으로 팀을 옮겼다고 해도, <strong>team 객체에는 옮긴 멤버의 참조가 남아있다.</strong>  단방향 관계 두 개를 따로 관리해야하는 것이다. (연관관계의 주인, mappedby가 필요한 이유)</li>\n<li>하지만 테이블은 Foreign Key를 통해 Join하므로, 멤버의 TEAM_ID필드가 변경된 경우, Team테이블에서도 Join을 통해 멤버를 조회했을 때 정상적으로 확인된다(옮긴 멤버가 조회되지 않는다)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jpa에서의-객체-매핑\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C%EC%9D%98-%EA%B0%9D%EC%B2%B4-%EB%A7%A4%ED%95%91\" aria-label=\"jpa에서의 객체 매핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서의 객체 매핑</h3>\n<p>Member와 Team엔티티가 연관관계를 맺는 예시입니다. 아래에서는 해당 엔티티를 통해 연관관계 매핑을 설명합니다.</p>\n<p>Member 엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@ManyToOne</span>\n\t<span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Team엔티티</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"TEAM_ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>@ManyToOne: 다대일관계라는 정보를 갖는 매핑 애너테이션입니다. 매핑 시 <strong>연관관계의 주인 엔티티에</strong> 필수적으로 사용해야합니다. 양방향의 경우, 연관관계를 갖는 각 필드에 알맞는 애너테이션을 추가합니다.</li>\n<li>@JoinColumn: 외래키를 name속성의 컬럼에 매핑합니다. 생략 가능하며, 생략 시 [필드이름  + 연관 엔티티 식별자 이름] 으로 기본값을 갖습니다. (따라서 위의 경우는 “team_id” 컬럼!)</li>\n</ul>\n<h3 id=\"연관관계-저장\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%80%EC%9E%A5\" aria-label=\"연관관계 저장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계 저장</h3>\n<p>엔티티를 저장할 때는, 연관관계 엔티티를 저장하려 하는 경우, <strong>연관 엔티티 역시 영속상태여야 한다.</strong></p>\n<blockquote>\n<p>이것을 보고 궁금해서 직접 실험해봤는데, 영속하지 않은 상태에서 setTeam한 후, 영속시켜도 정상적으로 동작하는것을 확인했다.  내부적으로 어떤 차이가 있는지는 확인이 필요하다.</p>\n</blockquote>\n<h3 id=\"조회\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%ED%9A%8C\" aria-label=\"조회 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조회</h3>\n<ul>\n<li>객체 그래프 탐색을 통한 조회(프록시를 이용)\n<ul>\n<li>객체지향적인 방법!</li>\n</ul>\n</li>\n<li>객체지향 쿼리 사용(JPQL: SQL 방언으로 변환)\n<ul>\n<li>파라미터를 쿼리에 바인딩하는 전통적 방법과 유사하다.</li>\n<li>연관 엔티티는 Join문을 통해 조회한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"수정\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A0%95\" aria-label=\"수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수정</h3>\n<p><strong>연관 엔티티 수정</strong>은 특별한 방법 없이 엔티티를 수정하면 플러시 시점에 변경감지가 작동한다.</p>\n<h3 id=\"삭제\" style=\"position:relative;\"><a href=\"#%EC%82%AD%EC%A0%9C\" aria-label=\"삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<p>연관 엔티티를 제거할 때는, <strong>연관관계의 주인이 먼저 삭제될 수 없다(외래 키 제약조건) 이 경우, 데이터베이스에서 참조 무결성 오류가 발생한다.</strong></p>\n<p>따라서, 외래키를 가지고있는 부모 엔티티의 연관관계를 삭제하거나, 자식 엔티티를 삭제해 연관관계를 지운 후 부모 엔티티를 삭제할 수 있다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  테이블이 양방향 참조를 할 수 있는 이유는 무엇인가요? (객체와 참조 방향성 측면에서 어떤 차이가 있나요?)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속되지 않은 엔티티를 영속상태의 엔티티에 연관객체로 지정할 수 있나요?\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  비영속상태의 team와 영속상태의 member에서, member.setTeam(team)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  영속상태의 team와 비영속상태의 member에서, member.setTeam(team) 후 member 영속</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h3>\n<p><a href=\"%5Bhttps://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16%5D(https://learn.microsoft.com/ko-kr/sql/relational-databases/tables/primary-and-foreign-key-constraints?view=sql-server-ver16)\">MS learn - 외래 키 제약조건</a></p>","id":"228d870b-db70-59ed-ba74-50e933c33e29","fields":{"slug":"jpa-연관관계-매핑-기초"},"frontmatter":{"date":"2023-01-17","title":"JPA 연관관계 매핑 기초","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":2},{"excerpt":"JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다. 데이터베이스에는 유일성 최소성을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.…","html":"<p>JPA에서 엔티티와 데이터베이스의  기본 키(Primary Key) 매핑을 알아보겠습니다.</p>\n<p>데이터베이스에는 <strong>유일성</strong> <strong>최소성</strong>을 만족하는지 여부에 따라 몇가지 키 종류가 존재합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/226088482-446952cd-6dc2-42a8-b0dd-10e0a9e20137.png\" alt=\"1\"></p>\n<p><strong>유일성</strong>이란, 여러 레코드들 중, 하나의 레코드를 특정지을 수 있는 키의 특성입니다.</p>\n<p>예를들어 이름,생일과 같은 특성은 레코드를 하나로 특정지을 수 없지만, [**학교 , 학번]**의 조합이나 [**주민등록번호]**와 같은 특성은 레코드를 유일하게 특정지을 수 있으므로 유일성을 만적하는 특성입니다.</p>\n<p><strong>최소성</strong>이란, 레코드를 유일하게 식별하는데 꼭 필요한 최소한의 특성만 선택되어야한다는 키의 특성입니다.</p>\n<p>예를 들어, <strong>[이름, 나이, 주민등록번호]</strong> 의 속성 조합으로 유일성을 만족하지만, 이름과 나이 없이 주민등록번호만으로 레코드를 유일하게 식별할 수 있으므로, <strong>최소성을 만족하지 못하는 키</strong>이고, <strong>[주민등록번호]</strong> 로 구성된 키는 <strong>최소성을 만족한다</strong>고 할 수 있습니다.</p>\n<h2 id=\"jpa의-기본-키-매핑-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa의 기본 키 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 기본 키 매핑 방법</h2>\n<p>데이터베이스 시스템에서는 보통 레코드의 기본 키를 설정하기 위한 디폴트 설정이 있습니다. 앞서 소개한 주민등록번호나 학교+학번은 사실 <strong>비즈니스 상 변경</strong>될 수도 있는 값이고, <strong>인덱스를 통해</strong> <strong>효율적으로 탐색</strong>하기에는 부적절한 키입니다.</p>\n<p>그렇기때문에 데이터베이스 시스템에서는 비즈니스 로직과 관계 없는 고유한 값을 만들어 기본 키로 채택하는데요,   이번 글은 JPA에서 엔티티와 데이터베이스 테이블 간 “기본 키”를 어떻게 생성하고 매핑하는지 알아보겠습니다.</p>\n<p>참고로 좋은 데이터베이스 기본 키를 선택하는 기준은 아래와 같습니다.</p>\n<ul>\n<li>Null값을 허용하지 않음</li>\n<li>변하지 않음</li>\n<li>유일함</li>\n</ul>\n<p>JPA로 엔티티를 한번 이상 만들어봤다면, 기본적으로 아래 구조를 띄는것을 알 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 구성하면, Member테이블의 Key인 Id필드는 언제 지정될까요? 영속성 관리에서 배운것처럼, 엔티티는 바로 데이터베이스에 저장되지 않고 1차캐시에 저장됩니다.</p>\n<p><em><strong>고치기</strong></em></p>\n<p>만약 데이터베이스의 기본 키 생성 전략이 직접할당일 경우에는, 애플리케이션에서 엔티티의 키를 설정할 방법이 없을것입니다.</p>\n<p>JPA에서는 데이터베이스 벤더별로 각기 다른 키 생성 전략과 자바 엔티티를 매핑하기 위해, @Id 컬럼에 여러 옵션들을 제공합니다.</p>\n<h2 id=\"기본-키-생성-전략\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%82%A4-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5\" aria-label=\"기본 키 생성 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 키 생성 전략</h2>\n<p>기본키를 어떤 방식으로 생성하느냐에 따라, <strong>개발자가 키를 직접 설정하는</strong> 직접할당 전략, <strong>자동으로 키를 생성하는</strong>  IDENTITY, SEQUENCE, TABLE, AUTO 전략을 살펴봅니다.</p>\n<p>아래의 Java 타입을 선언한 뒤, Id애너테이션을 통해 필드가 기본 키로 매핑되도록 합니다.</p>\n<p>@<strong>Id필드 타입</strong></p>\n<p>Id 애너테이션은 다음과 같은 자바 타입에서만 적용 가능합니다</p>\n<ul>\n<li>Primitive Types</li>\n<li>Wrapper Types</li>\n<li>String</li>\n<li>java.util.Date</li>\n<li>java.sql.Date</li>\n<li>java.math.[bigDecimal, bigInteger]</li>\n</ul>\n<h3 id=\"직접-할당-전략\" style=\"position:relative;\"><a href=\"#%EC%A7%81%EC%A0%91-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5\" aria-label=\"직접 할당 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>직접 할당 전략</h3>\n<p>기본 키 직접 할당 전략은 프로그래머가 <strong>엔티티매니저에 영속되기 전에</strong> 엔티티의 키를 직접 할당하는 방식입니다.</p>\n<p>이 방식에서 식별자 값 없이 영속시키면 PersistenceExeption이 발생합니다.</p>\n<p><strong>설정방법:  Id</strong> 필드에 @Id 애너테이션을 적용하면 기본키를 직접 할당방식으로 테이블이 생성됩니다.</p>\n<h3 id=\"identity-전략\" style=\"position:relative;\"><a href=\"#identity-%EC%A0%84%EB%9E%B5\" aria-label=\"identity 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IDENTITY 전략</h3>\n<p>IDENTITY전략은 기본 키 생성 전략을 데이터베이스에 위임하는 방식입니다.</p>\n<p>보통 AUTO_INCREMENT같은 자동 키 생성방법을 제공하는 MySQL, Postgresql, DB2등에서 사용합니다.</p>\n<p><strong>설정방법: 필드에</strong> GeneratedValue 애너테이션, strategy 옵션을 GenerationType.IDENTITY로 설정</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">IDENTITY</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>em.persist(member) → insert query 날리고 → select query(id 포함된 레코드) → 영속성 컨텍스트에 저장</strong></p>\n<p><strong>주의사항</strong></p>\n<p>영속성 컨텍스트에 저장될때는 필수로 식별자 값이 필요한데, IDENTITY 전략에서는 기본 키를 데이터베이스에서 지정하므로, <strong>식별자를 알 수없다</strong>.</p>\n<p>그러므로 IDENTITY전략을 사용하는 엔티티는 <strong>영속되는 시점에 INSERT쿼리를 데이터베이스에 전달</strong>한다.</p>\n<p>따라서 <strong>IDENTITY전략에서는 트랜잭션을 지원하는 쓰기지연이 동작하지 않는다.</strong></p>\n<p><strong>최적화 방법</strong></p>\n<p>IDENTITY전략에서는 영속 시 INSERT쿼리를 데이터베이스에 전달하고, 식별자를 얻기 위해 추가로 조회작업을 해야해서 총 <strong>2번의 통신이 이뤄진다.</strong></p>\n<p>JDBC3에서 추가된 Statement.getGeneratedKeys()를 사용하면, 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다.</p>\n<h3 id=\"sequence-전략\" style=\"position:relative;\"><a href=\"#sequence-%EC%A0%84%EB%9E%B5\" aria-label=\"sequence 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SEQUENCE 전략</h3>\n<p>데이터베이스에서 시퀀스는 유일한 값을 순서대로 생성하는 데이터베이스 오브젝트입니다. Sequence를 제공하는 Oracle,Postgresql, DB2,H2등에서 사용가능합니다.</p>\n<p>SEQUENCE방법은 이를 통해 기본 키를 생성합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>엔티티에 @SequenceGenerator 등록: 시퀀스 생성기 등록  옵션은 아래와 같습니다.\n<ul>\n<li>name : 엔티티에서 갖는 시퀀스생성기 이름(필수)</li>\n<li>sequenceName : 데이터베이스의 시퀀스 이름</li>\n<li>initialValue : DDL 생성시 처음 시작하는 숫자</li>\n<li>allocationSize:시퀀스 호출 시 증가하는 숫자, 기본값 50 (최적화에 사용)</li>\n<li>catalog, schema: 데이터베이스의  catalog, schema</li>\n</ul>\n</li>\n<li>@GeneratedValue의 strategy 속성을 GenerationType.SEQUENCE로 설정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@SequenceGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>  \n\tsequenceName<span class=\"token operator\">=</span><span class=\"token string\">\"MEMBER_SEQ\"</span><span class=\"token punctuation\">,</span> \n\tinitialValue<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> \n\tallocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span>  \n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy<span class=\"token operator\">=</span><span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">SEQUENCE</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>@SequenceGenerator의 옵션이 다양하게 존재하는것을 확인할 수 있다.</p>\n<p><strong>참고사항1. 시퀀스 동작구조</strong></p>\n<p>IDENTITY전략과 마찬가지로 ,데이터베이스에서 식별자 값을 가져와야 하지만 IDENTITY전략이 영속성 컨텍스트에서 Insert 쿼리를 날린 뒤 조회를 한것과는 달리, SEQUENCE 전략에서는 데이터베이스 시퀀스만 조회해 식별자값만 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> emp_seq<span class=\"token punctuation\">.</span>NEXTVAL\n     <span class=\"token punctuation\">,</span> emp_seq<span class=\"token punctuation\">.</span>CURRVAL\n  <span class=\"token keyword\">FROM</span> dual</code></pre></div>\n<p>따라서 <strong>SEQUENCE전략은 트랜잭션을 사용하는 쓰기지연 방식을 지원하지만, 시퀀스를 추가적으로 조회한다</strong>.</p>\n<p><strong>참고사항 2. allocationSize의 기본값이 50이다.</strong></p>\n<p><strong>hibernate.id.new_generator_mappings 설정이 true인 경우, allocationSize</strong>는 <strong>기본적으로 50으로 설정됩니다. 이는 JPA의 시퀀스 접근횟수를 줄이기 위함이고, 아래와 같이 동작합니다.</strong></p>\n<ul>\n<li>JPA에서 데이터베이스 시퀀스에 접근</li>\n<li>시퀀스는 <strong>allocationSize값인 50만큼 시퀀스를 생성</strong></li>\n<li>JPA는 메모리에 1 ~ 50까지의 시퀀스를 메모리에 할당.</li>\n<li>50개까지 엔티티가 생성되어도, 시퀀스를 생성하기 위해 DB에 접근하지 않아도 됨.</li>\n</ul>\n<p>멀티서버 환경에서는 엔티티가 생성된 순서대로 ID가 증가하지는 않지만, Insert성능 측면에서 가장 훌륭함.</p>\n<h3 id=\"table-전략\" style=\"position:relative;\"><a href=\"#table-%EC%A0%84%EB%9E%B5\" aria-label=\"table 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TABLE 전략</h3>\n<p>TABLE전략은 키 생성용 테이블을 만들고, 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략입니다. 또한, 테이블을 사용하므로 모든 데이터베이스에서 적용가능합니다.</p>\n<p><strong>설정방법:</strong></p>\n<ul>\n<li>필드에 @GeneratedValue 등록, 아래의 속성 추가\n<ul>\n<li>strategy = GenerationType.Table,</li>\n<li>generator = 시퀀스 생성테이블 이름(TableGenerator의 name속성 값) 등록</li>\n</ul>\n</li>\n<li>엔티티에 @TableGenerator 등록 : 속성들이 많은데, 시퀀스 테이블을 구성하기 위한 이름과 관련된것들이 많습니다. 아래에서 설명합니다.\n<ul>\n<li>name: 식별자 생성기 이름 (필수)</li>\n<li>table:  키 생성 테이블명 (기본값 - hibernate_sequence)</li>\n<li>pkColumnValue:  키로 사용할 이름 [ Default - 엔티티명 ]</li>\n<li>pkColumnName: 시퀀스 컬럼명 [ Default - sequence_name]</li>\n<li>valueColumnName: 시퀀스 값 컬럼명 [ Default - next_val ]</li>\n<li>initalValue: 초기 값 [ Default - 0 ]</li>\n<li>allocationSize; 시퀀스 한번 호출에 증가하는 숫자(최적화용), [ Default  1 or 50: 최적화 설정 적용여부에 따라 ]</li>\n<li>catalog, schema: 데이터베이스 catalog, schema 이름</li>\n<li>uniqueConstraints: 유니크 제약조건</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@TableGenerator</span><span class=\"token punctuation\">(</span>\n\tname<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">,</span>\n\ttable<span class=\"token operator\">=</span><span class=\"token string\">\"MY_SEQUENCE\"</span><span class=\"token punctuation\">,</span>\n\tpkColumnValue<span class=\"token operator\">=</span><span class=\"token string\">\"BOARD_SEQ\"</span><span class=\"token punctuation\">,</span> allocationSize<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Board</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TABLE</span><span class=\"token punctuation\">,</span>\n\t\tgenerator <span class=\"token operator\">=</span> <span class=\"token string\">\"BOARD_SEQ_GENERATOR\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 등록 하게 되면, 아래와 같이 시퀀스 이름과 시퀀스 값을 컬럼으로 갖는 테이블을 만들어 시퀀스를 관리합니다</p>\n<p>앞서 @TableGenerator의 속성들 중 <del>Column</del> 같은 이름에 사용되는 속성들이 많이 보이는데요, 시퀀스테이블을 구성할 때 사용하는 이름입니다.</p>\n<table>\n<thead>\n<tr>\n<th>sequence_name</th>\n<th>next_val</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BOARD_SEQ</td>\n<td>102</td>\n</tr>\n<tr>\n<td>MEMBER_SEQ</td>\n<td>50</td>\n</tr>\n</tbody>\n</table>\n<p><strong>참고사항: 테이블전략 동작구조</strong></p>\n<p>(시퀀스)테이블의 값을 조회하고, 이 값을 기반으로 Update쿼리를 한번 더 날리기때문에, 시퀀스 전략보다 네트워크 통신을 1회 더 한다는 단점이 있습니다.</p>\n<p>이는 SEQUENCE방법과 같이 allocationSize를 통해 최적화할 수 있습니다.</p>\n<h3 id=\"auto-전략\" style=\"position:relative;\"><a href=\"#auto-%EC%A0%84%EB%9E%B5\" aria-label=\"auto 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AUTO 전략</h3>\n<p>@GeneratedValue.strategy의 기본 설정값인 AUTO전략입니다.</p>\n<p>AUTO 전략은 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE중 하나를 자동으로 선택합니다.</p>\n<ul>\n<li><strong>데이터베이스가 변경되어도 코드를 수정할 필요가 없습니다.</strong></li>\n<li>MySQL은 IDENTITY, Oracle은 SEQUENCE방법 선택합니다.</li>\n</ul>\n<h2 id=\"매우매우-중요한-뽀인트\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%EC%9A%B0%EB%A7%A4%EC%9A%B0-%EC%A4%91%EC%9A%94%ED%95%9C-%EB%BD%80%EC%9D%B8%ED%8A%B8\" aria-label=\"매우매우 중요한 뽀인트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매우매우 중요한 뽀인트</h2>\n<p>JPA에서 <strong>키 생성 전략은 INSERT성능에 중요한 영향을 미친다!!!</strong></p>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  자동 키 생성전략: IDENTITY, SEQUENCE, TABLE 방법에서 영속성 컨텍스트에 식별자를 동기화하기 위해 각각은 어떻게 동작하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  allocationSize 속성은 어떻게 키 생성 전략에서 최적화를 수행하나요?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  AUTO 생성전략은 무엇이고, 어떤 장점이 있나요?</li>\n</ul>\n<h2 id=\"챕터에-없지만-알아볼-내용\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EC%97%86%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EB%B3%BC-%EB%82%B4%EC%9A%A9\" aria-label=\"챕터에 없지만 알아볼 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 없지만 알아볼 내용</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  Table 방식과 Sequence 방식은 근본적으로 어떤 차이점이 있나요? (시퀸스는 테이블과 어떻게 다른가요?)</p>\n</li>\n</ul>\n<h3 id=\"정답\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%8B%B5\" aria-label=\"정답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정답</h3>\n<ul>\n<li>각 방법에 대한 답변\n<ul>\n<li>IDENTITY의 경우, 데이터베이스에 키 생성전략을 위임한다. AUTO_INCREMENT같이 자동으로 기본 키를 설정해주는 MYSQL등에서 사용한다. (MySQL AUTO_INCREMENT가 적용되었을 때, id없이 insert 쿼리가 가능하다!). [ 삽입/조회 쿼리 발생, 쓰기지연 불가 ]</li>\n<li>SEQUENCE는 증가하는 값을 생성해내는 객체로, 조회만을 통해 증가하는 값을 할당받아 엔티티의 키로 지정한다. [ 조회쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n<li>TABLE은 키 할당 정보를 관리하는 테이블을 생성해 키를 매핑한다. Sequence와 유사하게 동작합니다. [ 조회/수정쿼리 발생, <strong>allocationSize로</strong> 최적화 가능 ]</li>\n</ul>\n</li>\n<li>Table, Sequence방법에서 사용하는 최적화 전략으로, 키를 allocationSize만큼 할당받아 사용. 식별자를 생성하기 위해 N회 쿼리를 날리는것에서 N/allocationSize 만큼만 쿼리를 날리게 됨.</li>\n<li>AUTO방식은 데이터베이스 방언에 맞는 자동 키 생성방식을 설정합니다. 데이터베이스 벤더가 변경되어도 코드가 변경될 필요가 없다는 장점이 있습니다.</li>\n</ul>\n<hr>\n<ul>\n<li>시퀀스는 select 시퀀스네임.nextval from dual 을 통해 다음 값을 조회하고 자동으로 증가합니다. 따라서 테이블 방식과 달리, Update 쿼리를 사용할 필요가 없어 효율적입니다.</li>\n</ul>","id":"b78f1971-39d1-5252-8584-8372d1a2ca74","fields":{"slug":"jpa에서-기본-키-매핑-방법-종류"},"frontmatter":{"date":"2023-01-13","title":"JPA에서 기본 키 매핑 방법 종류","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":4},{"excerpt":"JPA에서 엔티티를 작성하는 방법 JPA에서 **엔티티(Entity)**는 관계형 데이터베이스의 테이블과 대응하며, JPA가 관리하는 클래스를 말합니다. 이는 Java 클래스로 선언하며, 보통 domain 패키지에 포함되고, 아래와 같이 구성됩니다 기본 엔티티 매핑 방법 @Entity JPA에서 테이블과 매핑할 클래스는 @Entity 애너테이션을 필수로 붙여야 합니다. @Entity…","html":"<h1 id=\"jpa에서-엔티티를-작성하는-방법\" style=\"position:relative;\"><a href=\"#jpa%EC%97%90%EC%84%9C-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"jpa에서 엔티티를 작성하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA에서 엔티티를 작성하는 방법</h1>\n<p>JPA에서 **엔티티(Entity)**는 관계형 데이터베이스의 테이블과 대응하며, JPA가 관리하는 클래스를 말합니다.</p>\n<p>이는 Java 클래스로 선언하며, 보통 domain 패키지에 포함되고, 아래와 같이 구성됩니다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"기본-엔티티-매핑-방법-entity\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95-entity\" aria-label=\"기본 엔티티 매핑 방법 entity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 엔티티 매핑 방법 @Entity</h2>\n<p>JPA에서 테이블과 매핑할 클래스는 @Entity 애너테이션을 필수로 붙여야 합니다. @Entity 적용 시에는, 클래스가 아래 주의사항을 따라야 합니다</p>\n<ul>\n<li>기본생성자 필수</li>\n<li>final, enum, interface, inner 클래스에는 사용 불가</li>\n<li>테이블에 저장할 필드는 final 키워드 사용 불가</li>\n</ul>\n<blockquote>\n<p>JPA는 자바 리플렉션(Java Reflection API)을 통해 엔티티 정보를 받는데, 이 때 생성자 인자 정보를 가져올 수 없으므로 기본 생성자는 필수적으로 필요합니다. 몇몇 JPA구현체(하이버네이트같은)에서는 바이트코드 조작(Bytecode Manipulation)을 통해 이런 문제를 회피한다고 합니다.</p>\n</blockquote>\n<blockquote>\n<p>자바는 클래스를 생성하면 기본 생성자를 자동으로 만들지만, 만약 생성자가 추가된다면 기본 생성자가 사라지므로 주의해야 합니다. (대부분의 IDE에서 잡아주긴 하지만..)</p>\n</blockquote>\n<p><strong>속성</strong></p>\n<ul>\n<li>name: 엔티티 이름 지정, 기본값 - 클래스명</li>\n</ul>\n<h2 id=\"매핑할-테이블을-지정하는-table\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%ED%95%91%ED%95%A0-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-table\" aria-label=\"매핑할 테이블을 지정하는 table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매핑할 테이블을 지정하는 @Table</h2>\n<p>@Table은 엔티티와 매핑할 데이터베이스 테이블을 지정합니다. 생략 시, 엔티티 이름을 테이블 이름으로 사용합니다.</p>\n<ul>\n<li>name속성: 매핑할 테이블 이름, 기본값 - 엔티티 이름</li>\n<li>catalog: catalog 기능이 있는 데이터베이스에서 catalog 매핑</li>\n<li>schema - schema기능이 있는 데이터베이스에서 schema를 매핑한다</li>\n<li>uniqueConstraints - DDL 생성 시, 유니크 제약조건을 만듭니다.</li>\n</ul>\n<blockquote>\n<p>catalog 기능: 데이터베이스의 인덱스, 뷰테이블, 사용자정보 등 메타데이터를 저장하는 객체</p>\n</blockquote>\n<h2 id=\"엔티티-내-필드-매핑-방법\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%82%B4-%ED%95%84%EB%93%9C-%EB%A7%A4%ED%95%91-%EB%B0%A9%EB%B2%95\" aria-label=\"엔티티 내 필드 매핑 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 내 필드 매핑 방법</h2>\n<p>MySQL,MsSQL등 다양한 RDBMS에는 데이터 타입이 존재합니다. JPA역시 Java의 데이터타입을 RDBMS와 매핑하기 위한 방법들이 존재합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"가장-많이-사용되는-column\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%B4-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-column\" aria-label=\"가장 많이 사용되는 column permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가장 많이 사용되는 @Column</h3>\n<p>데이터베이스 테이블과 필드를 매핑하기 위해 사용합니다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li><strong>name</strong>: 필드와 매핑할 테이블 컬럼 이름, 기본값 - 필드명</li>\n<li><strong>nullable</strong>(DDL) : false로 지정 시 NOT NULL 제약조건 추가. 기본값 true</li>\n<li><strong>unique</strong>(DDL) : true로 지정 시 하나의 칼럼에 대해 유니크 제약조건. 기본값 false</li>\n<li><strong>columnDefinition</strong>: 데이터베이스 컬럼정보를 직접 입력</li>\n<li><strong>length</strong>: String 타입의 필드의 경우, 최대 길이 제약조건. 기본값 255</li>\n<li><strong>precision</strong>, <strong>scale:</strong> precision의 경우 소수점 제외 전체자리수, scale은 소수 자리수</li>\n<li>i<strong>nsertable</strong>, <strong>updatable</strong>: 저장 / 수정하고싶지 않을 때 false로 지정, 기본값 true</li>\n<li><strong>table</strong>: 하나의 엔티티를 두 개의 테이블에서 사용하려고 할 때 사용</li>\n</ul>\n<blockquote>\n<p>필드에 @Column을 사용하지 않으면, 모든 속성이 기본값으로 들어가게 된다.</p>\n</blockquote>\n<blockquote>\n<p>Java Primitive type은 Null이 들어올 수 없으므로, DDL 생성 시 nullable=true로 설정됨</p>\n</blockquote>\n<blockquote>\n<p>Wrapper Type을 사용하거나  nullable을 false로 지정해야 한다.</p>\n</blockquote>\n<blockquote>\n<p>@Column(<strong>columnDefinition</strong>=”varchar(100)”) 과 같이, 방언정보를 활용해 선언한다</p>\n</blockquote>\n<h3 id=\"날짜-필드를-매핑하는-temporal\" style=\"position:relative;\"><a href=\"#%EB%82%A0%EC%A7%9C-%ED%95%84%EB%93%9C%EB%A5%BC-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-temporal\" aria-label=\"날짜 필드를 매핑하는 temporal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>날짜 필드를 매핑하는 @Temporal</h3>\n<p>java의 날짜 타입인 java.util.Date, java.util.Calendar를 매핑한다.</p>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 시간포맷 지정, 기본값 없음(필수지정)\n<ul>\n<li>TemporalType.DATE: “날짜(<strong>date</strong>)”에 매핑 - 2023-01-01</li>\n<li>TemporalType.TIME: “시간(<strong>time</strong>)”에 매핑 - 12:03:21</li>\n<li>TemporalType.TIMESTAMP: “날짜 및 시간(<strong>timestamp</strong>)에 매핑” - 2023-01-01 12:03:21</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Java의 Date에는 날짜,시간이 모두 있지만, RDBMS는 date, time, timestamp로 나누어져있는 경우가 많아 @Temporal을 명시한 경우 value 속성을 필수로 지정해야한다.</p>\n</blockquote>\n<blockquote>\n<p>@Temporal을 생략하면, DB의 timestamp 타입으로 매핑된다.</p>\n</blockquote>\n<h3 id=\"enum-타입을-매핑하는-enumerated\" style=\"position:relative;\"><a href=\"#enum-%ED%83%80%EC%9E%85%EC%9D%84-%EB%A7%A4%ED%95%91%ED%95%98%EB%8A%94-enumerated\" aria-label=\"enum 타입을 매핑하는 enumerated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>enum 타입을 매핑하는 @Enumerated</h3>\n<p><strong>속성</strong></p>\n<ul>\n<li>value: 저장할 값 지정\n<ul>\n<li>(기본)EnumType.ORDINAL: enum 순서를 데이터베이스에 저장</li>\n<li>EnumType.STRING: enum 이름을 데이터베이스에 저장</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>EnumType.ORDINAL로 지정할 경우, 저장되는 크기가 작다는 장점이 있지만, 순서가 바뀌거나 사이에 새로운 내용이 추가되었을 때, 데이터베이스의 기존 데이터와 일치하지 않는다는 문제가 있다. 따라서, EnumType.STRING을 권장한다.</p>\n</blockquote>\n<h3 id=\"길이제한-없는-문자타입-lob\" style=\"position:relative;\"><a href=\"#%EA%B8%B8%EC%9D%B4%EC%A0%9C%ED%95%9C-%EC%97%86%EB%8A%94-%EB%AC%B8%EC%9E%90%ED%83%80%EC%9E%85-lob\" aria-label=\"길이제한 없는 문자타입 lob permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>길이제한 없는 문자타입 @Lob</h3>\n<p>데이터베이스의 CLOB, BLOB 타입과 매핑됩니다. 필드 타입이 문자면 CLOB, 나머지는 BLOB로 매핑됩니다.</p>\n<p>Example)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자 필드이므로 CLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> lobString<span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@Lob</span> <span class=\"token comment\">//문자필드가 아니므로 BLOB으로 매핑</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> lobByte<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<blockquote>\n<p>CLOB: Character Large Object (대형 문자 객체) , BLOB: Binary Large Object(대형 이진 객체)로, 최대 4GB의 대형 문자/이진 객체를  데이터베이스 시스템 밖의 파일로 저장하는 타입입니다.</p>\n</blockquote>\n<h3 id=\"무시하고-매핑하지-않는-transient\" style=\"position:relative;\"><a href=\"#%EB%AC%B4%EC%8B%9C%ED%95%98%EA%B3%A0-%EB%A7%A4%ED%95%91%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-transient\" aria-label=\"무시하고 매핑하지 않는 transient permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>무시하고 매핑하지 않는 @Transient</h3>\n<p>@Transient가 지정된 필드는 데이터베이스에 저장하지 않고, 따라서 조회하지도 않습니다.</p>\n<h3 id=\"jpa의-접근방식을-지정하는-access\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%A0%91%EA%B7%BC%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-access\" aria-label=\"jpa의 접근방식을 지정하는 access permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 접근방식을 지정하는 @Access</h3>\n<p>JPA가 엔티티 데이터에 접근하는 방식을 지정합니다.</p>\n<ul>\n<li>필드접근: AccessType.FIELD - 필드에 직접 접근. private여도 가능합니다.</li>\n<li>프로퍼티접근: AccessType.Property - getter를 통해 접근합니다.</li>\n</ul>\n<blockquote>\n<p>@Id 의 위치에 따라, @id가 프로퍼티(getter)에 있으면, 자동으로 AccessType.PROPERTY에 지정, 필드에 있으면 AccessType.FIELD에 지정됩니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 필드통한 접근</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> <span class=\"token class-name\">Id</span>\n\n<span class=\"token annotation punctuation\">@Access</span> <span class=\"token comment\">//: 프로퍼티 통한 접근 </span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"아까-봤던-엔티티-다시보기\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B9%8C-%EB%B4%A4%EB%8D%98-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0\" aria-label=\"아까 봤던 엔티티 다시보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아까 봤던 엔티티 다시보기</h3>\n<p>내용들을 공부하기 전에 확인했던 엔티티입니다. 아래 엔티티를 확인하면, 필드에 선언된 애너테이션의 의미와 역할, 제한사항, 컬럼 등에 대해 이해할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token annotation punctuation\">@Table</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Id</span>\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"ID\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> id<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Column</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"NAME\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> age<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Enumerated</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">EnumType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">STRING</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">RoleType</span> roleType<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemporalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> createdDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Temporal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TemproalType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TIMESTAMP</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> lastModifiedDate<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token annotation punctuation\">@Lob</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> description\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"데이터베이스-스키마-자동생성\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99%EC%83%9D%EC%84%B1\" aria-label=\"데이터베이스 스키마 자동생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 스키마 자동생성</h2>\n<p>JPA는 위처럼 엔티티를 통해 데이터베이스 테이블이 어떻게 구성되는지 알 수 있습니다. 이를 통해 데이터베이스 스키마를 DDL(Data Definition Language)로 자동 생성해주는 기능을 갖습니다.</p>\n<p>(show-sql은 실행되는 쿼리를 콘솔에 출력해줍니다.)</p>\n<p>application.properties</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">spring.jpa.hibernate.ddl-auto: create\nspring.jpa.show-sql: true</code></pre></div>\n<p>application.yaml</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">jpa</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">show-sql</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\t\t<span class=\"token key atrule\">hibernate</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token key atrule\">ddl-auto</span><span class=\"token punctuation\">:</span> create\n</code></pre></div>\n<h3 id=\"ddl-auto-옵션\" style=\"position:relative;\"><a href=\"#ddl-auto-%EC%98%B5%EC%85%98\" aria-label=\"ddl auto 옵션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ddl-auto 옵션</h3>\n<table>\n<thead>\n<tr>\n<th>옵션</th>\n<th>환경</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>개발 초기</td>\n<td>기존 테이블을 삭제 후, 새로 생성 (DROP + CREATE)</td>\n</tr>\n<tr>\n<td>create-drop</td>\n<td>개발 초기</td>\n<td>애플리케이션을 시작할 때 CREATE, 종료할 때 DROP (CREATE + DROP)</td>\n</tr>\n<tr>\n<td>update</td>\n<td>테스트서버</td>\n<td>데이터베이스 테이블과 엔티티의 변경사항을 비교해 변경사항만 수정</td>\n</tr>\n<tr>\n<td>validate</td>\n<td>테스트서버 or</td>\n<td></td>\n</tr>\n<tr>\n<td>스테이징/운영서버</td>\n<td>데이터베이스 테이블과 엔티티 매핑정보가 차이가 있을 경우, 경고를 남기고 애플리케이션을 실행하지 않음.</td>\n<td></td>\n</tr>\n<tr>\n<td>none</td>\n<td>스테이징/운영서버</td>\n<td>자동생성기능을 사용하지 않음. ddl-auto 옵션을 제거하거나 유효하지 않은 옵션을 준것과 같음</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>ddl-auto 옵션은 운영환경에서 사용할만큼 완벽하지 않다고 한다. 그렇기에 학습이나 참고용으로만 사용하는것이 좋다.</p>\n</blockquote>\n<h2 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h2>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  데이터베이스에 2GB이상의 데이터를 저장하기 위해 JPA에서 어떤 애너테이션을 사용해야하는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  ddl-auto 옵션의 validate는 무슨 역할을 하는가?</li>\n</ul>\n<p><strong>정답</strong></p>\n<ol>\n<li>@Lob 애너테이션을 사용하면 문자열의 경우 CLOB, 이외는 BLOB으로 매핑해줍니다. 다만, Java String의 경우 최대 길이가 2GB이므로, 내용이 절삭되는것에 유의해야 한다.</li>\n<li>데이터베이스 테이블과 엔티티의 매핑이 일치하는지 확인하고, 일치하지 않으면 경고와 함께 애플리케이션을 실행하지 않음</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>","id":"ccf75a49-36b1-5159-856c-f8b3cd59287f","fields":{"slug":"jpa에서-엔티티를-작성하는-방법"},"frontmatter":{"date":"2023-01-08","title":"JPA에서 엔티티를 작성하는 방법","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":4},{"excerpt":"JPA의 엔티티매니저와 영속성 관리 JPA의 엔티티매니저가…","html":"<h1 id=\"jpa의-엔티티매니저와-영속성-관리\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%EB%8B%88%EC%A0%80%EC%99%80-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC\" aria-label=\"jpa의 엔티티매니저와 영속성 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 엔티티매니저와 영속성 관리</h1>\n<p>JPA의 엔티티매니저가 1차캐시, 쓰기지연, 영속성 관리 등의 역할을 하기 위해 어떻게 동작하는지 살펴보자</p>\n<h2 id=\"엔티티-매니저-팩토리-엔티티-매니저\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80\" aria-label=\"엔티티 매니저 팩토리 엔티티 매니저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 매니저 팩토리, 엔티티 매니저</h2>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 클래스입니다. 일반적으로 하나의 데이터베이스를 사용하는 애플리케이션은, 하나의 엔티티 매니저 팩토리를 생성하고 이를 통해 엔티티 매니저를 생성합니다.</p>\n<p>엔티티 매니저 팩토리는 생성시 매우 큰 비용을 지불해야 하므로, 애플리케이션당 하나를 사용하면 되고, <strong>Thread-safe</strong>하므로 다른 스레드와 공유해도 괜찮습니다.</p>\n<p>반면 엔티티매니저의 경우, 생성 비용이 거의 들지 않지만 여러 스레드가 동시에 접근할 경우, <strong>동시성 문제</strong>가 발생하므로, 스레드간 공유하면 안됩니다.</p>\n<img width=\"473\" alt=\"JPA_3_1\" src=\"https://user-images.githubusercontent.com/30853787/210956641-10027f43-7206-4d82-96d1-25c6d304035e.png\">\n<p>또한, 엔티티 매니저는 데이터베이스 연결이 필요한 시점까지 커넥션이 없는 상태로 유지하다가, 트랜잭션이 시작되는 등, 데이터베이스 연결이 필요한 시점이 되면 커넥션을 획득합니다.</p>\n<h2 id=\"엔티티의-생명주기\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"엔티티의 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티의 생명주기</h2>\n<p>엔티티는 영속성 컨텍스트라는 엔티티 저장소에 영속되어 관리됩니다.  엔티티는 영속 상태에 따라 4가지의 상태가 있고, 생명주기는 아래와 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956646-f95a5164-e574-4b35-a23b-988c0e0780da.png\" alt=\"JPA_4\"></p>\n<ul>\n<li>비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태\n<ul>\n<li>New를 통해 엔티티를 생성해, 엔티티와 영속성 컨텍스트가 아무 관련이 없는 상태이다.</li>\n</ul>\n</li>\n<li>영속: 엔티티가 영속성 컨텍스트에 의해 관리되는 상태\n<ul>\n<li><strong>em.persiste(member)</strong> 또는, <strong>em.find(Member.class, “memberId”);</strong> 로 SQL을 통해 데이터 조회 시, 영속상태가 된다</li>\n<li>영속된 엔티티는 식별자를 통해 관리된다.</li>\n</ul>\n</li>\n<li>준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태\n<ul>\n<li>em.close()로 영속성 컨텍스트를 닫거나 em.clear()를 호출해 영속성 컨텍스트를 초기화하는 경우, 엔티티들이 준영속 상태가 된다</li>\n<li>**em.detach(member)**같이 특정 엔티티를 준영속시킬수도 있다.</li>\n<li>개발자가 엔티티를 준영속 상태로 만드는 일은 흔치않은 일입니다.</li>\n</ul>\n</li>\n<li>삭제: 삭제된 상태\n<ul>\n<li>em.remove(member); 를 통해 영속성 컨텍스트 및 데이터베이스에서 삭제됩니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"영속성-컨텍스트란\" style=\"position:relative;\"><a href=\"#%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80\" aria-label=\"영속성 컨텍스트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>영속성 컨텍스트란?</h2>\n<p><strong>엔티티를 영구 저장하는 환경</strong>으로, 엔티티 매니저를 통해 엔티티를 저장하거나 조회했을 때, 엔티티 매니저는 엔티니를 영속성 컨텍스트에 보관 및 관리합니다. 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제나 성능 개선을 위해 아래와 같은 특징을 갖습니다.</p>\n<h3 id=\"엔티티-조회-시-1차캐시-제공\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%A1%B0%ED%9A%8C-%EC%8B%9C-1%EC%B0%A8%EC%BA%90%EC%8B%9C-%EC%A0%9C%EA%B3%B5\" aria-label=\"엔티티 조회 시 1차캐시 제공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 조회 시 1차캐시 제공</h3>\n<p>영속성 컨텍스트 내부에는 Map 자료구조가 존재합니다. @Id로 매핑한 값을 Key로 사용하고, 엔티티 인스턴스를 Value로 합니다.</p>\n<p>만약 멤버 인스턴스가 생성되어 <strong>영속성 컨텍스트에 영속된 상태</strong>라면, 해당 엔티티에 대해 식별자로 조회했을 때 동일성이 보장되는 멤버 인스턴스를 <strong>데이터베이스 조회 없이</strong> 조회해주는 <strong>캐싱 기능</strong>을 제공합니다. 이를 <strong>1차캐시</strong>라고 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"member1\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nem<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//동일성 보장, Insataces has same identity 출력</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>emMember <span class=\"token operator\">==</span> member<span class=\"token punctuation\">)</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Insataces has same identity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>1차캐시에 엔티티가 저장되어있는경우의 workflow입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956653-ad82cf2d-7e52-48f9-b3f0-785f73a587c5.png\" alt=\"JPABook_97 drawio\"></p>\n<p>위의 경우와 달리, 멤버 <strong>엔티티가 1차캐시에 등록되어있지 않다면</strong>, SQL문으로 데이터를 조회하고, 엔티티를 생성한 뒤 1차캐시에 저장해 이를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//데이터베이스에 존재하지만, 영속상태가 아닌 엔티티 조회 </span>\n<span class=\"token class-name\">Member</span> emMember <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"member2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956650-60b80152-5734-4d92-a11a-3028a9178bf8.png\" alt=\"JPABook_97 drawio_(1)\"></p>\n<p>따라서 영속성 컨텍스트는 1차캐시 기능을 통해 총 두 가지의 이점을 얻습니다.</p>\n<ul>\n<li>엔티티의 동일성 보장</li>\n<li>캐싱을 통한 성능 향상</li>\n</ul>\n<h3 id=\"트랜잭션을-지원하는-쓰기지연-transactional-write-behind\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%93%B0%EA%B8%B0%EC%A7%80%EC%97%B0-transactional-write-behind\" aria-label=\"트랜잭션을 지원하는 쓰기지연 transactional write behind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션을 지원하는 쓰기지연 (Transactional write-behind)</h3>\n<p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 전달하지 않고, 쓰기지연 저장소에 쌓아놓고, 트랜잭션이 커밋되는 순간 데이터베이스에 쿼리를 전달합니다. 이것을 트랜잭션을 지원하는 쓰기지연이라고 합니다.</p>\n<p>(1) Commit 전까지 영속성 컨텍스트에 쿼리 저장, 1차캐시에 엔티티 저장</p>\n<p>(2) 트랜잭션 커밋 시, DB에 flush.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956659-2e9b80db-b21d-4ed8-8694-3561dfbff315.png\" alt=\"JPABook-100 drawio\"></p>\n<h3 id=\"엔티티-수정\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%88%98%EC%A0%95\" aria-label=\"엔티티 수정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 수정</h3>\n<p>SQL을 사용한 엔티티 수정 작업은 많은 양의 쿼리 반복과 SQL의존성을 갖게됩니다.</p>\n<p>JPA는 역시 트랜잭션을 지원하는 쓰기지연을 이용해 객체지향적인 방법으로 해결합니다.</p>\n<p>이 때, 스냅샷이라는 새로운 개념이 등장하는데요, <strong>스냅샷</strong>은 엔티티가 영속성 컨텍스트에 <strong>처음 저장될 때의 값</strong>을 기억해놓은 것입니다.  영속성 컨텍스트는 이를 기반으로, 플러시가 호출되었을 때 엔티티와 스냅샷을 비교해 Update 쿼리를 생성하고, 데이터베이스에 전송, 커밋합니다.</p>\n<ul>\n<li>\n<ol>\n<li>flush 호출 시, Entity와 Snapshot 비교해 변경 감지</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>변경된부분이 있다면, 쓰기지연 저장소에 Update Query 추가</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>DB에 Update Query 전달 후 커밋</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210956656-6dec4769-15cb-4516-a35b-debf65f1a6c9.png\" alt=\"JPABook-100 drawio_(1)\"></p>\n<p>JPA 변경감지의 특징 : <strong>JPA가 생성하는 Update Query는  기본적으로 엔티티의 모든 필드를 업데이트합니다.</strong></p>\n<p>왜 이렇게 하는걸까요? 책에서는 <strong>재사용 측면</strong>에서 두 가지 정도의 장점을 설명합니다.</p>\n<ul>\n<li>수정쿼리가 항상 같아, 이를 애플리케이션 로딩 시점에 미리 로드해서 재사용할 수 있음</li>\n<li>데이터베이스는 동일한 쿼리를 받았을 때, 이전에 파싱된 쿼리를 재사용할 수 있음</li>\n</ul>\n<p>수정된 필드만을 이용해 쿼리를 전송하고 싶다면, @DynamicUpdate어노테이션을 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Mklee\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\"># Name 필드만 변경할것으로 예상</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> NAME <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">WHERE</span> ID <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#모든 필드를 수정</span>\n<span class=\"token keyword\">UPDATE</span> MEMBER\n\t<span class=\"token keyword\">SET</span> \n\t\tNAME<span class=\"token operator\">=</span>?\n\t\tAGE<span class=\"token operator\">=</span>?\n\t\tADDRESS<span class=\"token operator\">=</span>?\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">WHERE</span> \n\t\tID<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"엔티티-삭제\" style=\"position:relative;\"><a href=\"#%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%82%AD%EC%A0%9C\" aria-label=\"엔티티 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엔티티 삭제</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> memberA <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"memberA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nem<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>memberA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>앞선 생성/수정과정과 마찬가지로, 삭제쿼리 역시 쓰기지연 저장소에 추가됩니다.</p>\n<p>영속성 컨텍스트에서 즉시 엔티티가 삭제되고, 삭제쿼리가 플러시되면 데이터베이스에서도 삭제됩니다.</p>\n<h3 id=\"플러시\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9F%AC%EC%8B%9C\" aria-label=\"플러시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플러시</h3>\n<p>플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영합니다.( 동기화 )</p>\n<p><strong>동작과정</strong></p>\n<ul>\n<li>변경감지 동작, 변경된 엔티티에 대해 수정쿼리를 만들어 쓰기지연 저장소에 저장</li>\n<li>쓰기지연 저장소에 쿼리를 데이터베이스에 전달( 여기는 삽입,수정,삭제 쿼리 포함입니다)</li>\n</ul>\n<p><strong>플러시를 일으키는 방법</strong></p>\n<ul>\n<li>직접호출: em.flush()를 통해 직접 플러시를 호출하는 방법 ( 실무에서 잘 쓰지 않습니다)</li>\n<li>트랜잭션 커밋: 플러시 없이 트랜잭션만 커밋하면, 데이터베이스에 변경한 데이터가 반영되지 않고, 서버가 종료되는 등의 상황에서 Durability가 보장되지 않는다.</li>\n<li>JPQL 사용: JPQL은, 뒤에서 다루지만 조회쿼리 시 1차캐시를 사용하지 않고 SQL문으로 변환합니다. 이 경우 1차캐시에 저장된 내용이 누락되므로, flush 이후 JPQL이 수행되어야 합니다.</li>\n</ul>\n<p><strong>플러시 모드 옵션</strong></p>\n<ul>\n<li>FlushModeType.AUTO: 커밋이나 쿼리 실행 시 플러시</li>\n<li>FlushModeType.COMMIT: 커밋 실행시 플러시, 최적화를 위한 옵션입니다.</li>\n</ul>\n<h2 id=\"준영속-상태\" style=\"position:relative;\"><a href=\"#%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C\" aria-label=\"준영속 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>준영속 상태</h2>\n<p>엔티티가 준영속”detached” 상태라는 것은, 영속성 컨텍스트에서 분리되어 관리대상에서 벗어남을 의미하며, 앞서 설명한 영속성 컨텍스트의 기능들을 활용할 수 없음을 의미합니다.</p>\n<p>영속성 컨텍스트에서 분리되는 방법: 준영속 엔티티를 만드는 방법</p>\n<ul>\n<li>em.detach(entity);  → 특정 엔티티만을 준영속상태로 만듦</li>\n<li>em.clear(); → 영속성 컨텍스트를 비워, 내부에 있던 엔티티를 준영속상태로 만듦.</li>\n<li>em.close(); → 엔티티매니저를 닫힘.</li>\n</ul>\n<p>준영속과 비영속은 매우 가까운 상태입니다. 하지만, 준영속 상태는 이미 영속된적이 있는 엔티티로, 식별자 값이 존재합니다.</p>\n<p>또한 준영속 → 영속상태로 가는 동작을 merge라고 합니다. 책에서는 길게 설명하지만, 짧게 요약하자면,</p>\n<p>“merge 와 persist는 매우 비슷하지만, merge는 식별자 값을 제외한 값을 영속성 컨텍스트에 복사 후 리턴한다” 입니다.</p>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저와 엔티티 매니저 팩토리란? 각각의 역할, 특징은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2. 1차캐시의 장점은 무엇인가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  3. 쓰기지연은 무엇이고, 어떤 장점이 있는가?</li>\n</ul>\n<h3 id=\"챕터에-나오지-않지만-알아야하는-부분\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EB%82%98%EC%98%A4%EC%A7%80-%EC%95%8A%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84\" aria-label=\"챕터에 나오지 않지만 알아야하는 부분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 나오지 않지만 알아야하는 부분</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1.엔티티 매니저가 커넥션을 맺는 시점과 끊는 시점</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2.준영속 상태가 되면, 데이터베이스에는 남아있는가?</li>\n</ul>\n<p><strong>복습질문 정답</strong></p>\n<ol>\n<li>\n<p>엔티티 매니저 팩토리는 엔티티 매니저를 생성하는 객체, DB 커넥션 풀을 관리하고,<br>\nJPA의 <strong>엔티티메니저</strong>는 엔티티를 저장/수정/삭제/조회 하는 등, 엔티티와 관련된 많은 일을 처리하는 엔티티 관리자입니다(이름과 같은 역할).<br>\n또한 <strong>영속성 컨텍스트에 엔티티를 저장하면서 캐싱/변경감지/쓰기지연 등, CRUD의 성능을 개선합니다.</strong></p>\n</li>\n<li>\n<p>성능상의 이점과 엔티티 간 동일성을 보장해주는 장점이 있습니다.</p>\n</li>\n<li>\n<p>트랜잭션을 커밋할때까지 엔티티를 1차캐시에 저장해놓고, 쓰기지연 SQL저장소에 쓰기 SQL을 저장해놓는다. 이후 트랜잭션이 커밋되면 flush작업과 함께, 쓰기 SQL을 데이터베이스에 전달하는것을 쓰기지연이라고 하고,</p>\n</li>\n</ol>\n<p><strong>더 알아보기 정답</strong></p>\n<ol>\n<li>엔티티매니저는 데이터가 변경되는 시점에 트랜잭션을 시작합니다.  앤티티메니저의 메서드를 호출 할 때, 트랜잭션 상태가 아니면 <a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/TransactionRequiredException.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TransactionRequiredException</a>을 발생시킵니다.</li>\n<li>데이터베이스에는 남아있지만, 1차캐시에는 존재하지 않는 상태가 됩니다.</li>\n</ol>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n<li><a href=\"https://docs.oracle.com/javaee/7/api/javax/persistence/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle Java Docs(javax.persistence)</a></li>\n</ul>","id":"776bb867-4d09-5c57-9ae5-d6b293e1271d","fields":{"slug":"jpa의-엔티티-매니저와-영속성-관리"},"frontmatter":{"date":"2023-01-03","title":"JPA의 엔티티 매니저와 영속성 관리 ","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":4},{"excerpt":"JPA를 사용하는 이유와 패러다임 불일치 문제 기존 시스템들에서 어떤 방식을 통해 데이터를 접근했는지, 어떤 문제점들이 있었는지 살펴보고, JPA가 이를 어떻게 해결했는지 살펴봅시다. 목차 주제 1.  JPA 등장 배경 SQL을 기반으로 구현했을 때의 문제점 패러다임 불일치 문제 상속,연관관계 참조, 객체그래프 탐색, 비교 불일치 JPA란? JPA의 장점 JPA의 탄생 배경: SQL을 직접 다룰 때 생기는 문제점 JPA…","html":"<h1 id=\"jpa를-사용하는-이유와-패러다임-불일치-문제\" style=\"position:relative;\"><a href=\"#jpa%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%99%80-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"jpa를 사용하는 이유와 패러다임 불일치 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA를 사용하는 이유와 패러다임 불일치 문제</h1>\n<p>기존 시스템들에서 어떤 방식을 통해 데이터를 접근했는지, 어떤 문제점들이 있었는지 살펴보고, JPA가 이를 어떻게 해결했는지 살펴봅시다.</p>\n<h3 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h3>\n<ul>\n<li>주제 1.  JPA 등장 배경\n<ul>\n<li>SQL을 기반으로 구현했을 때의 문제점</li>\n<li>패러다임 불일치 문제\n<ul>\n<li>상속,연관관계 참조, 객체그래프 탐색, 비교 불일치</li>\n</ul>\n</li>\n<li>JPA란? JPA의 장점</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"jpa의-탄생-배경-sql을-직접-다룰-때-생기는-문제점\" style=\"position:relative;\"><a href=\"#jpa%EC%9D%98-%ED%83%84%EC%83%9D-%EB%B0%B0%EA%B2%BD-sql%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%8B%A4%EB%A3%B0-%EB%95%8C-%EC%83%9D%EA%B8%B0%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"jpa의 탄생 배경 sql을 직접 다룰 때 생기는 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA의 탄생 배경: SQL을 직접 다룰 때 생기는 문제점</h1>\n<hr>\n<p>JPA이전 관계형 데이터베이스의 데이터를 가져오기 위해서는 JDBC API를 통해 SQL 쿼리를 직접 날려주는 방식을 사용했습니다. 이는 직관적인것을 떠나 매우 직접적인 방법이고, 여러가지 문제점과 불편함이 존재합니다.</p>\n<h3 id=\"sql에-의존적인-개발\" style=\"position:relative;\"><a href=\"#sql%EC%97%90-%EC%9D%98%EC%A1%B4%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C\" aria-label=\"sql에 의존적인 개발 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL에 의존적인 개발</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> tel<span class=\"token punctuation\">;</span> <span class=\"token comment\">// !! 비즈니스 로직 변경으로 전화번호 필드 추가</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>데이터에서 <strong>하나의 필드(컬럼) 이 추가될 때</strong>, SQL을 직접 매핑해 개발하는 방식에서는 삽입,조회,변경,삭제 시 <strong>많은 코드 변경이 필요합니다.</strong></p>\n<ul>\n<li>생성코드 변경:  SQL 수정 / Prepared Statement에 필드 추가하는 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token string\">\"INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) values(?,?,?);\"</span><span class=\"token punctuation\">;</span>\n''' \npstmt<span class=\"token punctuation\">.</span><span class=\"token function\">setString</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getTel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<ul>\n<li>조회코드 변경 :  SQL수정 / 필드 가져오는 코드 / 필드 설정하는 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token string\">\"SELECT MEMBER_ID, NAME, TEL from MEMBER WHERE MEMBER_ID = ?\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> tel <span class=\"token operator\">=</span> rs<span class=\"token punctuation\">.</span><span class=\"token function\">getString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TEL\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTel</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"XXX\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<ul>\n<li>연관객체 조회: Member가 Team이라는 연관된 데이터를 새로 개발하는 경우, member.getTeam().getTeamName()을 통해 멤버가 속한 팀을 가져오는 마법같은 일은 벌어지지 않습니다. <strong>DAO에서 SQL Join을  통해 다른 테이블을 연결해야 가능합니다.</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> M<span class=\"token punctuation\">.</span>MEMBER_ID<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">.</span>NAME<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">.</span>TEL<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span>TEAM_ID<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span>TEAM_NAME \n\t<span class=\"token keyword\">FROM</span> MEMBER M \n\t<span class=\"token keyword\">JOIN</span> TEAM T <span class=\"token keyword\">ON</span> M<span class=\"token punctuation\">.</span>TEAM_ID <span class=\"token operator\">=</span> T<span class=\"token punctuation\">.</span>TEAM_ID</code></pre></div>\n<p>많은 비즈니스 로직에서 데이터 간 연관관계가 존재하는데, 위같이 SQL에 의존하는 개발을 하는 경우, <strong>진정한 계층 분할이 어렵다</strong>는 문제가 있습니다.</p>\n<p>DAO를 통해 데이터에 접근하는 로직만 분리했을 뿐이지, <strong>필드를 추가할때만 해도 SQL과 CRUD와 관련된 코드를 추가해야하기 때문</strong>입니다. 이때문에 엔티티를 신뢰할 수 없게됩니다.</p>\n<h3 id=\"jpa와-문제-해결\" style=\"position:relative;\"><a href=\"#jpa%EC%99%80-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"jpa와 문제 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA와 문제 해결</h3>\n<p>JPA는 위에서 소개한 문제들을 효율적으로 해결합니다.</p>\n<ul>\n<li>조회기능: 객체의 필드를 바탕으로 SELECT SQL 을 생성하고, 그 결과를 Member객체로 생성해 반환합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"MyeonggGyu Lee\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<ul>\n<li>수정기능: “영속상태”에 있는 엔티티의 변경을 감지해, <strong>트랙잭션이 커밋될 때 Update SQL문을 전달</strong>합니다.\n<ul>\n<li><strong>“변경감지”란</strong> EntityManager에서 <strong>엔티티를 영속할 때 Snapshot을 저장하고 트랜잭션 커밋 시 이와 비교하므로서 변경을 감지하는 동작</strong>이 가능합니다.  (CH3에서 본격적으로 다룬다.)</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Changed_Name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<ul>\n<li>연관객체 조회:  JPA는 연관객체를 조회하는 시점에 적절한 SELECT문을 실행합니다. JPA에서는 단순히 객체그래프를 탐색하는것만으로 수행할 수 있는데, 이를 위해 실제 객체의 참조를 저장하는 프록시를 반환하고, 이를 지연로딩이라 합니다. (H2에서 지연로딩은 프록시와 바이트코드 수정을 통한 방법이 있고, CH8에서 본격적으로 다룬다.)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> teamName<span class=\"token operator\">=</span> team<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"패러다임-불일치-문제\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C\" aria-label=\"패러다임 불일치 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패러다임 불일치 문제</h1>\n<hr>\n<p>관계형 데이터베이스와  객체지향 프로그래밍 언어는 그 목적이 다른만큼 데이터의 기본 단위인 <strong>레코드와 객체의 기능과 표현 방법이 다릅니다</strong>. 따라서, 개발자가 이를 중간에서 해결해주어야 하지만, 이를 일일히 해결하는것은 너무 많은 리소스를 투입해야하는 작업입니다.</p>\n<p>이같은 패러다임 불일치로 생기는 문제 또한 여러가지가 있으며, JPA가 어떤 방법으로 이를 해결하는지 살펴보겠습니다.</p>\n<h2 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h2>\n<p>객체의 경우 상속이라는 기능을 통해 다형성을 제공하지만, 대부분의 데이터베이스는 상속 기능이 없습니다.</p>\n<p>아래 그림과 같이 서브타입과 슈퍼타입을 사용하면 그나마 해결이 가능하지만, 이는 많은 불편함을 초래합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210951775-582b7a16-6641-4a51-862f-11148a8f158b.png\" alt=\"Untitled\"></p>\n<p>위의 경우, 만약 ALBUM 객체를 저장하기 위해서는 두 개의 INSERT문이 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ITEM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span> NAME<span class=\"token punctuation\">,</span> PRICE<span class=\"token punctuation\">,</span> DTYPE<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ALBUM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span>ARTIST<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>만약 데이터베이스를 사용하지 않고 자바 컬렉션(Ex, ArrayList)에 저장한다면, <strong>list.add(album)처럼</strong>  부모 객체에 대해 고려하지 않고도 데이터를 저장할 수 있습니다.</p>\n<p>이처럼 상속으로 인한 자바 객체와 관계형 데이터베이스 사이의 패러다임 불일치문제는 분명히 존재하는것을 알아보았습니다 .</p>\n<p>JPA에 상속하는 객체를 저장하면 상속에 의한 패러다임 불일치문제를 개발자 대신 해결해줍니다.</p>\n<p>JPA의 EntityManager에 객체를 저장하면, ITEM,ALBUM 테이블에 데이터를 각각 나누어 저장합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">jpa<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>album<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ITEM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span> NAME<span class=\"token punctuation\">,</span> PRICE<span class=\"token punctuation\">,</span> DTYPE<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> ALBUM<span class=\"token punctuation\">(</span>ITEM_ID<span class=\"token punctuation\">,</span>ARTIST<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>?<span class=\"token punctuation\">,</span>?<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이후 album 객체를 찾고자 할 때, ITEM, ALBUM 테이블을 조인해서 데이터를 조회하고, 그 결과를 반환합니다 .</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> I<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> \n\t\t<span class=\"token keyword\">FROM</span> ITEM I \n\t\t<span class=\"token keyword\">JOIN</span> ALBUM A <span class=\"token keyword\">ON</span> A<span class=\"token punctuation\">.</span>ITEM_ID <span class=\"token operator\">=</span> I<span class=\"token punctuation\">.</span>ITEM_ID<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"연관관계\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84\" aria-label=\"연관관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연관관계</h3>\n<p><strong>객체는 참조를 통해서 다른 객체와 연관관계를 가지고</strong>, 참조에 접근하면서 연관관계의 객체를 조회합니다.</p>\n<p>반면 관계형 데이터베이스의 테이블은 <strong>외래 키를 통해 다른 테이블과 연관관계를 가지고,</strong> JOIN을 통해 연관된 테이블을 조회합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token class-name\">Team</span> <span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> team<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nmember<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> M<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> \n\t<span class=\"token keyword\">FROM</span> MEMBER M \n\t<span class=\"token keyword\">JOIN</span> TEAM T <span class=\"token keyword\">ON</span> M<span class=\"token punctuation\">.</span>TEAM_ID <span class=\"token operator\">=</span> T<span class=\"token punctuation\">.</span>TEAM_ID</code></pre></div>\n<p>위에서 다룬 상속에서의 패러다임 불일치문제는 서브타입/슈퍼타입을 통해 객체지향적으로 데이터를 다룰 수 있었지만, 연관관계로 인한 패러다임 불일치 문제는 객체지향적으로 풀어내기에 꽤 복잡합니다.</p>\n<p>객체는 다른 연관관계를 조회하고자 할 때, 외래키 대신 참조만 있으면 되고, RDB의 테이블에서는 참조 대신 외래키만 있으면 조회가 가능합니다.</p>\n<p>또한, 객체는 member.getTeam()을 통한 member → team 으로의 단방향 조회만 가능하지만, team에서 member에 대한 참조가 없으므로, team.getMember()을 통한 team → member 조회가 불가능합니다.</p>\n<p>(RDB에서는 외래키를 통해 양방향으로 연관관계를 Join할 수 있습니다)</p>\n<ul>\n<li>저장 시</li>\n</ul>\n<p>(직접구현) 개발자는 객체에서의 연관관계만 지정해주면, team의 참조를 외래키로 변환해 INSERT SQL문을 데이터베이스에 전달합니다.</p>\n<p>(JPA 사용)JPA에서는 이런 연관관계로 인한 패러다임 문제 역시 해결해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njpa<span class=\"token punctuation\">.</span><span class=\"token function\">persist</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njpa<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>조회 시</li>\n</ul>\n<p>(직접구현) 조회시에는 TEAM_ID 외래 키 값을 Member 객체의 team 참조로 변활해 객체로 저장합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Member</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//SQL 실행 후, 멤버 데이터 입력</span>\n\n\t\t<span class=\"token class-name\">Team</span> team <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// team 외래키를 통해 팀 정보 조회 후, 팀 관련 정보 입력</span>\n\n\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">setTeam</span><span class=\"token punctuation\">(</span>team<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//팀 연관관계 생성</span>\n\n\t\t<span class=\"token keyword\">return</span> meber<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(JPA 사용) 마찬가지로  jpa entitymanager를 통해 find하면, 위의 과정을 간단하게 수행할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">.</span> <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getTeam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"객체-그래프-탐색\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89\" aria-label=\"객체 그래프 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 그래프 탐색</h3>\n<p>실제 데이터의 연관관계가 복잡하게 얽혀있는 구조를 생각해보자. 예를 들어 아래와 같다고 해보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/210951768-9a789a7c-579a-4a1b-b571-fa684e3cab82.png\" alt=\"jpabook-48 drawio\"></p>\n<p>만약 DAO를 통해 SQL을 직접 조작한다고 해보자. 아래와 같은 자유로운 객체그래프 탐색이 가능할끼?</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">member<span class=\"token punctuation\">.</span>getOrder<span class=\"token punctuation\">.</span><span class=\"token function\">getOrderItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>get…<span class=\"token punctuation\">.</span></code></pre></div>\n<p>만약 member을 조회하는 기능에서 order까지 참조로 저장하였다면, getOrder까지는 성공할 것이다. 하지만 그 이후부터는 데이터가 존재하지 않으므로 탐색할 수 없다.</p>\n<p>비즈니스 로직에 따라 객체 그래프를 자유롭게 탐색할 수 있어야하지만, DAO내부에서 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지가 정해집니다. 결국 객체 그래프를 탐색할때마다 새로운 메서드와 SQL을 만들어야하는 복잡하고 불편한 상황이 연출됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmemberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMemberWithOrderWithDelivery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>앞서 해결했던 문제들과 달리, 객체 그래프 탐색 문제는 소스코드 몇줄을 추가한다 해서 해결될 수 없습니다.  member와 관련된 모든 객체들을 메모리에 올려놓으면, 엄청난 메모리 낭비가 발생하기 때문이죠.</p>\n<p>JPA는 실제 객체 사용 시점까지 데이터베이스 조회를 미루는 <strong>지연로딩</strong>을 통해 해당 문제를 해결합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Member</span> member <span class=\"token operator\">=</span> jpa<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Order</span> order <span class=\"token operator\">=</span> member<span class=\"token punctuation\">.</span><span class=\"token function\">getOrder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\norder<span class=\"token punctuation\">.</span><span class=\"token function\">gerOrderDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Order객체를 사용하는 시점에 SELECE Order 쿼리를 날림. </span></code></pre></div>\n<h3 id=\"비교-불일치\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%90-%EB%B6%88%EC%9D%BC%EC%B9%98\" aria-label=\"비교 불일치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비교 불일치</h3>\n<p>데이터베이스에서는 기본 키(PK)를 통해 데이터를 비교합니다. 반면 객체는 동일성과 동등성을 통해 데이터를 비교합니다.</p>\n<p><strong>동일성</strong> 비교는 “==”을 통해 비교합니다. 객체의 주소값을 비교하는 비교방법입니다.</p>\n<p><strong>동등성</strong> 비교는 “equals()”메서드를 통해 비교합니다.  객체 내부 값을 비교합니다.</p>\n<p>SQL을 통해 Java에서 데이터베이스 레코드를 여러 번 불러왔을 때, 비교과정에 대해 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> memberId <span class=\"token operator\">=</span> <span class=\"token string\">\"12\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> m1 <span class=\"token operator\">=</span> memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Member</span> m2 <span class=\"token operator\">=</span> memberDAO<span class=\"token punctuation\">.</span><span class=\"token function\">getMember</span><span class=\"token punctuation\">(</span>memberId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>m1 <span class=\"token operator\">==</span> m2<span class=\"token punctuation\">)</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Equal\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not Equal\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ouput : Not Equal</span></code></pre></div>\n<p>m1과 m2는 같은 member id를 통해 조회했으므로 그 내용은 같겠지만, 동일한 객체는 아닙니다. equals메서드를 통해 내용만 비교하면 되지 않나 라는 생각을 할 수 있지만, 만약 두 객체가 다른 스레드에서 각각 생성되고, 변경된다고 가정하면, 예상하지 않은 결과를 가져올 것입니다.</p>\n<p>JPA에서는 같은 트랜잭션일 때, 같은 객체가 조회되는 것을 보장한다. 이는 엔티티메니저의 식별자를 통해 가능하다.</p>\n<h1 id=\"jpa란-무엇인가\" style=\"position:relative;\"><a href=\"#jpa%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"jpa란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA란 무엇인가</h1>\n<p>Java Persistence API의 약자로, 자바 진영의 ORM 기술.</p>\n<h3 id=\"orm이란\" style=\"position:relative;\"><a href=\"#orm%EC%9D%B4%EB%9E%80\" aria-label=\"orm이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ORM이란?</h3>\n<p>Object Relational Mapping으로, 객체와 관계형 데이터베이스를 매핑하는 기술로, 앞서 설명했던 패러다임 불일치 문제를 해결해준다.</p>\n<h3 id=\"jpa를-사용해야하는-이유\" style=\"position:relative;\"><a href=\"#jpa%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"jpa를 사용해야하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JPA를 사용해야하는 이유?</h3>\n<ul>\n<li><strong>생산성</strong>: JPA를 사용하면 자바 컬렉션 객체에 저장하듯 엔티티메니저에 저장하면, JDBC API를 사용하는 반복적인 SQL 작성은 JPA가 대신 처리해준다</li>\n<li><strong>유지보수성</strong>: SQL을 직접 매핑하면 필드가 추가될 때마다 많은 양의 코드가 추가되었지만, JPA에서는 필드가 추가/삭제되더라도 변경되는 코드가 줄어든다.</li>\n<li><strong>패러다임 불일치 해결</strong>: 앞서 살펴본 상속, 연관관계, 객체그래프 탐색, 비교 불일치 등으로 인한 패러다임 불일치 문제를 해결해준다</li>\n<li><strong>성능:</strong> 엔티티메니저의 1차캐시는 앞서 살펴본것같이 동일성을 보장해주기도 하지만, 캐시의 역할과 쓰기지연 저장소 역할도 수행한다.</li>\n<li><strong>벤더 독립성:</strong> 데이터베이스는 같은 기능이어도 벤더마다 사용법이 다른 경우가 많다. JPA는 다른 데이터베이스 벤더들을 하나로 통합한 방언(Dialect)을 제공해 데이터베이스 기술을 추상화하고, 특정 기술에 종속되지 않도록 한다.</li>\n</ul>\n<hr>\n<h3 id=\"복습질문\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%8A%B5%EC%A7%88%EB%AC%B8\" aria-label=\"복습질문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복습질문</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  1. SQL을 직접 다뤄서 생기는 문제점에는 어떤것이 있는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  2. 객체지향 프로그래밍과 관계형 데이터베이스의 데이터의 패러다임 불일치에는 어떤 문제들이 있는가?</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled>  3.JPA를 사용해 얻을 수 있는 이점은 무엇인가?</li>\n</ul>\n<h3 id=\"챕터에-나오지-않지만-알아야하는-부분들\" style=\"position:relative;\"><a href=\"#%EC%B1%95%ED%84%B0%EC%97%90-%EB%82%98%EC%98%A4%EC%A7%80-%EC%95%8A%EC%A7%80%EB%A7%8C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EB%93%A4\" aria-label=\"챕터에 나오지 않지만 알아야하는 부분들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>챕터에 나오지 않지만 알아야하는 부분들</h3>\n<ul class=\"contains-task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  1. member.setName()만으로 데이터를 수정할 수 있는 개념인 “변경감지” 란 무엇인가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  2.member.getTeam()을 통해 연관객체를 불러올 수 있는 원리는 무엇인가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  3.JPA 구현체인 H2에서는 지연로딩을 구현하는 방법으로 무엇들이 있는가?</p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" disabled>  4.JPA에서 같은 레코드에 대한 동일성을 보장하는 방법은 무엇인가?</p>\n<p>정답</p>\n<ol>\n<li>\n<p>패러다임 불일치 문제 → 계층분할 힘듦 → 코드 작업량 증가,</p>\n</li>\n<li>\n<p>상속, 연관관계 참조, 객체그래프 탐색,  비교 방법 불일치 문제</p>\n</li>\n<li>\n<p>생산성,유지보수, 성능, 벤더 독립성</p>\n</li>\n<li>\n<p>엔티티매니저에서 객체 영속 시 스냅샷을 저장하고,commit, JPQL등으로 인한 커밋 시, 스냅샷과 엔티티를 비교하는 방법</p>\n</li>\n<li>\n<p>지연로딩. 프록시객체를 가지고있다가 해당 객체가 사용되는 시점에 SQL 실행</p>\n</li>\n<li>\n<p>바이트코드 수정, 프록시</p>\n</li>\n<li>\n<p>엔티티매니저 1차캐시에 식별자 비교를 통해서 동일성 보장</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"referecnce\" style=\"position:relative;\"><a href=\"#referecnce\" aria-label=\"referecnce permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Referecnce</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/90439472\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>","id":"a30b6231-38b0-55d3-a1ec-a7ac7a7bf4ff","fields":{"slug":"패러다임-불일치-문제와-jpa를-사용하는-이유"},"frontmatter":{"date":"2022-12-19","title":"패러다임 불일치 문제와 JPA를 사용하는 이유 ","category":"tech","tags":["JPA","JPA 스터디"],"banner":null},"timeToRead":5},{"excerpt":"본 글은  Link: Spring 공식문서에서 1절을 읽고 궁금한점을 찾아보며 정리한 글입니다. 1.1  Introduction to the Spring IoC Container and Beans 1.2  Container Overview 1.3  Bean Overview ...and so on Spring IoC Container와 ApplicationContext IoC, Inversion of Control…","html":"<p>본 글은  <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Link: Spring 공식문서에서 1절</a>을 읽고 궁금한점을 찾아보며 정리한 글입니다.</p>\n<ul>\n<li>1.1  Introduction to the Spring IoC Container and Beans</li>\n<li>1.2  Container Overview</li>\n<li>1.3  Bean Overview</li>\n</ul>\n<p>...and so on</p>\n<h1 id=\"spring-ioc-container와-applicationcontext\" style=\"position:relative;\"><a href=\"#spring-ioc-container%EC%99%80-applicationcontext\" aria-label=\"spring ioc container와 applicationcontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring IoC Container와 ApplicationContext</h1>\n<p>IoC, Inversion of Control은 직역하면 제어의 역전이라는 뜻을 가지고있으며, Spring의 주요 특징 중 하나입니다.</p>\n<p>IoC의 예시로, Dependency Injection(DI)를 들 수 있는데요, 런타임 시점의 의존관계는 의존 대상 인스턴스가 아니라 컨테이너나 팩토리가 결정하며, 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않기 때문에,  (DI의 경우) 의존성 설정에 대한 제어권이 역전된 모습이라 해 제어의 역전이라고 합니다.</p>\n<p><code class=\"language-text\">org.springframework.beans</code> 와 <code class=\"language-text\">org.springframework.context</code> 패키지는 Spring IoC컨테이너의 근간이 되는 패키지입니다.<br>\n그 중에서도, <code class=\"language-text\">org.springframework.beans.factory</code>패키지의 <code class=\"language-text\">BeanFactory</code> 인터페이스는 모든 타입의 객체에 고급 설정을 구성할 수 있는 메커니즘을 제공합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/202149288-44e3789f-9fd7-4eaf-b5d3-4221be5c9e3d.png\" alt=\"IoCContainer drawio (1)\"></p>\n<p><code class=\"language-text\">BeanFactory</code> 의 하위 인터페이스인 <code class=\"language-text\">ApplicationContext</code>가 제공하는 기능입니다.</p>\n<ul>\n<li>\n<p>Spring AOP 통합</p>\n</li>\n<li>\n<p>메시지 리소스 국제화</p>\n</li>\n<li>\n<p>이벤트 생성</p>\n</li>\n<li>\n<p><code class=\"language-text\">WebApplicationContext</code>같은 애플리케이션 레이어 컨텍스트 제공</p>\n</li>\n</ul>\n<p>간단히 말하자면, <code class=\"language-text\">BeanFactory</code> 는 Spring 기본 기능과 설정 기능을 제공하고, <code class=\"language-text\">ApplicationContext</code>는 enterprise application에 특화된 기능을 제공합니다. <code class=\"language-text\">ApplicationContext</code>가 기능적으로 <code class=\"language-text\">BeanFactory</code>를 모두 포함하기때문에, 위에서 설명한 추가기능을 사용하기 위해서 기본적으로 <code class=\"language-text\">ApplicationContext</code>를 사용하는게 좋습니다.</p>\n<p>Spring에서는 애플리케이션의 중추를 담당하고 IoC컨테이너가 관리하는 객체를 빈(bean)이라고 합니다. 빈은 애플리케이션의 일반적인 객체와 달리, IoC 컨테이너에 의해 조합되거나 관리되는 객체이고, 컨테이너가 사용하는 설정 메타데이터에 의해 반영됩니다. (groovy script, xml파일이나 annotation 등)</p>\n<h1 id=\"ioc-container에-대해서\" style=\"position:relative;\"><a href=\"#ioc-container%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"ioc container에 대해서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IoC Container에 대해서</h1>\n<p><code class=\"language-text\">org.springframework.context.ApplicationContext</code> 인터페이스는 스프링의 IoC 컨테이너를 나타내고, 빈의 인스턴스화, 설정, 조합(instantiating, configuring, assembling)을 담당합니다. 즉, (IoC)컨테이너는 설정 메타정보를 읽으며 어떤 객체를 인스턴스화할지, 설정할지, 조합할지에 대한 명령어를 읽어들입니다. 설정 메타데이터는 XML, Java annotations, Java code에 존재합니다.</p>\n<p>기존에 많은 경우에 XML을 통해 설정을 해왔지만, XML 코드를 추가해 Java annotation을 통해 설정할 수 있도록 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>context</span> <span class=\"token attr-name\">:</span> <span class=\"token attr-name\">component-scan</span> <span class=\"token attr-name\">base-package</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.sample<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n</code></pre></div>\n<p>위와같은 설정파일을 추가하면 <code class=\"language-text\">@Component, @Repository, @Service, @Controller, @RestController, @Configuration</code>를 base-package에서 찾아 빈으로 등록합니다.</p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/container-magic.png\" alt=\"img\"></p>\n<p>위 그림은 IoC 컨테이너가 어떤 동작을 하는지에 대한 간단한 과정입니다. 컨테이너는 비즈니스 로직을 포함한 POJO 객체와 설정 메타데이터를 로드해 실행가능한 애플리케이션을 생산해냅니다.</p>\n<p>이때, Business Object뒤에 POJO 객체라고 정확히 지칭한부분이 재미있습니다. 직접 의존성을 로드해 개발했을 때 객체가 무거워지고 결합도가 높아지는 단점이 생겼고, 의존성 라이브러리를 결합해서 사용할 수 있도록 IoC의 개념 중 하나인 DI가 생겨났기 때문입니다. POJO라고 특정지어서 말하는 부분은 이 부분을 강조하는듯 합니다.</p>\n<p>단적인 예로, 이전에는 JDBC드라이버를 직접 로드해서 커넥션을 맺고 끊는 로직을 직접 구현했다면, 최근에는 JPA나 MyBatis등의 라이브러리, 심지어 JDBC API까지도 XML설정 또는 애너테이션을 통해 DAO 빈을 생성하면 POJO만으로도 비즈니스 로직을 구현해낼 수 있게 되었고, 결합도가 낮아져 리팩토링이나 확장에 들어가는 작업량이 현저히 줄었습니다.</p>\n<h3 id=\"configuration-metadata\" style=\"position:relative;\"><a href=\"#configuration-metadata\" aria-label=\"configuration metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Configuration Metadata</h3>\n<p>그림에서 컨테이너가 설정 메타데이터를 사용하는 부분을 확인했습니다. 설정 메타데이터는 컨테이너에게 Bean이 무엇이고 어떻게 인스턴스화하고 조립할지에 대해 알려주는 정보입니다. 이 정보를 쓰는 방법을 간단하게만 알아보겠습니다.</p>\n<blockquote>\n<p>참고로, 스프링 설정 메타데이터를 작성하는 방법은 몇가지가 있으나, 작성하는 포멧 형식은 컨테이너와 분할되어있으므로, 어떤 형식으로 작성하는지는 중요하지 않습니다.</p>\n</blockquote>\n<ul>\n<li>XML: <code class=\"language-text\">beans</code>라는 루트 엘리먼트 하위에 <code class=\"language-text\">bean</code> 엘리먼트를 선언하는 방식</li>\n<li>Java: <code class=\"language-text\">@Configuration</code> 애너테이션을 가진 클래스 하위에 <code class=\"language-text\">@Bean</code>애너테이션을 가진 메서드를 선언하는 방식</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span><span class=\"token punctuation\">></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>services.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>resources/messageSource.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/resources/themeSource.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bean1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bean2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\r\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>일반적인 XML설정 메타데이터는 위와 같이 구성합니다. bean의 id에는 빈을 유일하게 식별할 수 있는 id, class에는 빈에 해당하는 클래스명을 패키지까지 포함해 작성합니다.</p>\n<p>import를 통해 다른 파일의 설정을 불러올 수 있습니다. resource, 경로에 해당하는 부분은 가급적 상대경로를 포함하지 않습니다. (애플리케이션 외부에 종속성이 생길 수 있기 때문)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathXmlApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"services.xml\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"daos.xml\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token class-name\">PetStoreService</span> service <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"petStore\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">PetStoreService</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> userList <span class=\"token operator\">=</span> service<span class=\"token punctuation\">.</span><span class=\"token function\">getUsernameList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 앞서 언급했듯 빈들은 BeanFactory를 상속한 <code class=\"language-text\">ApplicationContext</code>에 의해 관리되므로, 위같은 방법으로  인스턴스화된 빈들을 가져올 수 있습니다. 하지만 비즈니스로직에서 이같이 선언적 방법으로 빈을 로드하는것은 권장하지 않는 방법입니다.</p>\n<h1 id=\"bean에-대해서\" style=\"position:relative;\"><a href=\"#bean%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C\" aria-label=\"bean에 대해서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean에 대해서</h1>\n<p>아래 내용은 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">1.3 Bean Overview</a> 및 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">1.The IoC Container</a>에서 원문으로 확인할 수 있습니다.</p>\n<h3 id=\"bean의-생성과정\" style=\"position:relative;\"><a href=\"#bean%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC%EC%A0%95\" aria-label=\"bean의 생성과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean의 생성과정</h3>\n<ul>\n<li>\n<p>Bean을 생성하기 위해 [XML,Java,Groovy]로 이뤄진 Configuration Metadata(설정 메타데이터)를 작성합니다.</p>\n</li>\n<li>\n<p>컨테이너는 설정 메타데이터를 통해 <code class=\"language-text\">패키지가 포함된 클래스명</code> <code class=\"language-text\">동작 구성요소(생명주기, 콜백,스코프 등)</code> <code class=\"language-text\">다른 Bean 의존성</code>, <code class=\"language-text\">Bean 설정(property)</code>를 <code class=\"language-text\">XML,Java,Groovy BeanDefinitionReader</code>를 통해 <code class=\"language-text\">BeanDefinition</code>으로 구성합니다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">BeanDefinition은</code> 아래와 같은 정보를 포함하게 되며, 결과적으로 컨테이너는 설정파일을 어떤 형식으로 구성해도 <code class=\"language-text\">BeanDefinition</code>이라는 일관된 객체를 불러올 수 있습니다. 공식문서에서는 BeanDefinition객체를 '레시피'라고 표현합니다. 여러개의 Bean 인스턴스를 생성해도 같은 객체를 생성할 수 있도록 합니다.</p>\n</li>\n</ul>\n<h3 id=\"beandefinition의-구성요소와-bean의-특징\" style=\"position:relative;\"><a href=\"#beandefinition%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C%EC%99%80-bean%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"beandefinition의 구성요소와 bean의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BeanDefinition의 구성요소와 Bean의 특징</h3>\n<ul>\n<li>\n<p>Class: 인스턴스화할 빈 클래스. Java Config의 경우 Return Class의 패키지경로+클래스이름, XML Config의 경우 class 프로퍼티로 자동 지정되며, 필수값입니다.</p>\n</li>\n<li>\n<p>Name: Bean을 하나로 구분할 수 있도록 하는 식별자. XML의 경우 id, name프로퍼티를 사용해 IoC Container가 지정합니다. Java의 경우, @Bean프로퍼티가 붙은 메서드의 이름으로 지정됩니다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//(Class, Id, Name 적용 예시)</span>\r\n<span class=\"token annotation punctuation\">@Configuration</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppConfig</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token annotation punctuation\">@Bean</span>\r\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CouponService</span> <span class=\"token function\">couponService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CouponService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span><span class=\"token punctuation\">></span></span>\r\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>couponService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.demo.service.CouponService<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\r\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>\n<p>Scope: singleton, prototype, session, request 등 Bean을 생성하는 방법과 생명주기에 관련된 요소입니다.</p>\n</li>\n<li>\n<p>Constructor arguments: 생성자 인자들입니다. 생성자를 통해서 Bean 의존성을 설정할 수 있습니다.</p>\n</li>\n<li>\n<p>Properties: Bean에 저장되는 속성값입니다.(JDBC의 경우 max-pool등의 것들)</p>\n</li>\n<li>\n<p>Autowiring mode:</p>\n</li>\n<li>\n<p>Late initialization mode</p>\n</li>\n<li>\n<p>Initialization method</p>\n</li>\n<li>\n<p>Destruction  method</p>\n</li>\n</ul>\n<h3 id=\"bean-의-scope\" style=\"position:relative;\"><a href=\"#bean-%EC%9D%98-scope\" aria-label=\"bean 의 scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bean 의 scope</h3>\n<p>앞서 말했듯, scope는 Bean의 생성방법이나 생명주기를 나타내는 요소입니다. BeanDefinition에서 scope라는 구성을 제공하므로서 Bean을 생성하고 Java Class계층에서 자신의 생성방법을 정의하지 않아도 되고, 생성/소멸에 관련된 부분에 대해 이미 정해진 방법으로 동작할 수 있도록 합니다.</p>\n<p><code class=\"language-text\">singleton</code>: 기본값이며, 하나의 빈 인스턴스가 공유됩니다. 컨테이너는 여러번의 생성 요청에도 하나의 특정 빈 인스턴스만을 리턴하기때문에, 하나의 BeanDefinition에 하나의 Bean 인스턴스를 갖습니다.</p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/current/reference/html/images/singleton.png\" alt=\"img_singleton\"></p>\n<p><code class=\"language-text\">prototype</code>: 싱글톤과 달리, 모든 요청에 대해 Bean을 인스턴스화하므로, == 연산자 비교(레퍼런스 비교) 시 false를 반환합니다. <strong>또한 prototype으로 생성된 bean instance들은 spring container의 관리대상이 아니므로, 사용을 완료한 prototype bean은 직접 자원을 해제하거나 lifecycle callback등을 이용해 자원을 해제해야 합니다.</strong></p>\n<p><img src=\"https://docs.spring.io/spring-framework/docs/6.0.3-SNAPSHOT/reference/html/images/prototype.png\" alt=\"img_prototype\"></p>\n<p>&#x3C;Singleton과 Prototype Bean 비교></p>\n<p>JPA같이 EntityManager를 통해 데이터를 관리하는 경우, 이를 prototype bean으로 설정하는 경우, 매번 새로운 EM을 반환합니다. 이런 경우, singleton으로 빈을 생성해야 합니다.</p>\n<p>유저 정보를 저장하는 Bean이 있다고 가정하면, singleton으로 생성하는 경우 동시성 문제 또는 초기화 문제로 잘못된 데이터를 사용할 걱정이 있습니다. 이런 경우 prototype 빈을 생성해야 합니다.</p>\n<p>아래의 request, session, application, socket scope는 Spring framework의 ApplicationContext아래에서만 사용할 수 있는 scope입니다.</p>\n<p><code class=\"language-text\">request</code>: HTTP 단일 요청과 같은 생명주기를 갖는 BeanDefinition. 각각의 요청이 하나의 Bean 인스턴스를 갖게됩니다.</p>\n<p><code class=\"language-text\">session</code>: HTTP Session과 같은 생명주기를 갖습니다.</p>\n<p><code class=\"language-text\">application</code>: ServletContext와 같은 생명주기를 갖습니다.</p>\n<p><code class=\"language-text\">websocket</code>: Websocket과 같은 생명주기를 갖습니다.</p>\n<h1 id=\"후기\" style=\"position:relative;\"><a href=\"#%ED%9B%84%EA%B8%B0\" aria-label=\"후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>후기</h1>\n<p>Spring은 추상화가 정말 잘 되어있는 프레임워크라 개인적으로 공부할때 의문이 생기는게 많았는데, 오히려 자세히 설명된 글을 읽으니까 더 재밌네요. 다음으론 추상화 끝판왕 AOP부분에 대해 살펴볼듯 싶습니다.</p>\n<p>Spring의 IoC, Bean을 공부하며 이 개념으로 뭔갈 할 수 있겠다 라는 생각보다는 이미 숨쉬듯 사용하던 코드들이\r\n내부적으로 어떻게 동작하는지 공부한 느낌이었습니다! Bean과 관련된 에러는 이제 조금 친숙하지 않을까 생각합니다.</p>","id":"b2b57dbe-180b-5d8f-9ef1-c9a464946168","fields":{"slug":"spring-framework의-io-c와-bean이란"},"frontmatter":{"date":"2022-11-17","title":"Spring Framework의 IoC와 Bean이란","category":"tech","tags":["spring framework","IoC","Bean"],"banner":null},"timeToRead":4},{"excerpt":"데이터베이스 인덱스 데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다. Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다. Clustered Index…","html":"<h1 id=\"데이터베이스-인덱스\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"데이터베이스 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터베이스 인덱스</h1>\n<p>데이터베이스에서 인덱스란, 자료에 빠르게 접근하기 위해서 존재하는 데이터베이스 자료구조입니다. Index는 한국말로 색인,목차라는 의미를 가지는데, 두거운 책에서 원하는 내용을 찾기 위해 목차를 찾는것과 비슷하게 동작합니다.</p>\n<p>Index는 원하는 자료를 빠르게 찾기 위해서 여러 방법으로 구현할 수 있지만, 가장 많이 사용되는 MySQL의 InnoDB 기준으로 설명해보도록 하겠습니다.</p>\n<h1 id=\"clustered-index\" style=\"position:relative;\"><a href=\"#clustered-index\" aria-label=\"clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clustered Index</h1>\n<p>Clustered Index는, Primary Key에 주로 사용되며 실제 데이터가 정렬된 상태로 존재합니다. 어떤 칼럼을 Clustered Index Key로 지정하는 경우 하나의 키만이 Clustered Index Key로 지정될 수 있으며, 지정 시 모든 데이터를 정렬해야하므로 많은 시간이 필요합니다.</p>\n<h3 id=\"인덱스-구조\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0\" aria-label=\"인덱스 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777748-1cdb21e0-8f9d-4220-b542-583272432b22.png\" alt=\"Clustered Index drawio\"></p>\n<p>클러스터드 인덱스의 경우 인덱스 키값과 데이터페이지 주소가 저장되며, 두 번의 페이지 조회만에 데이터를 찾을 수 있습니다.</p>\n<h1 id=\"non-clustered-index\" style=\"position:relative;\"><a href=\"#non-clustered-index\" aria-label=\"non clustered index permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non Clustered Index</h1>\n<p>InnoDB는 B+Tree 자료구조를 통해 인덱스 데이터를 관리합니다. B+Tree는 자식이 2개 이상인 m-ary 균형(Balanced) 트리입니다.</p>\n<ul>\n<li>N개 데이터에 대한 조회에 O(Log(N))의 시간복잡도를 가집니다. 이는 데이터가 일정수준 이상일 때, Full Scan 방식인 O(N)에 비해 월등히 빠른 속도입니다.</li>\n<li>삽입,삭제는 인덱스 트리에 대한 수정과 더불어 , 불균형 있는 경우 Rebalancing과정까지 추가되어 인덱스를 적용하기 전보다 느려집니다. 이는 B+Tree가 깊이를 일정하게 하기 위한 rebalancing과정에서 소요되는 시간입니다.</li>\n<li>인덱스 트리를 저장하기 위해 전체 데이터의 10%정도에 해당하는 추가 저장공간을 사용합니다.</li>\n</ul>\n<h3 id=\"인덱스-구조-1\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B5%AC%EC%A1%B0-1\" aria-label=\"인덱스 구조 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 구조</h3>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/200777762-504433d0-48d2-4609-9bb4-a3f1a580f9ea.png\" alt=\"Non Clustered Index drawio\"></p>\n<p>트리의 루트 및 브랜치 노드에는 키값과 인덱스 페이지의 주소가 담겨있고, 인덱스 키값으로 정렬된 모습을 확인할 수 있습니다.<br>\n트리의 리프 노드에는 키값과 데이터 페이지의 주소와 슬롯이 담겨있어 루트노드에서 리프노드까지 트리를 탐색하며 키에 해당하는 데이터를 가져올 수 있습니다.<br>\n(<em>추가적으로, 부모/자식노드간 키가 중복으로 들어가며, 리프노드들이 링크드 리스트 형태로 연결되었다는 특징이 있습니다. InnoDB는 여기서 조금 더 발전해 같은 레벨의 노드들이 더블 링크드 리스트로 연결되어 있습니다.)</em></p>\n<h2 id=\"페이지란\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80%EB%9E%80\" aria-label=\"페이지란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지란?</h2>\n<p>데이터베이스는 디스크에 페이지라는 단위로 데이터를 저장합니다. InnoDB에서는 16KB로 고정된 크기를 가지기 때문에, 인덱스를 구성하는 키가 커질수록 페이지에 저장할 수 있는 키가 적어지고, B+Tree의 깊이가 깊어져 성능 저하를 가져오게 됩니다.</p>\n<p>극단적으로 말했을 때, 페이지 주소가 12Byte이고 Varchar(1024)인 1KB 사이즈의 게시글 내용을 인덱스 키로 지정한다면,<br>\n한 페이지에 (16 * 1024) / (12 + 1024) = 15.xx로, 15개의 키밖에 저장할 수 없습니다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Database_index#Index_concurrency_control\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">위키피디아 https://en.wikipedia.org/wiki/Database_index</a></p>\n<p><a href=\"https://jojoldu.tistory.com/m/243\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">향로님 블로그</a></p>\n<p><a href=\"https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#B-Tree_%EC%9D%B8%EB%8D%B1%EC%8A%A4_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">인파님 블로그, 인덱스 총정리</a></p>","id":"f0da8866-3059-5999-9f12-9ad8bbfb644a","fields":{"slug":"데이터베이스-인덱스"},"frontmatter":{"date":"2022-10-17","title":"데이터베이스 인덱스","category":"tech","tags":["computerscience","database","index"],"banner":null},"timeToRead":1},{"excerpt":"운영체제 Heap 메모리 영역에 접근해 사용하지 않는 Object를 정리해주는 JVM의 구성요소입니다. 개발자가 직접적으로 메모리 해제를 C/C++과 달리, JVM에서는 GC를 제공해 개발에만 집중하고, Memory Leak을 신경쓰지 않아도 됩니다.  JVM은 다음과 같은 구성요소가 존재합니다. 실행엔진 : 자바 인터프리터(interpreter) ,JIT 컴파일러(Just-In Time compiler) 클래스 로더(class loader…","html":"<p>운영체제 Heap 메모리 영역에 접근해 <strong>사용하지 않는 Object를 정리</strong>해주는 JVM의 구성요소입니다. 개발자가 직접적으로 메모리 해제를 C/C++과 달리, JVM에서는 GC를 제공해 개발에만 집중하고, Memory Leak을 신경쓰지 않아도 됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/205865221-357f520b-465f-4c5f-a80c-a78a53707ac8.png\" alt=\"\"></p>\n<blockquote>\n<p>JVM은 다음과 같은 구성요소가 존재합니다.</p>\n</blockquote>\n<ul>\n<li>실행엔진 : 자바 인터프리터(interpreter) ,JIT 컴파일러(Just-In Time compiler)</li>\n<li>클래스 로더(class loader)</li>\n<li>Runtime Data Area(Heap, Stack, 등등 실행데이터)</li>\n<li><strong>가비지 컬렉터(garbage collector)</strong>  (오늘 알아볼 내용)</li>\n</ul>\n<h1 id=\"gc의-동작-과정\" style=\"position:relative;\"><a href=\"#gc%EC%9D%98-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"gc의 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC의 동작 과정</h1>\n<p>대부분의 객체는 생성되고 얼마되지 않아 Unreachable Object가 됩니다. JVM에서 Heap에 Object를 적재할 때, 생성시기와 생존기간을 고려해 크게 <strong>Young Generation, Old Generation</strong>으로 구역을 나누어, GC를 위한 데이터 접근을 효율적으로 수행합니다.</p>\n<blockquote>\n<p>Unreachable Object: 메서드가 종료되거나 참조가 사라져 사용할 수 없는 객체.</p>\n</blockquote>\n<p>또한, JVM을 설계할 때, 객체는 금방 Unreachable 상태가 된다는 것을 가정하고 시작하므로 Young Geneartion 영역이 Old Generation 영역보다 작고, GC도 더 자주 수행됩니다.</p>\n<p>YG,OG영역에서 수행되는 GC를 각각 Minor GC, Major GC 라고 하며 수행방법또한 차이가 있지만, 모두 <strong>Stop-the-world, Mark&#x26;Sweep동작</strong>이 기본이 됩니다.</p>\n<h3 id=\"stop-the-world동작은\" style=\"position:relative;\"><a href=\"#stop-the-world%EB%8F%99%EC%9E%91%EC%9D%80\" aria-label=\"stop the world동작은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Stop the world</strong>동작은</h3>\n<hr>\n<p><strong>Stop the world</strong>동작은 GC를 수행하는 스레드를 제외한 모든 스레드를 중지하면서 GC과정을 Thread-safe하게 수행하도록 하는 과정입니다.</p>\n<h3 id=\"mark--sweep동작은\" style=\"position:relative;\"><a href=\"#mark--sweep%EB%8F%99%EC%9E%91%EC%9D%80\" aria-label=\"mark  sweep동작은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Mark &#x26; Sweep</strong>동작은</h3>\n<hr>\n<p><strong>Mark &#x26; Sweep</strong>동작은, 전역변수와 현재 scope의 로컬 변수를 루트로 시작해 참조하고 있는 Object를 탐색하며 mark bit를 true로 변경해줍니다.</p>\n<p>이후 Mark되지 않은 Object(회색부분)를 삭제해주며, GC과정을 수행합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192480693-1eaf6928-40bb-43e1-8d12-a7159829dd2e.png\" alt=\"GC drawio (6)\"></p>\n<ul>\n<li>\n<p>이 때, 메모리에서 데이터가 부분적으로 존재하는 파편화 문제가 발생하며, Compaction 알고리즘을 통해 이를 해결합니다.</p>\n</li>\n</ul>\n<h2 id=\"young-generation과-minor-gc\" style=\"position:relative;\"><a href=\"#young-generation%EA%B3%BC-minor-gc\" aria-label=\"young generation과 minor gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young Generation과 Minor GC</h2>\n<hr>\n<p>Young Generation(YG)영역의 경우, 처음 생성한 객체를 저장하는 Eden영역과, Eden영역에서 살아남은 객체가 저장되는 Survival영역이 두 개 존재합니다.\n동적으로 할당된 메모리 영역(Heap)에서 <strong>Unreachable Object를</strong> 찾아 삭제하는 역할 수행합니다.</p>\n<h3 id=\"기본-프로세스\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"기본 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 프로세스</h3>\n<ol>\n<li>새로 생성된 객체들이 YG의 Eden영역에 할당되고, 곧 가득 찹니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445234-d42612cd-6d71-4b67-bb1b-85ae5ef0c53b.png\" alt=\"GC drawio\">\n<br></p>\n<ol start=\"2\">\n<li>Eden영역이 가득 찼으면, Minor GC를 수행합니다. 그 결과 , Eden에서 살아남은 Object가 Survival1에 위치합니다. 이 때부터, Object는 Age라는 변수를 가지며, <strong>자신의 생존 기간을 기록합니다.</strong></li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445223-b080df35-f96d-41f3-8a7b-37b9e245949f.png\" alt=\"GC drawio (1)\">\n<br></p>\n<ol start=\"3\">\n<li>또 다시 Eden 영역이 가득 찼습니다. 이번에는 Eden영역과 Survival0영역에도 Object가 있으므로, 이에 대해 Minor GC를 수행합니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192445232-b81745cd-bdaf-40a6-b405-37715a2b69db.png\" alt=\"GC drawio (2)\">\n<br></p>\n<ol start=\"4\">\n<li>Eden영역과 Survival0영역에서 살아남은 Object는 Survival1영역으로 이동합니다.</li>\n</ol>\n<p>Survival0,1 두 개의 영역은 서로의 역할을 번갈아가며 3번과 4번 과정이 여러번 반복됩니다. 이때, Eden영역에서 살아남은 Object는 Age값이 초기값이지만, Survival0(또는 1) 영역의 객체들은 살아남은 기간만큼의 Age값을 갖습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192446180-d9496029-1f76-4dd2-95a0-82143bde39fe.png\" alt=\"GC drawio (4)\"></p>\n<!-- ![GC drawio (3)](https://user-images.githubusercontent.com/30853787/192445233-4de84416-ccba-45e6-9cab-0264da936c57.png) -->\n<br>\n<ol start=\"5\">\n<li>Survival0(또는 1)영역에서, JVM에 설정된 Max age값에 도달한 객체가 있다면, Old Generation영역으로 이동합니다. 이를 Promotion이라고 합니다.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/30853787/192446711-9e79557e-c7b1-4fc0-a920-674e26812e44.png\" alt=\"GC drawio (5)\"></p>\n<ul>\n<li>추가적으로, YGd에서의 MinorGC에서 Mark되지 않은 Object를 OG영역이 참조할 경우, OG영역이 YG영역을 참조할 때마다 카드 테이블에 정보를 기록해, OG에서 YG로의 참조를 기록합니다. 이를 통해 OG에서 참조하는 YG의 객체가 mark되지 않는 문제를 해결합니다.</li>\n</ul>\n<h2 id=\"old-generation에서의-gc\" style=\"position:relative;\"><a href=\"#old-generation%EC%97%90%EC%84%9C%EC%9D%98-gc\" aria-label=\"old generation에서의 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old Generation에서의 GC</h2>\n<hr>\n<p>Old Generaion(OG)영역의 경우, YG영역에서 특정기간 이상 살아남은 객체들이 존재하는 영역입니다. 데이터가 가득 차면 GC를 수행하므로 그만큼 GC실행빈도는 적고, Stop the wolrd(STW)시간은 약 10배 이상 깁니다.</p>\n<p>GC의 STW시간은 애플리케이션 실행 성능에 큰 영향을 미칩니다. STW를 줄이는것이 GC의 역사라고 해도 과언이 아닐 정도로, GC에서 중요한 지표로 사용됩니다.</p>\n<p>여러가지 GC 알고리즘이 있지만, JDK8 이하 버전에서 사용된 SerialGC, ParallelGC JDK9이상 버전에서 사용중인 G1GC, JDK15에서 Production버전으로 준비되어 좋은 성능을 내고있는 ZGC에 대해서 Reference탭에 있는 링크를 통해 확인해주세요.</p>\n<h2 id=\"serial-gc--xxuseserialgc\" style=\"position:relative;\"><a href=\"#serial-gc--xxuseserialgc\" aria-label=\"serial gc  xxuseserialgc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial GC (-XX:+UseSerialGC)</h2>\n<hr>\n<p>YG영역에서는 앞부분 에서 설명한 GC를 그대로 수행하지만, OG 영역에서는 mark&#x26;sweep 이후 각 객체들이 연속되게 쌓이도록 Compaction 과정을 수행합니다. JDK 8버전 이하에서, 클라이언트 애플리케이션을 위한 GC 기본값으로 사용했습니다.</p>\n<h2 id=\"parallel-gc--xxuseparallelgc\" style=\"position:relative;\"><a href=\"#parallel-gc--xxuseparallelgc\" aria-label=\"parallel gc  xxuseparallelgc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel GC (-XX:+UseParallelGC)</h2>\n<p>SerialGC와 기본 알고리즘은 같지만, GC를 처리하는 스레드의 수가 여러개라는 차이가 있습니다. JDK8버전 이하에서, 서버 애플리케이션을 위한 GC 기본값으로 사용됩니다.</p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://d2.naver.com/helloworld/1329\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Naver D2,  Java Garbage Collection</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=vZRmCbl871I&#x26;list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&#x26;index=219\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">[10분 테코톡] 👌던의 JVM의 Garbage Collector</a></p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle ZGC</a></p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Oracle G1GC Tuning</a></p>\n<p><a href=\"https://coding-factory.tistory.com/829\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">코딩팩토리, [Java] 가비지 컬렉션(GC, Garbage Collection) 총정리</a></p>\n<p><a href=\"https://nobilitycat.tistory.com/entry/Mark-and-Sweep\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">고귀양이 노트, Mark &#x26; Sweep</a></p>\n<p><a href=\"https://steady-coding.tistory.com/590\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">느리더라도 꾸준하게, [Java] G1 GC의 동작 과정</a></p>","id":"05a833b7-9ea2-5502-8e4c-96942496c98e","fields":{"slug":"jvm의-garbage-collector-동작방법"},"frontmatter":{"date":"2022-09-23","title":"JVM의 Garbage Collector 동작방법","category":"tech","tags":["java","jvm","garbage collector"],"banner":"/assets/bg/3.jpg"},"timeToRead":2},{"excerpt":"Intro 여기 링크에서도 자세한 설명을 확인할 수 있습니다. 함수의 메소드와 arguments: 제로초님 블로그 자바스크립트 this 바인딩 우선순위 : 김정환님 블로그 Function.prototype의 call, apply, bind 메서드,\n공부를 해도 사용시에 헷갈릴때가 많아서 정리합니다..! call, apply Call과 Assign은 함수에 객체를 바인딩 후 호출하는 방법입니다. Javascript…","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>여기 링크에서도 자세한 설명을 확인할 수 있습니다.</p>\n<ul>\n<li><a href=\"https://www.zerocho.com/category/JavaScript/post/57433645a48729787807c3fd\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">함수의 메소드와 arguments: 제로초님 블로그</a></li>\n<li><a href=\"http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바스크립트 this 바인딩 우선순위 : 김정환님 블로그</a></li>\n</ul>\n<p>Function.prototype의 call, apply, bind 메서드,\n공부를 해도 사용시에 헷갈릴때가 많아서 정리합니다..!</p>\n<h2 id=\"call-apply\" style=\"position:relative;\"><a href=\"#call-apply\" aria-label=\"call apply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>call, apply</h2>\n<p>Call과 Assign은 함수에 객체를 바인딩 후 호출하는 방법입니다.</p>\n<p>Javascript에서는 함수 역시 객체이므로, 함수 객체 내에서 call, apply, bind 메서드 역시 객체의 프로퍼티 메서드로 가지고있습니다.</p>\n<p>따라서 <strong>myFunction.call()</strong>, **myFunction.bind()**와 같은 형태로 호출해서 사용하지만, 그 역할은 **myFunction()**과 비슷합니다.</p>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">myMethod</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> arg3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr <span class=\"token operator\">=</span> <span class=\"token string\">\"my attr\"</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">,</span> arg3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">myMethod</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//result</span>\n<span class=\"token comment\">// myattr 1 2 3</span>\n<span class=\"token comment\">// myattr 1 2 4</span>\n<span class=\"token comment\">// myattr 1,2,5</span></code></pre></div>\n<p>예시와 결과로 알 수 있듯, call(null, arg, arg2, arg)와 apply(null, [arg1, arg2, arg3])은 메서드 호출의 역할을 함을 알 수 있습니다.</p>\n<p>그렇다면 첫 번째 인자는 어떤 역할을 수행할까요?</p>\n<p>바로 this 객체를 바인딩 역할을 수행합니다.</p>\n<p>예시는 어떻게 출력될까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">attr</span><span class=\"token operator\">:</span> <span class=\"token string\">\"myattr\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">attr</span><span class=\"token operator\">:</span> <span class=\"token string\">\"your attr\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>너무 티나는 예시때문에 알 수 있듯 아래와 같이 출력됩니다.</p>\n<p>your attr 1 2 3</p>\n<p>myMethod.call의 첫 번째 인자가 실행 컨텍스트를 바꿨기 때문이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> va <span class=\"token operator\">=</span> <span class=\"token string\">\"globalValue\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"asd\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">myFunc2</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> va <span class=\"token operator\">=</span> <span class=\"token string\">\"lexicalSocpe\"</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//(1)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//(2)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmyObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"callValue\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"arg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이건 본문과는 관련성이 떨어지지만 조금 헷갈리는 예제네요~</p>\n<p>(1): Lexical scope에 의해 \"lexicalSocpe\"가 출력됩니다.</p>\n<ul>\n<li>함수가 실행될 때, 변수 참조 체인은 Call Stack이 아닌 Lexical stack에서 참조된다는 의미입니다.</li>\n</ul>\n<p>(2): call함수가 this를 교체했으므로, \"callValue\"가 출력됩니다.</p>\n<ul>\n<li>myFunc.call에서, myFunc.va = \"callValue\"로 교체해 실행합니다.</li>\n</ul>\n<h2 id=\"bind\" style=\"position:relative;\"><a href=\"#bind\" aria-label=\"bind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>bind</h2>\n<p>Function.prototype.bind는 apply, call과 조금 다릅니다,</p>\n<p>apply, call 은 bind + execute였다면, bind는 메서드와 오브젝트를 바인딩합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">myObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">log</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>va<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> binded <span class=\"token operator\">=</span> myObj<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">va</span><span class=\"token operator\">:</span> <span class=\"token string\">\"binded value\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">binded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// result: bindex value</span></code></pre></div>\n<p>이렇게 this가 바뀌는 것은, new 키워드에서도 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Persion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span> age</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">introduce</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> myeonggyu <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mklee\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyeonggyu<span class=\"token punctuation\">.</span><span class=\"token function\">introduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// mklee 23</span></code></pre></div>\n<p>!! 글을 작성하다가 알게되었는데, 위 예시의 log선언부를 익명함수로 고치면 this.attr이 undefinded가 출력됩니다. 익명함수는 무조건 this가 루트를 가르키는듯 합니다.</p>\n<p>위에서 new를 이용해 this를 바인딩한것이 <strong>new 바인딩</strong>,</p>\n<p>bind,call,apply를 통해 바인딩한것이 <strong>명시적 바인딩</strong>,</p>\n<p>상위객체의 this값을 가지는 방법으로 바인딩되는것이 <strong>암시적 바인딩입니다.</strong></p>\n<p>결과적으로, 바인딩 우선순위는 <strong>new > 명시적 > 암시적</strong> 바인딩 순으로 결합되며,</p>\n<p><a href=\"http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">자바스크립트 this 바인딩 우선순위 : 김정환님 블로그</a>에 잘 설명되어있습니다.</p>\n<h2 id=\"close\" style=\"position:relative;\"><a href=\"#close\" aria-label=\"close permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Close</h2>\n<p>사용되는것이 종종 보이긴 하지만, 볼때마다 헷갈려서 학습하곤 합니다. 관련 내용을 찾아가다 보면 Javascript동작구조에 대한 재미있는 글들이 많이 보이니, 위 글에서 얻은 키워드를 바탕으로 더 찾아보시면 도움될것 같습니다.</p>","id":"92725c1b-dfcb-51fb-88ee-3532106d1a93","fields":{"slug":"javascript-function-call-apply-bind-메서드"},"frontmatter":{"date":"2020-08-14","title":"[Javascript Function] call, apply, bind 메서드","category":"tech","tags":["javascript"],"banner":null},"timeToRead":2},{"excerpt":"본문은 Typescript 핵심 개념 을 번역(+ 개인적인 의견 추가)한 글입니다. OOP에 대한 기본 지식이 있으신 분은 Learn Typescript in Y minutes또는 MS 공식 DOCS에서 문법만 훑어보시면 좋습니다. 타입스크립트를 접했을때 드는 느낌은 OOP + Compile + javascript => typescript로 요약할 수 있겠습니다. typechecking, OOP개념이 분명하지 않은 Javscript(이하 JS…","html":"<blockquote>\n<p>본문은 <a href=\"https://www.educative.io/blog/advanced-typescript-concepts\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Typescript 핵심 개념</a> 을 번역(+ 개인적인 의견 추가)한 글입니다.</p>\n</blockquote>\n<blockquote>\n<p>OOP에 대한 기본 지식이 있으신 분은 <a href=\"https://learnxinyminutes.com/docs/typescript/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Learn Typescript in Y minutes</a>또는 <a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MS 공식 DOCS</a>에서 문법만 훑어보시면 좋습니다.</p>\n</blockquote>\n<hr>\n<p>타입스크립트를 접했을때 드는 느낌은 OOP + Compile + javascript => typescript로 요약할 수 있겠습니다.</p>\n<p>typechecking, OOP개념이 분명하지 않은 Javscript(이하 JS)의 단점을 커버하는 언어입니다.</p>\n<p>실제로 typechecking을 하지 않음으로 인해 발생하는 런타임에러는 꽤 큰 골칫거리기에 , typechekcing, compilable한 typescript의 개념이 아주 매력적입니다.</p>\n<p>그리고 javascript에 익숙하다면 학습난이도도 높지 않은듯 합니다.</p>\n<p><em>(통번역입니다. 오역주의) Lets go!</em></p>\n<hr>\n<p>자바스크립트를 사용할 때, 디버깅은 많은 개발자들의 골칫거리입니다! 프로그램을 실행하고, 버그를 찾고 고치기를 반복합니다. 디버깅을 시작한지 몇시간 뒤에야 마침내 버그를 고치곤 합니다. 이러한 문제는 자바스크립트같이 컴파일을 하지 않는 언어(인터프리터 언어)의 공통적인 특징입니다.</p>\n<p><em>python 역시 타입체킹을 하지 않는 인터프리터 언어인데 디버깅이나 런타임 에러 문제에 대해 논의하는것을 보지 못했네요.. 왜 그럴까요..?</em></p>\n<p>이런 자바스크립트의 단점을 고치기 위해 Microsoft는 Typescript를 만들어냅니다. 거대한 팀들이 Typescript의 장점을 깨닫고 그들의 기술스택에 적용하면서, 많은 개발자들이 이를 학습하게 되었습니다!</p>\n<ul>\n<li>Typescript란?</li>\n<li>Strict types 소개</li>\n<li>Typescript와 OOP(객체지향 프로그래밍)</li>\n<li>Typescript의 타입들</li>\n<li>그 외 알아야하는 것들</li>\n</ul>\n<h2 id=\"typescript란\" style=\"position:relative;\"><a href=\"#typescript%EB%9E%80\" aria-label=\"typescript란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript란?</h2>\n<p>Microsoft가 만들고 관리하는, javascript의 모집합(superset)으로, 모든 자바스크립트 코드는 Typescript에서 유효하다는 특징을 가지고있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">즉, JS로 할 수 있는건, TS로 할 수 있다는 뜻.</code></pre></div>\n<p>TS는 아래 두개의 핵심 개념에 초점을 맞춘 Application 규모(대규모) 개발을 위한 Javascript입니다.</p>\n<ul>\n<li>\n<p>현재버전 이후의 자바스크립트 엔진의 기능을 현재 자바스크립트 엔진에서 제공</p>\n</li>\n<li>\n<p>Javascript에서 type system 제공</p>\n</li>\n</ul>\n<p>Typescript의 구성요소는</p>\n<ol>\n<li>기본적으로 javascript와 추가적인 특징/문법들로 이루어진 Typescript 자체 문법과,</li>\n<li>Typescript 코드를 javascript 코드로 변환해주는 컴파일러,</li>\n<li>Compiler 파이프라인의 끝에서 에디터같은 기능을 제공하는 Language service가 있습니다.</li>\n</ol>\n<p>(3번기능은 지금으로서 어떤 기능인지 와닿지 않네요.)</p>\n<p>Typescript를 사용하는 이유!</p>\n<ul>\n<li>\n<p>타입체킹 : MS나 Google같은 거대한 팀들이 Typescript의 정적 타입 체크가 개발 프로세스 간소화에 있어 유용함을 알아냈습니다.</p>\n</li>\n<li>\n<p>객채지향 프로그래밍 : Typescript는 인터페이스, 상속, 클래스 등의 객체지향 프로그래밍 개념을 지원합니다.</p>\n</li>\n<li>\n<p>컴파일 : Typescript는 인터프리팅 언어인 JS와 달리 컴파일을 지원하며, 이는 여러분 코드의 컴파일 에러를 찾아주고, 디버깅을 간편하게 해줍니다.</p>\n</li>\n</ul>\n<p>Typescript 설치</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> <span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> typescript</code></pre></div>\n<p>compile</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> tsc hellowrold.ts</code></pre></div>\n<p>npm을 사용하지 않는다면, <a href=\"https://www.typescriptlang.org/#download-links\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">링크</a>에서 typescript패키지를 다운받을 수 있습니다.</p>\n<h2 id=\"typescript의-장점과-한계\" style=\"position:relative;\"><a href=\"#typescript%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%ED%95%9C%EA%B3%84\" aria-label=\"typescript의 장점과 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typescript의 장점과 한계</h2>\n<h3 id=\"타입체킹\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%B2%B4%ED%82%B9\" aria-label=\"타입체킹 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입체킹</h3>\n<p>Javascript는 동적으로 타입을 체킹하는 언어로, 오직 런타임에서만 에러를 찾을 수 있음을 의미합니다. 이것은 복잡한 프로젝트를 진행하는 큰 팀에게 거대한 단점으로, 코드에 대한 모든 실수를 미리 찾는 방법이 더 수월합니다.</p>\n<p>Typescript는 선택적(optional) 정적 타입체킹을 제공하므로, 변수는 타입을 바꿀 수 없으며, 특정 값만을 받을 수 있습니다. 이를 통해 Typescript 컴파일러가 에러가 발생하기 쉬운 코드에서 더 많은 버그를 잡을 수 있도록 합니다. 또한 타입은 가독성있고 쉽게 리팩토링하기 위한 구조를 만듭니다.</p>\n<p>Typescript와 Javacsript의 차이점을 보고싶다면 <a href=\"https://www.typescriptlang.org/#download-links\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a>로!</p>\n<h3 id=\"ide-지원\" style=\"position:relative;\"><a href=\"#ide-%EC%A7%80%EC%9B%90\" aria-label=\"ide 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IDE 지원</h3>\n<p>Typescript가 정적 타입체킹을 지원하므로, 코드 에디터 또는 IDE에서 더 많은 이점을 가질 수 있다.</p>\n<ol>\n<li>자동완성( Javascript의 변수는 type이 존재하지 않으므로, 변수에 대한 자동완성을 지원하지 않는다. 지원하더라도, 에디터 또는 IDE는 변수의 타입을 모르기에, 적절한 메서드명이나 애트리뷰트 명을 자동완성할 수 없음),</li>\n<li><a href=\"https://visualstudio.microsoft.com/ko/services/rich-code-navigation/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">code navigation</a>,</li>\n<li>type에 의한 Error flagging</li>\n</ol>\n<p>이런 IDE에서의 기능 지원은, Tpyescript로 작성해야하는 코드량이 Javascript보다 많더라도, 생산성 경쟁력에 많은 부분을 기여하고 있다.</p>\n<p>Typescrpt3를 지원하는 인기있는 IDE들</p>\n<ul>\n<li>MS Visual Studio</li>\n<li>Webstorm</li>\n<li>Visual Studio Code</li>\n<li>Atom</li>\n</ul>\n<h3 id=\"browser-호환성\" style=\"position:relative;\"><a href=\"#browser-%ED%98%B8%ED%99%98%EC%84%B1\" aria-label=\"browser 호환성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Browser 호환성</h3>\n<p>브라우저 호환성은 Typescript의 강력한 특징중 하나입니다. Typescript는 모든 모던 브라우저와 호환 가능한 코드로 Typescript 코드를 컴파일합니다. 이런 높은 호환성이 가능한 이유는, Typescript코드를 모든 기기와 플랫폼, 브라우저를 지원하는 vanilla JS(순수 Javscript)로 컴파일할 수 있기 때문에 가능합니다.</p>\n<p>Typescript를 사용하며 얻는 많은 장점이 있음에도, 이것은 완벽한 솔루션은 아닙니다.</p>\n<hr>\n<p>코드 가독성을 높히는 것에 있어 하나의 단점은, VanillaJS를 사용할 때와 비교해 Typescript를 사용할때는 가독성있는 코드를 위해 더 많은 코드를 써야하고,\n이는 잠재적으로 여러분의 개발 시간을 증가시킵니다.</p>\n<hr>","id":"a68d2bfe-4173-51c0-87f0-33ad79aba22a","fields":{"slug":"타입스크립트-핵심-concepts-번역"},"frontmatter":{"date":"2020-08-01","title":"타입스크립트 핵심 Concepts! (번역)","category":"tech","tags":["typescript","javascript"],"banner":null},"timeToRead":2},{"excerpt":"주제 : 운영체제 메모리 관리: 물리메모리 할당 방식! 목차 연속 메모리 할당 고정 분할 방식 Fixed Allocation 가변 분할 방식 Variable Allocation 비연속 메모리 할당 세그멘테이션 Segmentation 페이징 Paging ---continue--- 페이징/세그멘테이션 혼합 페이지 요구 Demand Paging…","html":"<blockquote>\n<p>주제 : 운영체제 메모리 관리: 물리메모리 할당 방식!</p>\n</blockquote>\n<ul>\n<li>\n<p>목차</p>\n</li>\n<li>\n<p>연속 메모리 할당</p>\n<ul>\n<li>고정 분할 방식 Fixed Allocation</li>\n<li>가변 분할 방식 Variable Allocation</li>\n</ul>\n</li>\n<li>\n<p>비연속 메모리 할당</p>\n<ul>\n<li>세그멘테이션 Segmentation</li>\n<li>페이징 Paging</li>\n</ul>\n<p>---continue---</p>\n<ul>\n<li>페이징/세그멘테이션 혼합</li>\n<li>페이지 요구 Demand Paging</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속 할당 방식</h1>\n<p>하나의 프로그램이 실행되는 메모리 순서를 연속적으로 물리 메모리에 할당하는 방법</p>\n<h3 id=\"고정-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%A0%95-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"고정 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고정 분할 방식</h3>\n<p>물리적 메모리를 몇 개의 영구적인 분할로 나누어 각각의 영역에 프로그램을 적재시킨다.</p>\n<p>심각한 내부 단편화가 발생할 수 있다.<br>\n예를 들어 256MB의 메모리를 32MB씩 분할한다면, 2MB의 메모리만이 필요한 프로그램이 실행되는 경우 30MB의 내부 단편화가 발생한다.<br>\n(보통은 다양한 크기의 프로그램을 실행하기 위해 메모리를 다양한 크기로 분할한다.)</p>\n<h3 id=\"가변-분할-방식\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80-%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"가변 분할 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 분할 방식</h3>\n<p>프로그램이 실행/종료되는 시점마다 프로그램 크기에 맞는 메모리를 할당/해제하는 방식.</p>\n<p>첫 할당 이후 메모리 위치를 재정리할 수 없으므로, 다양한 크기의 프로그램에 대해 메모리 할당/해제를 반복하다 보면 아래와 같이 외부 단편화가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-----------------------------------------------------\n| running(120MB) | empty(20MB) | running(8MB) | ...</code></pre></div>\n<hr>\n<h1 id=\"비연속-할당-방식\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"비연속 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속 할당 방식</h1>\n<p>프로그램의 메모리 할당 요청을 비연속적으로 메모리에 할당하는 방식. swap space를 사용하는 가상화 기법이 활용된다.</p>\n<h3 id=\"세그먼트-\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-\" aria-label=\"세그먼트  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그먼트 :</h3>\n<p>메모리를 나누는 단위.</p>\n<p>세그먼트: 프로세스 크기에 따라 가변 크기를 갖는 <strong>물리 메모리 분할 단위</strong></p>\n<hr>\n<h3 id=\"페이지--프레임\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80--%ED%94%84%EB%A0%88%EC%9E%84\" aria-label=\"페이지  프레임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 / 프레임</h3>\n<p>페이지 : 고정 크기로 <strong>가상 메모리를 분할하는 단위</strong></p>\n<p>프레임 : 페이지와 1:1로 매핑되는 <strong>물리 메모리 분할 단위</strong></p>\n<p>페이지와 프레임은 페이지 테이블을 매개로 연결된다.</p>\n<p>따라서, 프로세스가 page(N)을 가지고있을 경우, OS는 가상주소 N에 데이터를 요청하고, 가상주소 N은 페이지 테이블의 정보를 통해 물리 주소인 frame(K)에 접근한다. 이 때, frame(k)주소가 존재하지 않을 경우, swap space(주로 보조 기억장치)에서 데이터를 가져온다. 이는 page fault라고 불리며, 이는 성능 저하를 일으키기도 하며 segmentation-paging 기법에서 Thrashing 등을 일으켜 심각한 성능 저하를 내기도 한다.</p>\n<hr>\n<h3 id=\"페이지-테이블--페이징-기법\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94--%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\"페이지 테이블  페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 테이블 / 페이징 기법</h3>\n<p><strong>페이징 기법</strong> : 가상 메모리를 <strong>고정 크기</strong>로 분할한 페이지를 통해 메모리를 관리하는 방식.<br>\n만약 프로세스가 페이지의 크기보다 적은 메모리를 필요로 하는 경우, **내부 단편화((페이지)내부의 메모리 일부가 사용되지 않아 낭비되는 현상)**가 발생한다.</p>\n<p>(페이지의 크기 :프로세스의 크키가 커지면서 4KB > 4MB까지 크기가 커짐.)</p>\n<p>LRU, FIFO, LFU, NUR등의 페이지 교체 알고리즘을 통해 물리 메모리를 관리.</p>\n<p><strong>페이지 테이블</strong> : 페이지와 프레임의 매칭 정보를 담고있는 테이블.</p>\n<p>프로세스가 가상 메모리(page)의 정보를 hit할때 실제 물리 메모리 주소(frame)로 변환하는 역할을 수행한다.</p>\n<p>페이지의 크기가 커지면 아래와 같은 변화가 생긴다.</p>\n<ul>\n<li>내부 단편화가 증가한다.</li>\n<li>Page fault(페이지 요청 실패)가 감소한다.</li>\n<li>페이지 테이블의 크기가 감소한다.\n<ul>\n<li>(TMI)페이지 테이블 비례 : 전체 메모리 사이즈 /  페이지 크기</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"세그멘테이션-테이블-세그멘테이션-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 테이블 세그멘테이션 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션 테이블 /세그멘테이션 기법</h3>\n<p><strong>세그멘테이션 기법</strong> : 하나의 프로세스가 사용하는 메모리의 크기 단위로 가상 주소를 관리하는 기법.</p>\n<p>프로세스별로 요구하는 메모리가 다르므로, 세그먼트의 크기는 가변적이다.</p>\n<p>세그멘테이션 테이블 :</p>\n<ul>\n<li>물리 메모리에서 세그먼트의 <strong>start address</strong></li>\n<li>가변적인 세그먼트의 크기를 나타내는 <strong>limit</strong></li>\n</ul>\n<p>위 두 가지를 보관하고 있는 자료구조이다.</p>\n<hr>\n<h3 id=\"세그멘테이션-페이징-혼합-기법\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%98%BC%ED%95%A9-%EA%B8%B0%EB%B2%95\" aria-label=\"세그멘테이션 페이징 혼합 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세그멘테이션-페이징 혼합 기법</h3>\n<p>.</p>\n<h3 id=\"pcb-process-control-block\" style=\"position:relative;\"><a href=\"#pcb-process-control-block\" aria-label=\"pcb process control block permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PCB: Process Control Block</h3>\n<p>프로세스 생성 시 커널 스택만들어지는 자료구조 : Status / Pointer(addr)/ Identifier / PC / Priority 등을 저장한다.\n<img src=\"https://t1.daumcdn.net/cfile/tistory/995A6E395A5E0DAF18\" alt=\"PCB\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">/</th>\n<th align=\"center\">연속 메모리 할당</th>\n<th align=\"center\">가상화(swap)</th>\n<th align=\"center\">관리 테이블</th>\n<th align=\"center\">단편화</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">고정 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">가변 분할 방식</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">-</td>\n<td align=\"center\">외부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">페이징 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">페이지테이블</td>\n<td align=\"center\">페이지 내부 단편화</td>\n</tr>\n<tr>\n<td align=\"left\">세그멘테이션 기법</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">세그먼테이션 테이블</td>\n<td align=\"center\">세그멘테이션 외부 단편화</td>\n</tr>\n</tbody>\n</table>","id":"0db54144-01a0-551b-bfac-e41061832274","fields":{"slug":"continue-os-메모리파트-정리"},"frontmatter":{"date":"2020-05-24","title":"[Continue,OS] 메모리파트 정리","category":"tech","tags":["운영체제","computerscience"],"banner":null},"timeToRead":2},{"excerpt":"Intro 오늘 소개할 주제는 webhook 입니다. 서비스를 배포하거나 관련 공부를 해보셨다면, github과 Jenkins같은 CI도구를 연동하며 github에서 푸쉬를 비롯한 특정 이벤트를 jenkins로 전달해주기 위해 연동해본 경험이 있습니다. 이때 github서버는 Jenkins가 별다른 요청을 하지 않아도 서버 내에서 특정 이벤트가 일어났을 때 Jenkins…","html":"<h1 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h1>\n<p>오늘 소개할 주제는 <strong>webhook</strong> 입니다.</p>\n<p>서비스를 배포하거나 관련 공부를 해보셨다면,<br>\ngithub과 Jenkins같은 CI도구를 연동하며 github에서 푸쉬를 비롯한 특정 이벤트를 jenkins로 전달해주기 위해 연동해본 경험이 있습니다.</p>\n<p>이때 github서버는 Jenkins가 별다른 요청을 하지 않아도 서버 내에서 특정 이벤트가 일어났을 때 Jenkins로 관련 정보들을 보내줍니다.<br>\n이것은 \"웹훅\"이라고 불리는 과정인데요, 일반적으로 클라이언트가 서버에게 정보 또는 행위를 요청하는 방식과는 다릅니다.</p>\n<p>오늘은 위에서 설명한 웹훅이 어떻게 가능한지 간단하게 공부하려합니다.</p>\n<hr>\n<p>클라이언트에서 서버의 자원을 이용하기 위해, 또는 서버를 동작하기 위한 인터페이스로 Web API를 사용합니다.</p>\n<p>이와 반대로 <strong>역방향 API, 서버에서 발생하는 이벤트를 처리하기 위해 Webhook을 사용한다는 것을 알게되었습니다.</strong></p>\n<p>웹 API를 통해 클라이언트의 요청을 처리하는 방식은 일상적인 방법이기에 무리없이 관련 동작을 이해하고 개발에 사용했지만,<br>\n서버에서 발생하는 이벤트를 클라이언트로 전달하는 과정은 쉽사리 이해되지 않았습니다.<br>\n또한 순수하게 이것이 어떤 원리로 가능한지 궁금하기도 했습니다.</p>\n<h1 id=\"principle\" style=\"position:relative;\"><a href=\"#principle\" aria-label=\"principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Principle</h1>\n<p>핵심적인 원리에 접근하는것은 어렵지 않았습니다.</p>\n<p>webhook은 언제부턴가 익숙한 개념이 되어있었고, RFC문서가 존재할것이라 생각해서 <a href=\"https://tools.ietf.org/html/rfc8030\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rfc webhook</a>으로 검색한 결과 HTTP/2.0 부터 지원하는 <strong>Web push</strong>스펙을 확인할수 있었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">\n    +-------+           +--------------+       +-------------+\n    <span class=\"token operator\">|</span>  UA   <span class=\"token operator\">|</span>           <span class=\"token operator\">|</span> Push Service <span class=\"token operator\">|</span>       <span class=\"token operator\">|</span> Application <span class=\"token operator\">|</span>\n    +-------+           +--------------+       <span class=\"token operator\">|</span>   Server    <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>               +-------------+\n        <span class=\"token operator\">|</span>      Subscribe       <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>---------------------<span class=\"token operator\">>|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>       Monitor        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span><span class=\"token operator\">&lt;=</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span><span class=\"token operator\">>|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>          Distribute Push Resource           <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>--------------------------------------------<span class=\"token operator\">>|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token builtin class-name\">:</span>                      <span class=\"token builtin class-name\">:</span>                      <span class=\"token builtin class-name\">:</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>     Push Message     <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>    Push Message      <span class=\"token operator\">|</span><span class=\"token operator\">&lt;</span>---------------------<span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span><span class=\"token operator\">&lt;</span>---------------------<span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n        <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>                      <span class=\"token operator\">|</span>\n\n                      Figure <span class=\"token number\">1</span>: WebPush Architecture</code></pre></div>\n<p>RFC 8030에 소개된 overview에 소개된 webpush의 구조입니다. (UA: user agent)</p>\n<p>사실 이 그림을 보자마자 웹훅을 위한 Push service가 따로 존재하는구나! Push sevice가 메시지 브로커 역할을 하는군! 이라고 이해하시면 웹훅을 사용할때 큰 문제가 없습니다.</p>\n<p>발행/구독 구조에서 확인할 수 있는 push, monitor, message를 이해하신다면</p>\n<p>Subscriber : UA (user agent)<br>\nPublisher : Application Server<br>\nBroker : <strong>Push Service</strong></p>\n<p>라고 생각하시면 됩니다.</p>\n<p>이는 아래와 같이 동작합니다.</p>\n<ol>\n<li>UA가 Application Server의 push service를 구독하고, push service를 모니터링합니다.</li>\n<li>이후 Application Server에서 UA가 원하는 동작이 발생하고 trigger를 통해 이벤트 메서드를 호출합니다.</li>\n<li>Application server는 발생한 Action에 대한 정보를 담은 메시지를 Push service에 전달하고,</li>\n<li>Push service는 구독 정보를 참조해 관련있는 Subscripbers에게 메시지들을 전달합니다.</li>\n</ol>\n<img src=\"https://www.researchgate.net/profile/Ashwin_Makwana/publication/301350598/figure/fig1/AS:352171422961666@1460975618330/Publish-Subscribe-Model.png\"/>\n<p>&#x3C;그림: 발행/구독 모델></p>\n<hr>\n<h3 id=\"features\" style=\"position:relative;\"><a href=\"#features\" aria-label=\"features permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Features</h3>\n<p>발행/구독구조의 특징과 함께 Webpush에 존재하는 몇가지 특징이 있습니다.</p>\n<p>User Agent(이하 UA)가 구독을 시작하며 Webpush 시나리오가 시작됩니다.<br>\n구독은 UA와 Push server, Application server간 연결을 뜻하며, HTTPS(port:443)위에서만 동작합니다.</p>\n<p>구독과 관련된 정보는 push service에 저장되며, 이 정보를 UA와 Application server가 각각 사용합니다.</p>\n<hr>\n<p><em>실제 API 문서와 RFC의 overview에 소개된 내용을 위주로 특징들을 리스트해보았습니다.</em></p>\n<ul>\n<li>\n<p>UA는 모든 incomming messages를 모니터링하기 위해 구독정보를 사용합니다.</p>\n</li>\n<li>\n<p>Application server는 trigger가 발생한 Action 관련 정보들을 push service에게 던지는 과정을 위해 구독 정보를 사용합니다.</p>\n</li>\n<li>\n<p>Push API는 클라이언트와 서버 간 비동기적 통신을 지원합니다</p>\n<ul>\n<li>\n<p>Push service는 UA가 비활성 상태이더라도 메시지를 전달하기 위해 활성상태가 될때까지 메시지를 저장합니다.</p>\n</li>\n<li>\n<p>마찬가지로 Push service는 Application Server가 비활성 상태이더라도 저장된 Push message를 UA에게 전달합니다</p>\n</li>\n<li>\n<p>(WebPush API의 이러한 특징과 Notification API를 이용해 Chrome에서는 알림 API를 지원합니다!)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>UA와 Application server가 통신중일때도 push service는 동작합니다.<br>\n하지만 fetch, websocket등의 직접통신 API들에 비해 리소스가 많이 소요되고 지연현상이 많아 UA와 Application server가 활성연결 상태가 아닐 때 사용하는것을 권장하고 있습니다.</p>\n</li>\n</ul>\n<h1 id=\"ending\" style=\"position:relative;\"><a href=\"#ending\" aria-label=\"ending permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ending</h1>\n<p>W3C의 API 스펙과 RFC8030의 Overview탭을 위주로 작성했습니다.</p>\n<p>설명한 특징 이외에도 다양한 동작 시나리오 / 특징들이 있습니다.<br>\n아래 그림에서는 User Agent를 webpage와 service worker까지 추가해서 설명하고있습니다.</p>\n<p>저처럼 WebPush에 대한 호기심이 생기셨다면, 추가로 읽어보시는것도 추천드립니다..!</p>\n<img src=\"https://www.w3.org/TR/push-api/sequence_diagram.png\" />\n<p>&#x3C;그림 Webpush API 메서드 동작 시나리오 (WC3)></p>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<p><a href=\"https://medium.com/@shlee1353/http1-1-vs-http2-0-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-5727b7499b78\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http1,2 차이점</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc8030\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RFC8030 Web push</a></p>\n<p><a href=\"https://www.w3.org/TR/push-api/#application-server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">W3C Webpush API spec</a></p>","id":"9673e296-0c47-5baf-a5ee-c22d57f5c9ba","fields":{"slug":"웹훅-webhook-이-뭐야-http-2-0-webpush-스펙-요약"},"frontmatter":{"date":"2020-05-10","title":"웹훅 (webhook)이 뭐야?, HTTP/2.0 Webpush 스펙 요약","category":"tech","tags":["http","webhook"],"banner":null},"timeToRead":2},{"excerpt":"React.js 기초 튜터리얼을 학습하며 작성하는 글입니다. 오류가 있을 수 있으며, 이메일을 통한 오류 수정 환영합니다. JSX 위와 같은 문법으로 JSX를 작성한다. JSX는 Javascript의 String도 아니고, HTML역시 아닌데, JSX는 React Element를 생성하고, DOM에 렌더링한다. React.js의 컴포넌트 JSX의 중괄호 안에는 모든 Javascript 표현식이 들어갈 수 있다. 부연설명 -  이는 React…","html":"<blockquote>\n<p><a href=\"https://ko.reactjs.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React.js 기초 튜터리얼</a>을 학습하며 작성하는 글입니다. 오류가 있을 수 있으며, 이메일을 통한 오류 수정 환영합니다.</p>\n</blockquote>\n<h1 id=\"jsx\" style=\"position:relative;\"><a href=\"#jsx\" aria-label=\"jsx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSX</h1>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span> hello <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span></code></pre></div>\n<p>위와 같은 문법으로 JSX를 작성한다.</p>\n<p>JSX는 Javascript의 String도 아니고, HTML역시 아닌데, JSX는 <strong>React Element</strong>를 생성하고, DOM에 렌더링한다.</p>\n<h3 id=\"reactjs의-컴포넌트\" style=\"position:relative;\"><a href=\"#reactjs%EC%9D%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"reactjs의 컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.js의 컴포넌트</h3>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'mklee'</span>\r\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n    element<span class=\"token punctuation\">,</span>\r\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">gelElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>JSX의 중괄호 안에는 모든 Javascript 표현식이 들어갈 수 있다.</p>\n<p>부연설명 -  이는 React의 컴포넌트가 로직과 뷰를 분리하지 않는다는 특성과 관련있다. 컴포넌트는 엘리먼트를 포함하는 개념으로만 알고있자.</p>\n<p>(참고로, JSX는 뷰와 로직이 섞여있기는 하지만, Javascript에 더 가깝기에, Camelcase 변수 표기법을 사용한다.)</p>\n<ul>\n<li>JSX 예제</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>\r\n<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\r\n    <span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>profileURL<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\r\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이처럼,</p>\n<ul>\n<li>Attribute에도 Javascript 표현식이 들어갈 수 있고,</li>\n<li>자식으로 JSX를 포함할 수도 있다.</li>\n<li>인터프리터 언어 특성 상, 줄바꿈 시 자동 세미콜론이 등록되므로, 엘리먼트 범위를 소괄호로 묶어주거나 한 줄에 작성하도록 하자.</li>\n</ul>\n<h1 id=\"react의-엘리먼트-렌더링\" style=\"position:relative;\"><a href=\"#react%EC%9D%98-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"react의 엘리먼트 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React의 엘리먼트 렌더링</h1>\n<hr>\n<p>앞의 예제에서 살펴보았듯,  **ReactDOM.render(element,,target)**를 통해 엘리먼트를 렌더링한다.</p>\n<h3 id=\"렌더링된-엘리먼트-업데이트\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EB%90%9C-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8\" aria-label=\"렌더링된 엘리먼트 업데이트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링된 엘리먼트 업데이트</h3>\n<p>React의 엘리먼트는 불변객체(const로 선언)이므로, 이것의 내용을 변경할 수 없다.</p>\n<p>하지만, 새로운 Element를 생성하고 이를 렌더링하는 방식으로 극복할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>참고 - 이후에 배우는 개념을 학습하면...</p>\n<p>유상태 컴포넌트(엘리먼트 변경이 있는 컴포넌트)는 대부분 한번의 rㅣender하는 방식으로 작성할 수 있다.\r\nReactDom은 변경이 필요한 경우에만 업데이트를 수행한다.</p>\n<h1 id=\"component와-props\" style=\"position:relative;\"><a href=\"#component%EC%99%80-props\" aria-label=\"component와 props permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Component와 Props</h1>\n<hr>\n<p>UI를 분리하여 재사용 가능하도록 하는 React의 유닛을 컴포넌트라고 한다.</p>\n<p>또한, 속성을 나타내는 props 객체를 통해 결과를 표현합니다.</p>\n<p>컴포넌트 선언 시, 이름의 첫글자는 대문자입니다(컨벤션).</p>\n<ul>\n<li>함수 컴포넌트</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Welcome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>props객체를 인자로 받아 React 앨리먼트를 반환하는 Javascript 함수를 유효한 함수 컴포넌트라고 합니다.</p>\n<ul>\n<li>클래스 컴포넌트</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Class Welcome <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>응용 - 사용자 정의 컴포넌트로 엘리먼트 생성</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Welcome name<span class=\"token operator\">=</span><span class=\"token string\">\"mklee\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<h3 id=\"컴포넌트-렌더링\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"컴포넌트 렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 렌더링</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Welcome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Welcome name<span class=\"token operator\">=</span><span class=\"token string\">\"Sara\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n  element<span class=\"token punctuation\">,</span>\r\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"state와-lifecycle\" style=\"position:relative;\"><a href=\"#state%EC%99%80-lifecycle\" aria-label=\"state와 lifecycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>State와 LifeCycle</h1>\n<hr>\n<p>위쪽 파트에서 작성한 시계 코드를 리팩토링 해보자.</p>\n<ul>\n<li>기존 코드</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>UI를 업데이트하기 위해 ReactDOM.render()를 호출해주었는데, state 개념을 활용해 효율적인 코드를 작성한다.</p>\n<ul>\n<li>컴포넌트로 분리하기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Clock</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's props<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n    ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n        <span class=\"token operator\">&lt;</span>Clock date<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\r\n        document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>tick<span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드의 문제점</p>\n<ul>\n<li>한번의 실행이 업데이트를 수행하지 않음</li>\n</ul>\n<p>해결방법?</p>\n<ul>\n<li>state를 사용하자</li>\n<li>state는 props와 유사한 개념</li>\n<li>props와 달리 비공개 객체</li>\n</ul>\n<p>코드 수정하기</p>\n<ul>\n<li>우선, 함수 컴포넌트를 클래스 컴포넌트로 전환하고</li>\n<li>render()의 리턴으로 해당 JSX를 추가</li>\n<li>생성자를 아래와 같이 작성하고, status를 초기화해주기</li>\n<li>React의 컴포넌트 생명주기 메서드인 componentDidMount(), componentDidMount()를 작성해 시계가 랜더링될 때와 언마운트 될때의 수행코드 작성</li>\n<li>매 초 status를 변경해주는 tick함수 작성. (이 떄, status값의 수정은 setStatus를 통해서만 갱신된다)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">Class Clock <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>   \r\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>     \r\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timerID<span class=\"token operator\">=</span><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timerID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n    <span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>it's <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">.</span><span class=\"token function\">toLocaleTimeString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\r\n    <span class=\"token operator\">&lt;</span>Clock <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\r\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>실행과정</p>\n<ul>\n<li>**ReactDOM.render()**의 Clock 컴포넌트의 생성자를 호출하고 status 초기화됨.</li>\n<li>**Clock의 render()**가 호출된다. 이제부터 React에서 화면에 표시될 내용과 Clock의 렌더링 출력을 비교해 DOM을 업데이트한다.</li>\n<li>DOM이 업데이트 된 이후, componentDidMount() (마운트 동작)를 호출하고, 매 초 tick()함수를 호출하며, tick()함수에서는 status를 새로운 날짜로 갱신합니다.</li>\n<li>만약 Clock 컴포넌트가 삭제된다면, clearInterval을 통해 타이머가 중지됩니다.</li>\n</ul>","id":"ca4cdf75-95e5-5ba2-a562-ac1dcf9730af","fields":{"slug":"react-js-기초-튜터리얼-개념-편-1"},"frontmatter":{"date":"2019-09-12","title":"React.js 기초 튜터리얼, 개념 편 [1]","category":"tech","tags":["react"],"banner":null},"timeToRead":3}],"categoryName":"tech"}},"staticQueryHashes":[],"slicesMap":{}}